{"version":3,"file":"strategy-provider.service.js","sourceRoot":"","sources":["../../../../../../libs/cdk/render-strategies/src/lib/strategy-provider.service.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  ChangeDetectorRef,\n  Inject,\n  Injectable,\n  NgZone,\n  Optional\n} from '@angular/core';\nimport {\n  BehaviorSubject,\n  fromEvent,\n  MonoTypeOperatorFunction,\n  Observable\n} from 'rxjs';\nimport { map, shareReplay, switchMap, takeUntil } from 'rxjs/operators';\nimport {\n  mergeDefaultConfig, RxRenderStrategiesConfig, RX_RENDER_STRATEGIES_CONFIG\n} from './config';\nimport {\n  RxStrategies,\n  RxStrategyCredentials,\n  RxStrategyNames,\n  ScheduleOnStrategyOptions\n} from './model';\nimport { onStrategy } from './onStrategy';\n\n/**\n * @description\n * RxStrategyProvider is a wrapper service that you can use to consume strategies and schedule your code execution.\n *\n * @example\n * Component({\n *   selector: 'app-service-communicator',\n *   template: ``\n * });\n * export class ServiceCommunicationComponent {\n *   private currentUserSettings;\n *\n *   constructor(\n *     private strategyProvider: RxStrategyProvider,\n *     private userService: UserService,\n *     private backgroundSync: BackgroundSyncService\n *   ) {\n *     this.userService.fetchCurrentUserSettings\n *       .pipe(\n *         tap(settings => (this.currentUserSettings = settings)),\n *         this.strategyProvider.scheduleWith(\n *           settings => this.backgroundSync.openConnection(settings),\n *           { strategy: 'idle' }\n *         )\n *       )\n *       .subscribe();\n *   }\n * }\n *\n * @docsCategory RxStrategyProvider\n * @docsPage RxStrategyProvider\n */\n@Injectable({ providedIn: 'root' })\nexport class RxStrategyProvider<T extends string = string> {\n  private _strategies$ = new BehaviorSubject<RxStrategies<T>>(undefined);\n  private _primaryStrategy$ = new BehaviorSubject<\n    RxStrategyCredentials<RxStrategyNames<T>>\n  >(undefined);\n\n  private readonly _cfg: Required<RxRenderStrategiesConfig<T>>;\n\n  /**\n   * @description\n   * Returns current `RxAngularConfig` used in the service.\n   * Config includes:\n   * - strategy that currently in use - `primaryStrategy`\n   * - array of custom user defined strategies - `customStrategies`\n   * - setting that is responsible for running in our outside of the zone.js - `patchZone`\n   */\n  get config(): Required<RxRenderStrategiesConfig<T>> {\n    return this._cfg;\n  }\n\n  /**\n   * @description\n   * Returns object that contains key-value pairs of strategy names and their credentials (settings) that are available in the service.\n   */\n  get strategies(): RxStrategies<T> {\n    return this._strategies$.getValue();\n  }\n\n  /**\n   * @description\n   * Returns an array of strategy names available in the service.\n   */\n  get strategyNames(): string[] {\n    return Object.values(this.strategies).map((s) => s.name);\n  }\n\n  /**\n   * @description\n   * Returns current strategy of the service.\n   */\n  get primaryStrategy(): RxStrategyNames<T> {\n    return this._primaryStrategy$.getValue().name;\n  }\n\n  /**\n   * @description\n   * Set's the strategy that will be used by the service.\n   */\n  set primaryStrategy(strategyName: RxStrategyNames<T>) {\n    this._primaryStrategy$.next(\n      <RxStrategyCredentials<RxStrategyNames<T>>>this.strategies[strategyName]\n    );\n  }\n\n  /**\n   * @description\n   * Current strategy of the service as an observable.\n   */\n  readonly primaryStrategy$: Observable<RxStrategyCredentials> =\n    this._primaryStrategy$.asObservable();\n\n  /**\n   * @description\n   * Returns observable of an object that contains key-value pairs of strategy names and their credentials (settings) that are available in the service.\n   */\n  readonly strategies$ = this._strategies$.asObservable();\n\n  /**\n   * @description\n   * Returns an observable of an array of strategy names available in the service.\n   */\n  readonly strategyNames$ = this.strategies$.pipe(\n    map((strategies) => Object.values(strategies).map((s) => s.name)),\n    shareReplay({ bufferSize: 1, refCount: true })\n  );\n\n  /**\n   * @internal\n   */\n  constructor(\n    @Optional()\n    @Inject(RX_RENDER_STRATEGIES_CONFIG)\n    cfg: RxRenderStrategiesConfig<T>\n  ) {\n    this._cfg = mergeDefaultConfig(cfg);\n    this._strategies$.next(this._cfg.customStrategies as any);\n    this.primaryStrategy = this.config.primaryStrategy;\n  }\n\n  /**\n   * @description\n   * Allows to schedule a work inside rxjs `pipe`. Accepts the work and configuration options object.\n   * - work is any function that should be executed\n   * - (optional) options includes strategy, patchZone and scope\n   *\n   * Scope is by default a subscription but you can also pass `this` and then the scope will be current component.\n   * Scope setup is useful if your work is some of the methods of `ChangeDetectorRef`. Only one change detection will be triggered if you have multiple schedules of change detection methods and scope is set to `this`.\n   *\n   * @example\n   * myObservable$.pipe(\n   *    this.strategyProvider.scheduleWith(() => myWork(), {strategy: 'idle', patchZone: false})\n   * ).subscribe();\n   *\n   * @return MonoTypeOperatorFunction<R>\n   */\n  scheduleWith<R>(\n    work: (v?: R) => void,\n    options?: ScheduleOnStrategyOptions\n  ): MonoTypeOperatorFunction<R> {\n    const strategy = this.strategies[options?.strategy || this.primaryStrategy];\n    const scope = options?.scope || {};\n    const _work = getWork(work, options?.patchZone);\n    const ngZone = options?.patchZone || undefined;\n    return (o$) =>\n      o$.pipe(\n        switchMap((v) =>\n          onStrategy(\n            v,\n            strategy,\n            (_v) => {\n              _work(_v);\n            },\n            { scope, ngZone }\n          )\n        )\n      );\n  }\n\n  /**\n   * @description\n   * Allows to schedule a work as an observable. Accepts the work and configuration options object.\n   * - work is any function that should be executed\n   * - (optional) options includes strategy, patchZone and scope\n   *\n   * Scope is by default a subscription but you can also pass `this` and then the scope will be current component.\n   * Scope setup is especially useful if you provide work that will trigger a change detection.\n   *\n   * @example\n   * this.strategyProvider.schedule(() => myWork(), {strategy: 'idle', patchZone: false}).subscribe();\n   *\n   * @return Observable<R>\n   */\n  schedule<R>(\n    work: () => R,\n    options?: ScheduleOnStrategyOptions\n  ): Observable<R> {\n    const strategy = this.strategies[options?.strategy || this.primaryStrategy];\n    const scope = options?.scope || {};\n    const _work = getWork(work, options?.patchZone);\n    const ngZone = options?.patchZone || undefined;\n    let returnVal: R;\n    return onStrategy(\n      null,\n      strategy,\n      () => {\n        returnVal = _work();\n      },\n      { scope, ngZone }\n    ).pipe(map(() => returnVal));\n  }\n\n  /**\n   * @description\n   * Allows to schedule a change detection cycle. Accepts the ChangeDetectorRef and configuration options object.\n   * Options include:\n   * - afterCD which is the work that should be executed after change detection cycle.\n   * - abortCtrl is an AbortController that you can use to cancel the scheduled cycle.\n   *\n   * @example\n   * this.strategyProvider.scheduleCd(this.changeDetectorRef, {afterCD: myWork()});\n   *\n   * @return AbortController\n   */\n  scheduleCD(\n    cdRef: ChangeDetectorRef,\n    options?: ScheduleOnStrategyOptions & {\n      afterCD?: () => void;\n      abortCtrl?: AbortController;\n    }\n  ): AbortController {\n    const strategy = this.strategies[options?.strategy || this.primaryStrategy];\n    const scope = options?.scope || cdRef;\n    const abC = options?.abortCtrl || new AbortController();\n    const ngZone = options?.patchZone || undefined;\n    const work = getWork(() => {\n      strategy.work(cdRef, scope);\n      if (options?.afterCD) {\n        options.afterCD();\n      }\n    }, options.patchZone);\n    onStrategy(\n      null,\n      strategy,\n      () => {\n        work();\n      },\n      { scope, ngZone }\n    )\n      .pipe(takeUntil(fromEvent(abC.signal, 'abort')))\n      .subscribe();\n    return abC;\n  }\n}\n\nfunction getWork<T>(\n  work: (args?: any) => T,\n  patchZone?: false | NgZone\n): (args?: any) => T {\n  let _work = work;\n  if (patchZone) {\n    _work = (args?: any) => patchZone.run(() => work(args));\n  }\n  return _work;\n}\n"]}