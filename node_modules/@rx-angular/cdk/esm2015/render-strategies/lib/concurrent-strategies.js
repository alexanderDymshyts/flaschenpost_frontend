import { Observable } from 'rxjs';
import { filter, mapTo, switchMap } from 'rxjs/operators';
import { cancelCallback, scheduleCallback, forceFrameRate, } from '@rx-angular/cdk/internals/scheduler';
import { coalescingManager } from '@rx-angular/cdk/coalescing';
// set default to 60fps
forceFrameRate(60);
const immediateStrategy = {
    name: 'immediate',
    work: (cdRef) => cdRef.detectChanges(),
    behavior: ({ work, scope, ngZone }) => {
        return (o$) => o$.pipe(scheduleOnQueue(work, {
            ngZone,
            priority: 1 /* ImmediatePriority */,
            scope,
        }));
    },
};
const userBlockingStrategy = {
    name: 'userBlocking',
    work: (cdRef) => cdRef.detectChanges(),
    behavior: ({ work, scope, ngZone }) => {
        return (o$) => o$.pipe(scheduleOnQueue(work, {
            ngZone,
            priority: 2 /* UserBlockingPriority */,
            scope,
        }));
    },
};
const normalStrategy = {
    name: 'normal',
    work: (cdRef) => cdRef.detectChanges(),
    behavior: ({ work, scope, ngZone }) => {
        return (o$) => o$.pipe(scheduleOnQueue(work, {
            ngZone,
            priority: 3 /* NormalPriority */,
            scope,
        }));
    },
};
const lowStrategy = {
    name: 'low',
    work: (cdRef) => cdRef.detectChanges(),
    behavior: ({ work, scope, ngZone }) => {
        return (o$) => o$.pipe(scheduleOnQueue(work, {
            ngZone,
            priority: 4 /* LowPriority */,
            scope,
        }));
    },
};
const idleStrategy = {
    name: 'idle',
    work: (cdRef) => cdRef.detectChanges(),
    behavior: ({ work, scope, ngZone }) => {
        return (o$) => o$.pipe(scheduleOnQueue(work, {
            ngZone,
            priority: 5 /* IdlePriority */,
            scope,
        }));
    },
};
function scheduleOnQueue(work, options) {
    const scope = options.scope || {};
    return (o$) => o$.pipe(filter(() => !coalescingManager.isCoalescing(scope)), switchMap((v) => new Observable((subscriber) => {
        coalescingManager.add(scope);
        const task = scheduleCallback(options.priority, () => {
            work();
            coalescingManager.remove(scope);
            subscriber.next(v);
        }, { delay: options.delay, ngZone: options.ngZone });
        return () => {
            coalescingManager.remove(scope);
            cancelCallback(task);
        };
    }).pipe(mapTo(v))));
}
export const RX_CONCURRENT_STRATEGIES = {
    immediate: immediateStrategy,
    userBlocking: userBlockingStrategy,
    normal: normalStrategy,
    low: lowStrategy,
    idle: idleStrategy,
};
//# sourceMappingURL=concurrent-strategies.js.map