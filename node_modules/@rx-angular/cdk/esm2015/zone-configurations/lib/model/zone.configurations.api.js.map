{"version":3,"file":"zone.configurations.api.js","sourceRoot":"","sources":["../../../../../../../libs/cdk/zone-configurations/src/lib/model/zone.configurations.api.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Interface of `zone.js` configurations.\n *\n * You can define the following configurations on the `window/global` object before\n * importing `zone.js` to change `zone.js` default behaviors.\n */\nexport interface RxZoneGlobalConfigurations {\n  /**\n   * Disable the monkey patch of the `Node.js` `EventEmitter` API.\n   *\n   * By default, `zone.js` monkey patches the `Node.js` `EventEmitter` APIs to make asynchronous\n   * callbacks of those APIs in the same zone when scheduled.\n   *\n   * Consider the following example:\n   *\n   * ```\n   * const EventEmitter = require('unpatch');\n   * class MyEmitter extends EventEmitter {}\n   * const myEmitter = new MyEmitter();\n   *\n   * const zone = Zone.current.fork({name: 'myZone'});\n   * zone.run(() => {\n   *   myEmitter.on('event', () => {\n   *     console.log('an event occurs in the zone', Zone.current.name);\n   *     // the callback runs in the zone when it is scheduled,\n   *     // so the output is 'an event occurs in the zone myZone'.\n   *   });\n   * });\n   * myEmitter.emit('event');\n   * ```\n   *\n   * If you set `__Zone_disable_EventEmitter = true` before importing `zone.js`,\n   * `zone.js` does not monkey patch the `EventEmitter` APIs and the above code\n   * outputs 'an event occurred <root>'.\n   */\n  __Zone_disable_EventEmitter?: boolean;\n\n  /**\n   * Disable the monkey patch of the `Node.js` `fs` API.\n   *\n   * By default, `zone.js` monkey patches `Node.js` `fs` APIs to make asynchronous callbacks of\n   * those APIs in the same zone when scheduled.\n   *\n   * Consider the following example:\n   *\n   * ```\n   * const fs = require('fs');\n   *\n   * const zone = Zone.current.fork({name: 'myZone'});\n   * zone.run(() => {\n   *   fs.stat('/tmp/world', (err, stats) => {\n   *     console.log('fs.stats() callback is invoked in the zone', Zone.current.name);\n   *     // since the callback of the `fs.stat()` runs in the same zone\n   *     // when it is called, so the output is 'fs.stats() callback is invoked in the zone myZone'.\n   *   });\n   * });\n   * ```\n   *\n   * If you set `__Zone_disable_fs = true` before importing `zone.js`,\n   * `zone.js` does not monkey patch the `fs` API and the above code\n   * outputs 'get stats occurred <root>'.\n   */\n  __Zone_disable_fs?: boolean;\n\n  /**\n   * Disable the monkey patch of the `Node.js` `timer` API.\n   *\n   * By default, `zone.js` monkey patches the `Node.js` `timer` APIs to make asynchronous\n   * callbacks of those APIs in the same zone when scheduled.\n   *\n   * Consider the following example:\n   *\n   * ```\n   * const zone = Zone.current.fork({name: 'myZone'});\n   * zone.run(() => {\n   *   setTimeout(() => {\n   *     console.log('setTimeout() callback is invoked in the zone', Zone.current.name);\n   *     // since the callback of `setTimeout()` runs in the same zone\n   *     // when it is scheduled, so the output is 'setTimeout() callback is invoked in the zone\n   *     // myZone'.\n   *   });\n   * });\n   * ```\n   *\n   * If you set `__Zone_disable_timers = true` before importing `zone.js`,\n   * `zone.js` does not monkey patch the `timer` APIs and the above code\n   * outputs 'timeout <root>'.\n   */\n  __Zone_disable_node_timers?: boolean;\n\n  /**\n   * Disable the monkey patch of the `Node.js` `process.nextTick()` API.\n   *\n   * By default, `zone.js` monkey patches the `Node.js` `process.nextTick()` API to make the\n   * callback in the same zone when calling `process.nextTick()`.\n   *\n   * Consider the following example:\n   *\n   * ```\n   * const zone = Zone.current.fork({name: 'myZone'});\n   * zone.run(() => {\n   *   process.nextTick(() => {\n   *     console.log('process.nextTick() callback is invoked in the zone', Zone.current.name);\n   *     // since the callback of `process.nextTick()` runs in the same zone\n   *     // when it is scheduled, so the output is 'process.nextTick() callback is invoked in the\n   *     // zone myZone'.\n   *   });\n   * });\n   * ```\n   *\n   * If you set `__Zone_disable_nextTick = true` before importing `zone.js`,\n   * `zone.js` does not monkey patch the `process.nextTick()` API and the above code\n   * outputs 'nextTick <root>'.\n   */\n  __Zone_disable_nextTick?: boolean;\n\n  /**\n   * Disable the monkey patch of the `Node.js` `crypto` API.\n   *\n   * By default, `zone.js` monkey patches the `Node.js` `crypto` APIs to make asynchronous callbacks\n   * of those APIs in the same zone when called.\n   *\n   * Consider the following example:\n   *\n   * ```\n   * const crypto = require('crypto');\n   *\n   * const zone = Zone.current.fork({name: 'myZone'});\n   * zone.run(() => {\n   *   crypto.randomBytes(() => {\n   *     console.log('crypto.randomBytes() callback is invoked in the zone', Zone.current.name);\n   *     // since the callback of `crypto.randomBytes()` runs in the same zone\n   *     // when it is called, so the output is 'crypto.randomBytes() callback is invoked in the\n   *     // zone myZone'.\n   *   });\n   * });\n   * ```\n   *\n   * If you set `__Zone_disable_crypto = true` before importing `zone.js`,\n   * `zone.js` does not monkey patch the `crypto` API and the above code\n   * outputs 'crypto <root>'.\n   */\n  __Zone_disable_crypto?: boolean;\n\n  /**\n   * Disable the monkey patch of the `Object.defineProperty()` API.\n   *\n   * Note: This configuration is available only in the legacy bundle (dist/zone.js). This module is\n   * not available in the evergreen bundle (zone-evergreen.js).\n   *\n   * In the legacy browser, the default behavior of `zone.js` is to monkey patch\n   * `Object.defineProperty()` and `Object.create()` to try to ensure PropertyDescriptor parameter's\n   * configurable property to be true. This patch is only needed in some old mobile browsers.\n   *\n   * If you set `__Zone_disable_defineProperty = true` before importing `zone.js`,\n   * `zone.js` does not monkey patch the `Object.defineProperty()` API and does not\n   * modify desc.configurable to true.\n   *\n   */\n  __Zone_disable_defineProperty?: boolean;\n\n  /**\n   * Disable the monkey patch of the browser `registerElement()` API.\n   *\n   * NOTE: This configuration is only available in the legacy bundle (dist/zone.js), this\n   * module is not available in the evergreen bundle (zone-evergreen.js).\n   *\n   * In the legacy browser, the default behavior of `zone.js` is to monkey patch the\n   * `registerElement()` API to make asynchronous callbacks of the API in the same zone when\n   * `registerElement()` is called.\n   *\n   * Consider the following example:\n   *\n   * ```\n   * const proto = Object.create(HTMLElement.prototype);\n   * proto.createdCallback = function() {\n   *   console.log('createdCallback is invoked in the zone', Zone.current.name);\n   * };\n   * proto.attachedCallback = function() {\n   *   console.log('attachedCallback is invoked in the zone', Zone.current.name);\n   * };\n   * proto.detachedCallback = function() {\n   *   console.log('detachedCallback is invoked in the zone', Zone.current.name);\n   * };\n   * proto.attributeChangedCallback = function() {\n   *   console.log('attributeChangedCallback is invoked in the zone', Zone.current.name);\n   * };\n   *\n   * const zone = Zone.current.fork({name: 'myZone'});\n   * zone.run(() => {\n   *   document.registerElement('x-elem', {prototype: proto});\n   * });\n   * ```\n   *\n   * When these callbacks are invoked, those callbacks will be in the zone when\n   * `registerElement()` is called.\n   *\n   * If you set `__Zone_disable_registerElement = true` before importing `zone.js`,\n   * `zone.js` does not monkey patch `registerElement()` API and the above code\n   * outputs '<root>'.\n   */\n  __Zone_disable_registerElement?: boolean;\n\n  /**\n   * Disable the monkey patch of the browser legacy `EventTarget` API.\n   *\n   * NOTE: This configuration is only available in the legacy bundle (dist/zone.js), this module\n   * is not available in the evergreen bundle (zone-evergreen.js).\n   *\n   * In some old browsers, the `EventTarget` is not available, so `zone.js` cannot directly monkey\n   * patch the `EventTarget`. Instead, `zone.js` patches all known HTML elements' prototypes (such\n   * as `HtmlDivElement`). The callback of the `addEventListener()` will be in the same zone when\n   * the `addEventListener()` is called.\n   *\n   * Consider the following example:\n   *\n   * ```\n   * const zone = Zone.current.fork({name: 'myZone'});\n   * zone.run(() => {\n   *   div.addEventListener('click', () => {\n   *     console.log('div click event listener is invoked in the zone', Zone.current.name);\n   *     // the output is 'div click event listener is invoked in the zone myZone'.\n   *   });\n   * });\n   * ```\n   *\n   * If you set `__Zone_disable_EventTargetLegacy = true` before importing `zone.js`\n   * In some old browsers, where `EventTarget` is not available, if you set\n   * `__Zone_disable_EventTargetLegacy = true` before importing `zone.js`, `zone.js` does not monkey\n   * patch all HTML element APIs and the above code outputs 'clicked <root>'.\n   */\n  __Zone_disable_EventTargetLegacy?: boolean;\n\n  /**\n   * Disable the monkey patch of the browser `timer` APIs.\n   *\n   * By default, `zone.js` monkey patches browser timer\n   * APIs (`setTimeout()`/`setInterval()`/`setImmediate()`) to make asynchronous callbacks of those\n   * APIs in the same zone when scheduled.\n   *\n   * Consider the following example:\n   *\n   * ```\n   * const zone = Zone.current.fork({name: 'myZone'});\n   * zone.run(() => {\n   *   setTimeout(() => {\n   *     console.log('setTimeout() callback is invoked in the zone', Zone.current.name);\n   *     // since the callback of `setTimeout()` runs in the same zone\n   *     // when it is scheduled, so the output is 'setTimeout() callback is invoked in the zone\n   *     // myZone'.\n   *   });\n   * });\n   * ```\n   *\n   * If you set `__Zone_disable_timers = true` before importing `zone.js`,\n   * `zone.js` does not monkey patch `timer` API and the above code\n   * outputs 'timeout <root>'.\n   *\n   */\n  __Zone_disable_timers?: boolean;\n\n  /**\n   * Disable the monkey patch of the browser `requestAnimationFrame()` API.\n   *\n   * By default, `zone.js` monkey patches the browser `requestAnimationFrame()` API\n   * to make the asynchronous callback of the `requestAnimationFrame()` in the same zone when\n   * scheduled.\n   *\n   * Consider the following example:\n   *\n   * ```\n   * const zone = Zone.current.fork({name: 'myZone'});\n   * zone.run(() => {\n   *   requestAnimationFrame(() => {\n   *     console.log('requestAnimationFrame() callback is invoked in the zone', Zone.current.name);\n   *     // since the callback of `requestAnimationFrame()` will be in the same zone\n   *     // when it is scheduled, so the output will be 'requestAnimationFrame() callback is invoked\n   *     // in the zone myZone'\n   *   });\n   * });\n   * ```\n   *\n   * If you set `__Zone_disable_requestAnimationFrame = true` before importing `zone.js`,\n   * `zone.js` does not monkey patch the `requestAnimationFrame()` API and the above code\n   * outputs 'raf <root>'.\n   */\n  __Zone_disable_requestAnimationFrame?: boolean;\n\n  /**\n   *\n   * Disable the monkey patch of the browser blocking APIs(`alert()`/`prompt()`/`confirm()`).\n   */\n  __Zone_disable_blocking?: boolean;\n\n  /**\n   * Disable the monkey patch of the browser `EventTarget` APIs.\n   *\n   * By default, `zone.js` monkey patches EventTarget APIs. The callbacks of the\n   * `addEventListener()` run in the same zone when the `addEventListener()` is called.\n   *\n   * Consider the following example:\n   *\n   * ```\n   * const zone = Zone.current.fork({name: 'myZone'});\n   * zone.run(() => {\n   *   div.addEventListener('click', () => {\n   *     console.log('div event listener is invoked in the zone', Zone.current.name);\n   *     // the output is 'div event listener is invoked in the zone myZone'.\n   *   });\n   * });\n   * ```\n   *\n   * If you set `__Zone_disable_EventTarget = true` before importing `zone.js`,\n   * `zone.js` does not monkey patch EventTarget API and the above code\n   * outputs 'clicked <root>'.\n   *\n   */\n  __Zone_disable_EventTarget?: boolean;\n\n  /**\n   * Disable the monkey patch of the browser `FileReader` APIs.\n   */\n  __Zone_disable_FileReader?: boolean;\n\n  /**\n   * Disable the monkey patch of the browser `MutationObserver` APIs.\n   */\n  __Zone_disable_MutationObserver?: boolean;\n\n  /**\n   * Disable the monkey patch of the browser `IntersectionObserver` APIs.\n   */\n  __Zone_disable_IntersectionObserver?: boolean;\n\n  /**\n   * Disable the monkey patch of the browser onProperty APIs(such as onclick).\n   *\n   * By default, `zone.js` monkey patches onXXX properties (such as onclick). The callbacks of onXXX\n   * properties run in the same zone when the onXXX properties is set.\n   *\n   * Consider the following example:\n   *\n   * ```\n   * const zone = Zone.current.fork({name: 'myZone'});\n   * zone.run(() => {\n   *   div.onclick = () => {\n   *     console.log('div click event listener is invoked in the zone', Zone.current.name);\n   *     // the output will be 'div click event listener is invoked in the zone myZone'\n   *   }\n   * });\n   * ```\n   *\n   * If you set `__Zone_disable_on_property = true` before importing `zone.js`,\n   * `zone.js` does not monkey patch onXXX properties and the above code\n   * outputs 'clicked <root>'.\n   *\n   */\n  __Zone_disable_on_property?: boolean;\n\n  /**\n   * Disable the monkey patch of the browser `customElements` APIs.\n   *\n   * By default, `zone.js` monkey patches `customElements` APIs to make callbacks run in the\n   * same zone when the `customElements.define()` is called.\n   *\n   * Consider the following example:\n   *\n   * ```\n   * class TestCustomElement extends HTMLElement {\n   *   constructor() { super(); }\n   *   connectedCallback() {}\n   *   disconnectedCallback() {}\n   *   attributeChangedCallback(attrName, oldVal, newVal) {}\n   *   adoptedCallback() {}\n   * }\n   *\n   * const zone = Zone.fork({name: 'myZone'});\n   * zone.run(() => {\n   *   customElements.define('x-elem', TestCustomElement);\n   * });\n   * ```\n   *\n   * All those callbacks defined in TestCustomElement runs in the zone when\n   * the `customElements.define()` is called.\n   *\n   * If you set `__Zone_disable_customElements = true` before importing `zone.js`,\n   * `zone.js` does not monkey patch `customElements` APIs and the above code\n   * runs inside <root> zone.\n   */\n  __Zone_disable_customElements?: boolean;\n\n  /**\n   * Disable the monkey patch of the browser `XMLHttpRequest` APIs.\n   *\n   * By default, `zone.js` monkey patches `XMLHttpRequest` APIs to make XMLHttpRequest act\n   * as macroTask.\n   *\n   * Consider the following example:\n   *\n   * ```\n   * const zone = Zone.current.fork({\n   *   name: 'myZone',\n   *   onScheduleTask: (delegate, curr, target, task) => {\n   *     console.log('task is scheduled', task.type, task.source, task.zone.name);\n   *     return delegate.scheduleTask(target, task);\n   *   }\n   * })\n   * const xhr = new XMLHttpRequest();\n   * zone.run(() => {\n   *   xhr.onload = function() {};\n   *   xhr.open('get', '/', true);\n   *   xhr.send();\n   * });\n   * ```\n   *\n   * In this example, the instance of XMLHttpRequest runs in the zone and acts as a macroTask. The\n   * output is 'task is scheduled macroTask, XMLHttpRequest.send, zone'.\n   *\n   * If you set `__Zone_disable_XHR = true` before importing `zone.js`,\n   * `zone.js` does not monkey patch `XMLHttpRequest` APIs and the above onScheduleTask callback\n   * will not be called.\n   *\n   */\n  __Zone_disable_XHR?: boolean;\n\n  /**\n   * Disable the monkey patch of the browser geolocation APIs.\n   *\n   * By default, `zone.js` monkey patches geolocation APIs to make callbacks run in the same zone\n   * when those APIs are called.\n   *\n   * Consider the following examples:\n   *\n   * ```\n   * const zone = Zone.current.fork({\n   *   name: 'myZone'\n   * });\n   *\n   * zone.run(() => {\n   *   navigator.geolocation.getCurrentPosition(pos => {\n   *     console.log('navigator.getCurrentPosition() callback is invoked in the zone',\n   *     Zone.current.name);\n   *     // output is 'navigator.getCurrentPosition() callback is invoked in the zone myZone'.\n   *   }\n   * });\n   * ```\n   *\n   * If set you `__Zone_disable_geolocation = true` before importing `zone.js`,\n   * `zone.js` does not monkey patch geolocation APIs and the above code\n   * outputs 'getCurrentPosition <root>'.\n   *\n   */\n  __Zone_disable_geolocation?: boolean;\n\n  /**\n   * Disable the monkey patch of the browser `canvas` APIs.\n   *\n   * By default, `zone.js` monkey patches `canvas` APIs to make callbacks run in the same zone when\n   * those APIs are called.\n   *\n   * Consider the following example:\n   *\n   * ```\n   * const zone = Zone.current.fork({\n   *   name: 'myZone'\n   * });\n   *\n   * zone.run(() => {\n   *   canvas.toBlob(blog => {\n   *     console.log('canvas.toBlob() callback is invoked in the zone', Zone.current.name);\n   *     // output is 'canvas.toBlob() callback is invoked in the zone myZone'.\n   *   }\n   * });\n   * ```\n   *\n   * If you set `__Zone_disable_canvas = true` before importing `zone.js`,\n   * `zone.js` does not monkey patch `canvas` APIs and the above code\n   * outputs 'canvas.toBlob <root>'.\n   */\n  __Zone_disable_canvas?: boolean;\n\n  /**\n   * Disable the `Promise` monkey patch.\n   *\n   * By default, `zone.js` monkey patches `Promise` APIs to make the `then()/catch()` callbacks in\n   * the same zone when those callbacks are called.\n   *\n   * Consider the following examples:\n   *\n   * ```\n   * const zone = Zone.current.fork({name: 'myZone'});\n   *\n   * const p = Promise.resolve(1);\n   *\n   * zone.run(() => {\n   *   p.then(() => {\n   *     console.log('then() callback is invoked in the zone', Zone.current.name);\n   *     // output is 'then() callback is invoked in the zone myZone'.\n   *   });\n   * });\n   * ```\n   *\n   * If you set `__Zone_disable_ZoneAwarePromise = true` before importing `zone.js`,\n   * `zone.js` does not monkey patch `Promise` APIs and the above code\n   * outputs 'promise then callback <root>'.\n   */\n  __Zone_disable_ZoneAwarePromise?: boolean;\n\n  /**\n   * Define event names that users don't want monkey patched by the `zone.js`.\n   *\n   * By default, `zone.js` monkey patches EventTarget.addEventListener(). The event listener\n   * callback runs in the same zone when the addEventListener() is called.\n   *\n   * Sometimes, you don't want all of the event names used in this patched version because it\n   * impacts performance. For example, you might want `scroll` or `mousemove` event listeners to run\n   * the native `addEventListener()` for better performance.\n   *\n   * Users can achieve this goal by defining `__zone_symbol__UNPATCHED_EVENTS = ['scroll',\n   * 'mousemove'];` before importing `zone.js`.\n   */\n  __zone_symbol__UNPATCHED_EVENTS?: string[];\n\n  /**\n   * Define the event names of the passive listeners.\n   *\n   * To add passive event listeners, you can use `elem.addEventListener('scroll', listener,\n   * {passive: true});` or implement your own `EventManagerPlugin`.\n   *\n   * You can also define a global variable as follows:\n   *\n   * ```\n   * __zone_symbol__PASSIVE_EVENTS = ['scroll'];\n   * ```\n   *\n   * The preceding code makes all scroll event listeners passive.\n   */\n  __zone_symbol__PASSIVE_EVENTS?: string[];\n\n  /**\n   * Disable wrapping uncaught promise rejection.\n   *\n   * By default, `zone.js` wraps the uncaught promise rejection in a new `Error` object\n   * which contains additional information such as a value of the rejection and a stack trace.\n   *\n   * If you set `__zone_symbol__DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION = true;` before\n   * importing `zone.js`, `zone.js` will not wrap the uncaught promise rejection.\n   */\n  __zone_symbol__DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION?: boolean;\n}\n\n/**\n * Interface of `zone-testing.js` test configurations.\n *\n * You can define the following configurations on the `window` or `global` object before\n * importing `zone-testing.js` to change `zone-testing.js` default behaviors in the test runner.\n */\nexport interface RxZoneTestConfigurations {\n  /**\n   * Disable the Jasmine integration.\n   *\n   * In the `zone-testing.js` bundle, by default, `zone-testing.js` monkey patches Jasmine APIs\n   * to make Jasmine APIs run in specified zone.\n   *\n   * 1. Make the `describe()`/`xdescribe()`/`fdescribe()` methods run in the syncTestZone.\n   * 2. Make the `it()`/`xit()`/`fit()`/`beforeEach()`/`afterEach()`/`beforeAll()`/`afterAll()`\n   * methods run in the ProxyZone.\n   *\n   * With this patch, `async()`/`fakeAsync()` can work with the Jasmine runner.\n   *\n   * If you set `__Zone_disable_jasmine = true` before importing `zone-testing.js`,\n   * `zone-testing.js` does not monkey patch the jasmine APIs and the `async()`/`fakeAsync()` cannot\n   * work with the Jasmine runner any longer.\n   */\n  __Zone_disable_jasmine?: boolean;\n\n  /**\n   * Disable the Mocha integration.\n   *\n   * In the `zone-testing.js` bundle, by default, `zone-testing.js` monkey patches the Mocha APIs\n   * to make Mocha APIs run in the specified zone.\n   *\n   * 1. Make the `describe()`/`xdescribe()`/`fdescribe()` methods run in the syncTestZone.\n   * 2. Make the `it()`/`xit()`/`fit()`/`beforeEach()`/`afterEach()`/`beforeAll()`/`afterAll()`\n   * methods run in the ProxyZone.\n   *\n   * With this patch, `async()`/`fakeAsync()` can work with the Mocha runner.\n   *\n   * If you set `__Zone_disable_mocha = true` before importing `zone-testing.js`,\n   * `zone-testing.js` does not monkey patch the Mocha APIs and the `async()/`fakeAsync()` can not\n   * work with the Mocha runner any longer.\n   */\n  __Zone_disable_mocha?: boolean;\n\n  /**\n   * Disable the Jest integration.\n   *\n   * In the `zone-testing.js` bundle, by default, `zone-testing.js` monkey patches Jest APIs\n   * to make Jest APIs run in the specified zone.\n   *\n   * 1. Make the `describe()`/`xdescribe()`/`fdescribe()` methods run in the syncTestZone.\n   * 2. Make the `it()`/`xit()`/`fit()`/`beforeEach()`/`afterEach()`/`before()`/`after()` methods\n   * run in the ProxyZone.\n   *\n   * With this patch, `async()`/`fakeAsync()` can work with the Jest runner.\n   *\n   * If you set `__Zone_disable_jest = true` before importing `zone-testing.js`,\n   * `zone-testing.js` does not monkey patch the jest APIs and `async()`/`fakeAsync()` cannot\n   * work with the Jest runner any longer.\n   */\n  __Zone_disable_jest?: boolean;\n\n  /**\n   * Disable monkey patch the jasmine clock APIs.\n   *\n   * By default, `zone-testing.js` monkey patches the `jasmine.clock()` API,\n   * so the `jasmine.clock()` can work with the `fakeAsync()/tick()` API.\n   *\n   * Consider the following example:\n   *\n   * ```\n   * describe('jasmine.clock integration', () => {\n   *   beforeEach(() => {\n   *     jasmine.clock().install();\n   *   });\n   *   afterEach(() => {\n   *     jasmine.clock().uninstall();\n   *   });\n   *   it('fakeAsync test', fakeAsync(() => {\n   *     setTimeout(spy, 100);\n   *     expect(spy).not.toHaveBeenCalled();\n   *     jasmine.clock().tick(100);\n   *     expect(spy).toHaveBeenCalled();\n   *   }));\n   * });\n   * ```\n   *\n   * In the `fakeAsync()` method, `jasmine.clock().tick()` works just like `tick()`.\n   *\n   * If you set `__zone_symbol__fakeAsyncDisablePatchingClock = true` before importing\n   * `zone-testing.js`,`zone-testing.js` does not monkey patch the `jasmine.clock()` APIs and the\n   * `jasmine.clock()` cannot work with `fakeAsync()` any longer.\n   */\n  __zone_symbol__fakeAsyncDisablePatchingClock?: boolean;\n\n  /**\n   * Enable auto running into `fakeAsync()` when installing the `jasmine.clock()`.\n   *\n   * By default, `zone-testing.js` does not automatically run into `fakeAsync()`\n   * if the `jasmine.clock().install()` is called.\n   *\n   * Consider the following example:\n   *\n   * ```\n   * describe('jasmine.clock integration', () => {\n   *   beforeEach(() => {\n   *     jasmine.clock().install();\n   *   });\n   *   afterEach(() => {\n   *     jasmine.clock().uninstall();\n   *   });\n   *   it('fakeAsync test', fakeAsync(() => {\n   *     setTimeout(spy, 100);\n   *     expect(spy).not.toHaveBeenCalled();\n   *     jasmine.clock().tick(100);\n   *     expect(spy).toHaveBeenCalled();\n   *   }));\n   * });\n   * ```\n   *\n   * You must run `fakeAsync()` to make test cases in the `FakeAsyncTestZone`.\n   *\n   * If you set `__zone_symbol__fakeAsyncAutoFakeAsyncWhenClockPatched = true` before importing\n   * `zone-testing.js`, `zone-testing.js` can run test case automatically in the\n   * `FakeAsyncTestZone` without calling the `fakeAsync()`.\n   *\n   * Consider the following example:\n   *\n   * ```\n   * describe('jasmine.clock integration', () => {\n   *   beforeEach(() => {\n   *     jasmine.clock().install();\n   *   });\n   *   afterEach(() => {\n   *     jasmine.clock().uninstall();\n   *   });\n   *   it('fakeAsync test', () => { // here we don't need to call fakeAsync\n   *     setTimeout(spy, 100);\n   *     expect(spy).not.toHaveBeenCalled();\n   *     jasmine.clock().tick(100);\n   *     expect(spy).toHaveBeenCalled();\n   *   });\n   * });\n   * ```\n   *\n   */\n  __zone_symbol__fakeAsyncAutoFakeAsyncWhenClockPatched?: boolean;\n\n  /**\n   * Enable waiting for the unresolved promise in the `async()` test.\n   *\n   * In the `async()` test, `AsyncTestZone` waits for all the asynchronous tasks to finish. By\n   * default, if some promises remain unresolved, `AsyncTestZone` does not wait and reports that it\n   * received an unexpected result.\n   *\n   * Consider the following example:\n   *\n   * ```\n   * describe('wait never resolved promise', () => {\n   *   it('async with never resolved promise test', async(() => {\n   *     const p = new Promise(() => {});\n   *     p.then(() => {\n   *       // do some expectation.\n   *     });\n   *   }))\n   * });\n   * ```\n   *\n   * By default, this case passes, because the callback of `p.then()` is never called. Because `p`\n   * is an unresolved promise, there is no pending asynchronous task, which means the `async()`\n   * method does not wait.\n   *\n   * If you set `__zone_symbol__supportWaitUnResolvedChainedPromise = true`, the above case\n   * times out, because `async()` will wait for the unresolved promise.\n   */\n  __zone_symbol__supportWaitUnResolvedChainedPromise?: boolean;\n}\n\n/**\n * The interface of the `zone.js` runtime configurations.\n *\n * These configurations can be defined on the `Zone` object after\n * importing zone.js to change behaviors. The differences between\n * the `RxZoneRuntimeConfigurations` and the `RxZoneGlobalConfigurations` are,\n *\n * 1. `RxZoneGlobalConfigurations` must be defined on the `global/window` object before importing\n * `zone.js`. The value of the configuration cannot be changed at runtime.\n *\n * 2. `RxZoneRuntimeConfigurations` must be defined on the `Zone` object after importing `zone.js`.\n * You can change the value of this configuration at runtime.\n *\n */\nexport interface RxZoneRuntimeConfigurations {\n  /**\n   * Ignore outputting errors to the console when uncaught Promise errors occur.\n   *\n   * By default, if an uncaught Promise error occurs, `zone.js` outputs the\n   * error to the console by calling `console.error()`.\n   *\n   * If you set `__zone_symbol__ignoreConsoleErrorUncaughtError = true`, `zone.js` does not output\n   * the uncaught error to `console.error()`.\n   */\n  __zone_symbol__ignoreConsoleErrorUncaughtError?: boolean;\n}\n"]}