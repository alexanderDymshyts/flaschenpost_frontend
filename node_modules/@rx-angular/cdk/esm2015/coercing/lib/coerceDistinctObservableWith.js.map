{"version":3,"file":"coerceDistinctObservableWith.js","sourceRoot":"","sources":["../../../../../../libs/cdk/coercing/src/lib/coerceDistinctObservableWith.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,oBAAoB,EAAE,SAAS,EAAE,MAAM,gBAAgB,CAAC;AACjE,OAAO,EAAE,oBAAoB,EAAE,MAAM,wBAAwB,CAAC;AAE9D;;;;;;;;;GASG;AACH,MAAM,UAAU,kBAAkB,CAChC,eAAyD;IAEzD,eAAe,GAAG,eAAe,IAAI,SAAS,EAAE,CAAC;IACjD,OAAO,CAAC,EAAiC,EAAE,EAAE,CAC3C,EAAE,CAAC,IAAI,CACL,oBAAoB,EAAE,EACtB,oBAAoB,EAAE,EACtB,eAAe,EACf,oBAAoB,EAAE,CACvB,CAAC;AACN,CAAC","sourcesContent":["import { Observable, ObservableInput, OperatorFunction } from 'rxjs';\nimport { distinctUntilChanged, switchAll } from 'rxjs/operators';\nimport { coerceObservableWith } from './coerceObservableWith';\n\n/**\n * This operator takes an Observable of values ot Observables aof values and\n * It forwards only distinct values from distinct incoming Observables or values.\n * This comes in handy in any environment where you handle processing of incoming dynamic values and their state.\n *\n * Optionally you can pass a flatten strategy to get find grained control of the flattening process. E.g. mergeAll, switchAll\n *\n * @param flattenOperator - determines the flattening strategy e.g. mergeAll, concatAll, exhaust, switchAll. default is switchAll\n *\n */\nexport function coerceDistinctWith<T>(\n  flattenOperator?: OperatorFunction<ObservableInput<T>, T>\n) {\n  flattenOperator = flattenOperator || switchAll();\n  return (o$: Observable<Observable<T> | T>) =>\n    o$.pipe(\n      coerceObservableWith(),\n      distinctUntilChanged(),\n      flattenOperator,\n      distinctUntilChanged()\n    );\n}\n"]}