{"version":3,"file":"coerceDistinctObservable.js","sourceRoot":"","sources":["../../../../../../libs/cdk/coercing/src/lib/coerceDistinctObservable.ts"],"names":[],"mappings":"AAOA,OAAO,EAAE,oBAAoB,EAAO,SAAS,EAAE,MAAM,gBAAgB,CAAC;AACtE,OAAO,EAAE,gBAAgB,EAAE,MAAM,oBAAoB,CAAC;AAEtD;;;;;;;;;GASG;AACH,MAAM,UAAU,wBAAwB,CACtC,EAAiC,EACjC,eAAyD;IAEzD,eAAe,GAAG,eAAe,IAAI,SAAS,EAAE,CAAC;IACjD,OAAO,gBAAgB,CAAC,EAAE,CAAC,CAAC,IAAI,CAC9B,oBAAoB,EAAE,EACtB,eAAe,EACf,oBAAoB,EAAE,CACvB,CAAC;AACJ,CAAC","sourcesContent":["import {\n  isObservable,\n  Observable,\n  ObservableInput,\n  of,\n  OperatorFunction,\n} from 'rxjs';\nimport { distinctUntilChanged, map, switchAll } from 'rxjs/operators';\nimport { coerceObservable } from './coerceObservable';\n\n/**\n * This Observable factory creates an Observable out of a static value or ObservableInput.\n * It forwards only distinct values from distinct incoming Observables or values.\n * This comes in handy in any environment where you handle processing of incoming dynamic values and their state.\n *\n * Optionally you can pass a flatten strategy to get find grained control of the flattening process. E.g. mergeAll, switchAll\n *\n * @param o$ - The Observable to coerce and map to a Observable with distinct values\n * @param flattenOperator - determines the flattening strategy e.g. mergeAll, concatAll, exhaust, switchAll. default is switchAll\n */\nexport function coerceDistinctObservable<T>(\n  o$: Observable<Observable<T> | T>,\n  flattenOperator?: OperatorFunction<ObservableInput<T>, T>\n) {\n  flattenOperator = flattenOperator || switchAll();\n  return coerceObservable(o$).pipe(\n    distinctUntilChanged(),\n    flattenOperator,\n    distinctUntilChanged()\n  );\n}\n"]}