{"version":3,"file":"update.js","sourceRoot":"","sources":["../../../../../../../libs/cdk/transformations/src/lib/array/update.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,cAAc,EAAE,MAAM,mCAAmC,CAAC;AAEnE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAuEG;AACH,MAAM,UAAU,MAAM,CACpB,MAAW,EACX,OAAkC,EAClC,OAA2B;IAE3B,MAAM,cAAc,GAAG,OAAO,IAAI,IAAI,CAAC;IACvC,MAAM,cAAc,GAAG,cAAc;QACnC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC;YACtB,CAAC,CAAC,OAAO;YACT,CAAC,CAAC,CAAC,OAAO,CAAC;QACb,CAAC,CAAC,EAAE,CAAC;IAEP,MAAM,aAAa,GAAG,MAAM,IAAI,IAAI,CAAC;IACrC,MAAM,gBAAgB,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;IAChD,MAAM,YAAY,GAChB,gBAAgB,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,IAAI,cAAc,CAAC,MAAM,KAAK,CAAC,CAAC;IAEzE,IAAI,aAAa,IAAI,gBAAgB,EAAE;QACrC,OAAO,CAAC,IAAI,CAAC,2BAA2B,MAAM,oBAAoB,CAAC,CAAC;KACrE;IAED,IAAI,YAAY,EAAE;QAChB,OAAO,MAAM,CAAC;KACf;IAED,MAAM,CAAC,GAAQ,EAAE,CAAC;IAClB,KAAK,MAAM,YAAY,IAAI,MAAM,EAAE;QACjC,MAAM,KAAK,GAAG,UAAU,CAAC,cAAc,EAAE,CAAC,IAAI,EAAE,EAAE,CAChD,cAAc,CAAC,IAAS,EAAE,YAAY,EAAE,OAAO,CAAC,CACjD,CAAC;QAEF,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,iCAAM,YAAY,GAAK,KAAK,EAAG,CAAC,CAAC,YAAY,CAAC,CAAC;KAC9D;IAED,OAAO,CAAC,CAAC;AACX,CAAC;AAED,SAAS,UAAU,CAAI,KAAU,EAAE,EAAwB;IACzD,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;QACxB,MAAM,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,CAAC;QACnB,IAAI,CAAC,EAAE;YACL,OAAO,IAAI,CAAC;SACb;KACF;AACH,CAAC","sourcesContent":["import { ComparableData } from '../interfaces/comparable-data-type';\nimport { valuesComparer } from '../_internals/valuesComparer.util';\n\n/**\n * @description\n * Updates one or multiple items in an array T[].\n * For comparison you can provide key, array of keys or a custom comparison function that should return true if items match.\n * If no comparison is provided, an equality check is used by default.\n * Returns a shallow copy of the array T[] and updated items, does not mutate the original array.\n *\n * @example\n * // Update with comparison function\n *\n * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];\n *\n * const newCat = {id: 1, type: 'lion'};\n *\n * const updatedCreatures = update(creatures, newCat, (a, b) => a.id === b.id);\n *\n * // updatedCreatures will be:\n * // [{id: 1, type: 'lion'}, {id: 2, type: 'dog'}];\n *\n * @example\n * // Update with key\n *\n * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];\n *\n * const newCat = {id: 1, type: 'lion'};\n *\n * const updatedCreatures = update(creatures, newCat, 'id');\n *\n * // updatedCreatures will be:\n * // [{id: 1, type: 'lion'}, {id: 2, type: 'dog'}];\n *\n * @example\n * // Update with array of keys\n *\n * const creatures = [{id: 1, type: 'cat', name: 'Bella'}, {id: 2, type: 'dog', name: 'Sparky'}];\n *\n * const newCat = {id: 1, type: 'lion', name: 'Bella'};\n *\n * const updatedCreatures = update(creatures, newCat, ['id', 'name']);\n *\n * // updatedCreatures will be:\n * // [{id: 1, type: 'lion', name: 'Bella'}, {id: 2, type: 'dog', name: 'Sparky'}];\n *\n * @example\n * // Usage with RxState\n *\n * export class ListComponent {\n *\n *    readonly updateCreature$ = new Subject<Creature>();\n *\n *    constructor(private state: RxState<ComponentState>) {\n *      // Reactive implementation\n *      state.connect(\n *        'creatures',\n *        this.updateCreature$,\n *        ({ creatures }, creatureToUpdate) => {\n *            return update(creatures, creatureToUpdate, (a, b) => a.id === b.id);\n *        }\n *      );\n *    }\n *\n *    // Imperative implementation\n *    updateCreature(creatureToUpdate: Creature): void {\n *        this.state.set({ creatures: update(this.state.get().creatures, creatureToUpdate, (a, b) => a.id === b.id)});\n *    }\n * }\n *\n * @returns T[]\n *\n * @docsPage update\n * @docsCategory transformation-helpers\n */\nexport function update<T extends object>(\n  source: T[],\n  updates: Partial<T>[] | Partial<T>,\n  compare?: ComparableData<T>\n): T[] {\n  const updatesDefined = updates != null;\n  const updatesAsArray = updatesDefined\n    ? Array.isArray(updates)\n      ? updates\n      : [updates]\n    : [];\n\n  const sourceDefined = source != null;\n  const sourceIsNotArray = !Array.isArray(source);\n  const invalidInput =\n    sourceIsNotArray || source.length === 0 || updatesAsArray.length === 0;\n\n  if (sourceDefined && sourceIsNotArray) {\n    console.warn(`Update: Original value (${source}) is not an array.`);\n  }\n\n  if (invalidInput) {\n    return source;\n  }\n\n  const x: T[] = [];\n  for (const existingItem of source) {\n    const match = customFind(updatesAsArray, (item) =>\n      valuesComparer(item as T, existingItem, compare)\n    );\n\n    x.push(match ? { ...existingItem, ...match } : existingItem);\n  }\n\n  return x;\n}\n\nfunction customFind<T>(array: T[], fn: (item: T) => boolean): T | undefined {\n  for (const item of array) {\n    const x = fn(item);\n    if (x) {\n      return item;\n    }\n  }\n}\n"]}