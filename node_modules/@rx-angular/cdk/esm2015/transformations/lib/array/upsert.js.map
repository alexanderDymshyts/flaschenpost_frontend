{"version":3,"file":"upsert.js","sourceRoot":"","sources":["../../../../../../../libs/cdk/transformations/src/lib/array/upsert.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,aAAa,EAAE,MAAM,sBAAsB,CAAC;AACrD,OAAO,EAAE,cAAc,EAAE,MAAM,mCAAmC,CAAC;AAGnE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAwFG;AACH,MAAM,UAAU,MAAM,CACpB,MAAW,EACX,MAAiC,EACjC,OAA2B;IAE3B,4BAA4B;IAC5B,MAAM,cAAc,GAClB,MAAM,IAAI,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;IACpE,4BAA4B;IAC5B,MAAM,gBAAgB,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;IAChD,MAAM,YAAY,GAAG,gBAAgB,IAAI,cAAc,CAAC,MAAM,KAAK,CAAC,CAAC;IACrE,6FAA6F;IAC7F,sCAAsC;IACtC,0DAA0D;IAC1D,IAAI,YAAY,EAAE;QAChB,OAAO,MAAM,CAAC;KACf;IAED,uEAAuE;IACvE,iDAAiD;IACjD,IAAI,cAAc,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,gBAAgB,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,CAAC,EAAE;QAC1E,OAAO,CAAC,GAAG,cAAc,CAAQ,CAAC;KACnC;IAED,MAAM,OAAO,GAAQ,EAAE,CAAC;IACxB,MAAM,OAAO,GAA+B,EAAE,CAAC;IAC/C,0BAA0B;IAC1B,KAAK,MAAM,IAAI,IAAI,cAAc,EAAE;QACjC,MAAM,KAAK,GAAG,MAAM,CAAC,SAAS,CAAC,CAAC,UAAU,EAAE,EAAE,CAC5C,cAAc,CAAC,IAAS,EAAE,UAAU,EAAE,OAAO,CAAC,CAC/C,CAAC;QACF,4CAA4C;QAC5C,IAAI,KAAK,KAAK,CAAC,CAAC,EAAE;YAChB,OAAO,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC;SACvB;aAAM;YACL,oCAAoC;YACpC,IAAI,aAAa,CAAC,IAAI,CAAC,EAAE;gBACvB,6CAA6C;gBAC7C,OAAO,CAAC,IAAI,mBAAO,IAAU,EAAG,CAAC;aAClC;iBAAM;gBACL,yBAAyB;gBACzB,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aACpB;SACF;KACF;IAED,MAAM,OAAO,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,CAAC,EAAE,EAAE;QACrC,MAAM,WAAW,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;QAC/B,sBAAsB;QACtB,IAAI,WAAW,KAAK,IAAI,IAAI,WAAW,KAAK,SAAS,EAAE;YACrD,IAAI,aAAa,CAAC,IAAI,CAAC,EAAE;gBACvB,OAAO,gCAAK,IAAI,GAAK,WAAW,CAAO,CAAC;aACzC;iBAAM;gBACL,OAAO,WAAgB,CAAC;aACzB;SACF;QACD,OAAO,IAAI,CAAC;IACd,CAAC,CAAC,CAAC;IAEH,0EAA0E;IAC1E,OAAO,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;AACjC,CAAC","sourcesContent":["import { isObjectGuard } from '../_internals/guards';\nimport { valuesComparer } from '../_internals/valuesComparer.util';\nimport { ComparableData } from '../interfaces/comparable-data-type';\n\n/**\n * @description\n * Updates or inserts (if does not exist) one or multiple items in an array T[].\n * For comparison you can provide a key, an array of keys or a custom comparison function that should return true if\n * items match.\n * If no comparison is provided, an equality check is used by default.\n * upsert is `pure` and `immutable`, your inputs won't be changed\n *\n *\n * @example\n * // Upsert (update) with key\n *\n * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];\n *\n * const newCat = {id: 1, type: 'lion'};\n *\n * const updatedCreatures = upsert(creatures, newCat, 'id');\n *\n * // updatedCreatures will be:\n * // [{id: 1, type: 'lion'}, {id: 2, type: 'dog'}];\n *\n * @example\n * // Upsert (insert) with key\n *\n * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];\n *\n * const newCat = {id: 3, type: 'lion'};\n *\n * const updatedCreatures = upsert(creatures, newCat, 'id');\n *\n * // updatedCreatures will be:\n * // [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}, {id: 3, type: 'lion'}];\n *\n * @example\n * // Upsert (update) with array of keys\n *\n * const creatures = [{id: 1, type: 'cat', name: 'Bella'}, {id: 2, type: 'dog', name: 'Sparky'}];\n *\n * const newCat = {id: 1, type: 'lion', name: 'Bella'};\n *\n * const updatedCreatures = upsert(creatures, newCat, ['id', 'name']);\n *\n * // updatedCreatures will be:\n * // [{id: 1, type: 'lion', name: 'Bella'}, {id: 2, type: 'dog', name: 'Sparky'}];\n *\n * @example\n * // Update (insert) with comparison function\n *\n * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];\n *\n * const newCat = {id: 3, type: 'lion'};\n *\n * const updatedCreatures = upsert(creatures, newCat, (a, b) => a.id === b.id);\n *\n * // updatedCreatures will be:\n * // [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}, {id: 3, type: 'lion'}];\n *\n * @example\n * // Usage with RxState\n *\n * export class ListComponent {\n *\n *    // trigger which gets called on add/update (for reactive implementation)\n *    readonly addOrUpdateCreature = new Subject<Creature>();\n *\n *    constructor(private state: RxState<ComponentState>) {\n *      const initialCreatures = [{id: 1, type: 'cat', name: 'Bella'}, {id: 2, type: 'dog', name: 'Sparky'}];\n *      state.set({ creatures: initialCreatures });\n *      // Reactive implementation\n *      state.connect(\n *        'creatures',\n *        this.addOrUpdateCreature,\n *        ({ creatures }, creatureToUpsert) => {\n *            return upsert(creatures, creatureToUpsert, 'id');\n *        }\n *      );\n *    }\n *\n *    // Imperative implementation\n *    updateCreature(creatureToUpdate: Creature): void {\n *        this.state.set({ creatures: upsert(this.state.get('creatures'), creatureToUpdate, 'id')});\n *    }\n * }\n *\n * @returns T[]\n *\n * @docsPage upsert\n * @docsCategory transformation-helpers\n */\nexport function upsert<T>(\n  source: T[],\n  update: Partial<T>[] | Partial<T>,\n  compare?: ComparableData<T>\n): T[] {\n  // check inputs for validity\n  const updatesAsArray =\n    update != null ? (Array.isArray(update) ? update : [update]) : [];\n  // check inputs for validity\n  const sourceIsNotArray = !Array.isArray(source);\n  const invalidInput = sourceIsNotArray && updatesAsArray.length === 0;\n  // if the source value is not an Array or the input is not defined return the original source\n  // this is the case for any edge case:\n  // '', null, undefined, CustomObjectOfDoomAndDarkness, ...\n  if (invalidInput) {\n    return source;\n  }\n\n  // if source is empty array or not an array, but the updates are valid:\n  // return a shallow copy of the updates as result\n  if (updatesAsArray.length > 0 && (sourceIsNotArray || source.length === 0)) {\n    return [...updatesAsArray] as T[];\n  }\n\n  const inserts: T[] = [];\n  const updates: Record<number, Partial<T>> = {};\n  // process updates/inserts\n  for (const item of updatesAsArray) {\n    const match = source.findIndex((sourceItem) =>\n      valuesComparer(item as T, sourceItem, compare)\n    );\n    // if item already exists, save it as update\n    if (match !== -1) {\n      updates[match] = item;\n    } else {\n      // otherwise consider this as insert\n      if (isObjectGuard(item)) {\n        // create a shallow copy if item is an object\n        inserts.push({ ...(item as T) });\n      } else {\n        // otherwise just push it\n        inserts.push(item);\n      }\n    }\n  }\n\n  const updated = source.map((item, i) => {\n    const updatedItem = updates[i];\n    // process the updated\n    if (updatedItem !== null && updatedItem !== undefined) {\n      if (isObjectGuard(item)) {\n        return { ...item, ...updatedItem } as T;\n      } else {\n        return updatedItem as T;\n      }\n    }\n    return item;\n  });\n\n  // return the combination of the updated source & the inserts as new array\n  return updated.concat(inserts);\n}\n"]}