{"version":3,"file":"AsyncScheduler.js","sourceRoot":"","sources":["../../../../../../../../libs/cdk/zone-less/rxjs/src/scheduler/async/AsyncScheduler.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,SAAS,EAAE,MAAM,cAAc,CAAC;AAEzC,MAAM,OAAO,cAAe,SAAQ,SAAS;IAmB3C,YACE,eAA8B,EAC9B,MAAoB,SAAS,CAAC,GAAG;QAEjC,KAAK,CAAC,eAAe,EAAE,GAAG,CAAC,CAAC;QAtB9B,YAAO,GAA4B,EAAE,CAAC;QACtC;;;;;WAKG;QACH,YAAO,GAAG,KAAK,CAAC;QAEhB;;;;;;WAMG;QACH,eAAU,GAAS,SAAS,CAAC;IAO7B,CAAC;IAEM,KAAK,CAAC,MAAwB;QACnC,MAAM,EAAE,OAAO,EAAE,GAAG,IAAI,CAAC;QAEzB,IAAI,IAAI,CAAC,OAAO,EAAE;YAChB,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YACrB,OAAO;SACR;QAED,IAAI,KAAU,CAAC;QACf,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;QAEpB,GAAG;YACD,IAAI,CAAC,KAAK,GAAG,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE;gBACxD,MAAM;aACP;SACF,QAAQ,CAAC,MAAM,GAAG,OAAO,CAAC,KAAK,EAAG,CAAC,EAAE,CAAC,8BAA8B;QAErE,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;QAErB,IAAI,KAAK,EAAE;YACT,OAAO,CAAC,MAAM,GAAG,OAAO,CAAC,KAAK,EAAG,CAAC,EAAE;gBAClC,MAAM,CAAC,WAAW,EAAE,CAAC;aACtB;YACD,MAAM,KAAK,CAAC;SACb;IACH,CAAC;CACF","sourcesContent":["import { Action } from '../Action';\nimport { AsyncAction } from './AsyncAction';\nimport { Scheduler } from '../scheduler';\n\nexport class AsyncScheduler extends Scheduler {\n  actions: Array<AsyncAction<any>> = [];\n  /**\n   * A flag to indicate whether the Scheduler is currently executing a batch of\n   * queued actions.\n   * @type {boolean}\n   * @internal\n   */\n  _active = false;\n\n  /**\n   * An internal ID used to track the latest asynchronous task such as those\n   * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n   * others.\n   * @type {any}\n   * @internal\n   */\n  _scheduled?: any = undefined;\n\n  constructor(\n    SchedulerAction: typeof Action,\n    now: () => number = Scheduler.now\n  ) {\n    super(SchedulerAction, now);\n  }\n\n  public flush(action: AsyncAction<any>): void {\n    const { actions } = this;\n\n    if (this._active) {\n      actions.push(action);\n      return;\n    }\n\n    let error: any;\n    this._active = true;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions.shift()!)); // exhaust the scheduler queue\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions.shift()!)) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n"]}