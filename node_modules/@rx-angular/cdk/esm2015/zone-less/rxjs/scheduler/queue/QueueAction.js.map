{"version":3,"file":"QueueAction.js","sourceRoot":"","sources":["../../../../../../../../libs/cdk/zone-less/rxjs/src/scheduler/queue/QueueAction.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,WAAW,EAAE,MAAM,sBAAsB,CAAC;AAKnD;;;;GAIG;AACH,MAAM,OAAO,WAAe,SAAQ,WAAc;IAChD,YACY,SAAyB,EACzB,IAAmD;QAE7D,KAAK,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;QAHb,cAAS,GAAT,SAAS,CAAgB;QACzB,SAAI,GAAJ,IAAI,CAA+C;IAG/D,CAAC;IAEM,QAAQ,CAAC,KAAS,EAAE,QAAgB,CAAC;QAC1C,IAAI,KAAK,GAAG,CAAC,EAAE;YACb,OAAO,KAAK,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;SACrC;QACD,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAC3B,OAAO,IAAI,CAAC;IACd,CAAC;IAEM,OAAO,CAAC,KAAQ,EAAE,KAAa;QACpC,OAAO,KAAK,GAAG,CAAC,IAAI,IAAI,CAAC,MAAM;YAC7B,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,CAAC;YAC7B,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;IAClC,CAAC;IAES,cAAc,CACtB,SAAyB,EACzB,EAAQ,EACR,QAAgB,CAAC;QAEjB,sEAAsE;QACtE,sEAAsE;QACtE,2CAA2C;QAC3C,IAAI,CAAC,KAAK,KAAK,IAAI,IAAI,KAAK,GAAG,CAAC,CAAC,IAAI,CAAC,KAAK,KAAK,IAAI,IAAI,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC,EAAE;YACvE,OAAO,KAAK,CAAC,cAAc,CAAC,SAAS,EAAE,EAAE,EAAE,KAAK,CAAC,CAAC;SACnD;QACD,2DAA2D;QAC3D,OAAO,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;IAC/B,CAAC;CACF","sourcesContent":["import { AsyncAction } from '../async/AsyncAction';\nimport { Subscription } from 'rxjs';\nimport { SchedulerAction } from '../types';\nimport { QueueScheduler } from './QueueScheduler';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class QueueAction<T> extends AsyncAction<T> {\n  constructor(\n    protected scheduler: QueueScheduler,\n    protected work: (this: SchedulerAction<T>, state?: T) => void\n  ) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (delay > 0) {\n      return super.schedule(state, delay);\n    }\n    this.delay = delay;\n    this.state = state;\n    this.scheduler.flush(this);\n    return this;\n  }\n\n  public execute(state: T, delay: number): any {\n    return delay > 0 || this.closed\n      ? super.execute(state, delay)\n      : this._execute(state, delay);\n  }\n\n  protected requestAsyncId(\n    scheduler: QueueScheduler,\n    id?: any,\n    delay: number = 0\n  ): any {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Otherwise flush the scheduler starting with this action.\n    return scheduler.flush(this);\n  }\n}\n"]}