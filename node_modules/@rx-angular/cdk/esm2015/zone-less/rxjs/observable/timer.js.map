{"version":3,"file":"timer.js","sourceRoot":"","sources":["../../../../../../../libs/cdk/zone-less/rxjs/src/observable/timer.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAA8C,MAAM,MAAM,CAAC;AAC9E,OAAO,EAAE,cAAc,EAAE,MAAM,0BAA0B,CAAC;AAC1D,OAAO,EAAE,SAAS,EAAE,WAAW,EAAE,MAAM,SAAS,CAAC;AAEjD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAkDG;AACH,MAAM,UAAU,KAAK,CACnB,UAAyB,CAAC,EAC1B,iBAA0C,EAC1C,SAAyB;IAEzB,IAAI,MAAM,GAAG,CAAC,CAAC,CAAC;IAChB,IAAI,SAAS,CAAC,iBAAiB,CAAC,EAAE;QAChC,MAAM,GAAG,CAAC,MAAM,CAAC,iBAAiB,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,IAAI,MAAM,CAAC,iBAAiB,CAAC,CAAC;KAC5E;SAAM,IAAI,WAAW,CAAC,iBAAiB,CAAC,EAAE;QACzC,SAAS,GAAG,iBAAwB,CAAC;KACtC;IAED,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,EAAE;QAC3B,SAAS,GAAG,cAAc,CAAC;KAC5B;IAED,OAAO,IAAI,UAAU,CAAC,CAAC,UAAU,EAAE,EAAE;QACnC,MAAM,GAAG,GAAG,SAAS,CAAC,OAAO,CAAC;YAC5B,CAAC,CAAE,OAAkB;YACrB,CAAC,CAAC,CAAC,OAAO,GAAG,SAAS,CAAC,GAAG,EAAE,CAAC;QAE/B,OAAO,SAAS,CAAC,QAAQ,CAAC,QAAQ,EAAE,GAAG,EAAE;YACvC,KAAK,EAAE,CAAC;YACR,MAAM;YACN,UAAU;SACX,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;AACL,CAAC;AAQD,SAAS,QAAQ,CAAoC,KAAiB;IACpE,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,UAAU,EAAE,GAAG,KAAK,CAAC;IAC5C,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IAEvB,IAAI,UAAU,CAAC,MAAM,EAAE;QACrB,OAAO;KACR;SAAM,IAAI,MAAM,KAAK,CAAC,CAAC,EAAE;QACxB,OAAO,UAAU,CAAC,QAAQ,EAAE,CAAC;KAC9B;IAED,KAAK,CAAC,KAAK,GAAG,KAAK,GAAG,CAAC,CAAC;IACxB,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;AAC/B,CAAC","sourcesContent":["import { Observable, SchedulerAction, SchedulerLike, Subscriber } from 'rxjs';\nimport { asyncScheduler } from '../scheduler/async/async';\nimport { isNumeric, isScheduler } from './utils';\n\n/**\n * Creates an Observable that starts emitting after an `dueTime` and\n * emits ever increasing numbers after each `period` of time thereafter.\n *\n * <span class=\"informal\">Its like {@link index/interval}, but you can specify when\n * should the emissions start.</span>\n *\n * ![](timer.png)\n *\n * `timer` returns an Observable that emits an infinite sequence of ascending\n * integers, with a constant interval of time, `period` of your choosing\n * between those emissions. The first emission happens after the specified\n * `dueTime`. The initial delay may be a `Date`. By default, this\n * operator uses the {@link asyncScheduler} {@link SchedulerLike} to provide a notion of time, but you\n * may pass any {@link SchedulerLike} to it. If `period` is not specified, the output\n * Observable emits only one value, `0`. Otherwise, it emits an infinite\n * sequence.\n *\n * ## Examples\n * ### Emits ascending numbers, one every second (1000ms), starting after 3 seconds\n * ```ts\n * import { timer } from 'rxjs';\n *\n * const numbers = timer(3000, 1000);\n * numbers.subscribe(x => console.log(x));\n * ```\n *\n * ### Emits one number after five seconds\n * ```ts\n * import { timer } from 'rxjs';\n *\n * const numbers = timer(5000);\n * numbers.subscribe(x => console.log(x));\n * ```\n * @see {@link index/interval}\n * @see {@link delay}\n *\n * @param {number|Date} [dueTime] The initial delay time specified as a Date object or as an integer denoting\n * milliseconds to wait before emitting the first value of 0`.\n * @param {number|SchedulerLike} [periodOrScheduler] The period of time between emissions of the\n * subsequent numbers.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for scheduling\n * the emission of values, and providing a notion of \"time\".\n * @return {Observable} An Observable that emits a `0` after the\n * `dueTime` and ever increasing numbers after each `period` of time\n * thereafter.\n * @static true\n * @deprecated will be removed with 1.0.0\n * @name timer\n * @owner Observable\n */\nexport function timer(\n  dueTime: number | Date = 0,\n  periodOrScheduler?: number | SchedulerLike,\n  scheduler?: SchedulerLike\n): Observable<number> {\n  let period = -1;\n  if (isNumeric(periodOrScheduler)) {\n    period = (Number(periodOrScheduler) < 1 && 1) || Number(periodOrScheduler);\n  } else if (isScheduler(periodOrScheduler)) {\n    scheduler = periodOrScheduler as any;\n  }\n\n  if (!isScheduler(scheduler)) {\n    scheduler = asyncScheduler;\n  }\n\n  return new Observable((subscriber) => {\n    const due = isNumeric(dueTime)\n      ? (dueTime as number)\n      : +dueTime - scheduler.now();\n\n    return scheduler.schedule(dispatch, due, {\n      index: 0,\n      period,\n      subscriber,\n    });\n  });\n}\n\ninterface TimerState {\n  index: number;\n  period: number;\n  subscriber: Subscriber<number>;\n}\n\nfunction dispatch(this: SchedulerAction<TimerState>, state: TimerState) {\n  const { index, period, subscriber } = state;\n  subscriber.next(index);\n\n  if (subscriber.closed) {\n    return;\n  } else if (period === -1) {\n    return subscriber.complete();\n  }\n\n  state.index = index + 1;\n  this.schedule(state, period);\n}\n"]}