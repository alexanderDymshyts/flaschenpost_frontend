{"version":3,"file":"accumulateObservables.js","sourceRoot":"","sources":["../../../../../../../libs/cdk/internals/core/src/lib/accumulateObservables.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,YAAY,EAAE,MAAM,4BAA4B,CAAC;AAC1D,OAAO,EAAE,aAAa,EAAE,IAAI,EAAc,MAAM,MAAM,CAAC;AACvD,OAAO,EAAE,oBAAoB,EAAE,MAAM,EAAE,GAAG,EAAE,WAAW,EAAE,MAAM,gBAAgB,CAAC;AAShF,OAAO,EAAE,mBAAmB,EAAE,MAAM,0BAA0B,CAAC;AAE/D,MAAM,eAAe,GAAG,mBAAmB,CAAC,SAAS,CAAC,CAAC,OAAO,EAAE,CAAC;AACjE,MAAM,gBAAgB,GAAG,IAAI,CAAC,eAAe,CAAC,CAAC;AAE/C;;;;GAIG;AACH,SAAS,2BAA2B,CAClC,IAAmB;IAEnB,OAAO,CACL,WAAc,EACd,YAA0B,EAC1B,YAAqB,EAClB,EAAE;QACL,uCACK,WAAW,KACd,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,EAAE,YAAY,IAClC;IACJ,CAAC,CAAC;AACJ,CAAC;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAmCG;AACH,MAAM,UAAU,qBAAqB;AACnC,sFAAsF;AACtF,GAAM,EACN,mBAAoC,gBAAgB;IAEpD,MAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,CAAgB,CAAC;IAC7C,4EAA4E;IAC5E,MAAM,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CACnC,GAAG,CAAC,GAAG,CAAC,CAAC,IAAI;IACX,+CAA+C;IAC/C,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,KAAK,SAAS,CAAC;IAC9B,gFAAgF;IAChF,oBAAoB,EAAE,CACvB,CACF,CAAC;IACF,OAAO,aAAa,CAAC,WAAW,CAAC,CAAC,IAAI;IACpC,4GAA4G;IAC5G,WAAW;IACX,YAAY,CAAC,gBAAgB,CAAC;IAC9B,oCAAoC;IACpC,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CACb,MAAM,CAAC,MAAM,CAAC,2BAA2B,CAAC,IAAI,CAAC,EAAE,EAAS,CAAC,CAC5D;IACD,gGAAgG;IAChG,WAAW,CAAC,EAAC,QAAQ,EAAE,IAAI,EAAE,UAAU,EAAE,CAAC,EAAC,CAAC,CAC7C,CAAC;AACJ,CAAC","sourcesContent":["import { coalesceWith } from '@rx-angular/cdk/coalescing';\nimport { combineLatest, from, Observable } from 'rxjs';\nimport { distinctUntilChanged, filter, map, shareReplay } from 'rxjs/operators';\nimport {\n  ArrayReducerFn,\n  ExtractObservableValue,\n  NotEmpty,\n  ObservableMap,\n  PropName,\n  PropType,\n} from './model';\nimport { getZoneUnPatchedApi } from './get-zone-unpatched-api';\n\nconst resolvedPromise = getZoneUnPatchedApi('Promise').resolve();\nconst resolvedPromise$ = from(resolvedPromise);\n\n/**\n * @internal\n *\n * Used for typing\n */\nfunction getEntriesToObjectReducerFn<T extends Record<string, any>>(\n  keys: PropName<T>[]\n): ArrayReducerFn<T> {\n  return (\n    accumulator: T,\n    currentValue?: PropType<T>,\n    currentIndex?: number\n  ): T => {\n    return {\n      ...accumulator,\n      [keys[currentIndex]]: currentValue,\n    };\n  };\n}\n\n/**\n * This Observable creation function helps to accumulate an object of key & Observable of values to\n * an Observable of objects of key & value.\n * This comes in handy if you quickly want to create subsets as objects/state-slices of different Observables.\n *\n * The resulting Observable filters out undefined values forwards only distinct values and shared the aggregated output.\n *\n * @example\n *\n * Default usage:\n *\n * const object$: Observable<{\n *   prop1: number,\n *   prop2: string,\n *   prop3: string\n * }> = accumulateObservables({\n *   prop1: interval(42),\n *   prop2: of('lorem'),\n *   prop3: 'test'\n * });\n *\n * Usage with custom duration selector:\n *\n * const object$: Observable<{\n *   prop1: number,\n *   prop2: string,\n *   prop3: string\n * }> = accumulateObservables({\n *   prop1: interval(42),\n *   prop2: of('lorem'),\n *   prop3: 'test'\n * }, timer(0, 20));\n *\n * @param obj - An object of key & Observable values pairs\n * @param durationSelector - An Observable determining the duration for the internal coalescing method\n */\nexport function accumulateObservables<T extends ObservableMap & NotEmpty<T>>(\n  // @TODO type static or Observable to enable mixing of imperative and reatctive values\n  obj: T,\n  durationSelector: Observable<any> = resolvedPromise$\n): Observable<{ [K in keyof T]: ExtractObservableValue<T[K]> }> {\n  const keys = Object.keys(obj) as (keyof T)[];\n  // @TODO better typing to enable static values => coerceObservable(obj[key])\n  const observables = keys.map((key) =>\n    obj[key].pipe(\n      // we avoid using the nullish operator later ;)\n      filter((v) => v !== undefined),\n      // state \"changes\" differ from each other, this operator ensures distinct values\n      distinctUntilChanged()\n    )\n  );\n  return combineLatest(observables).pipe(\n    // As combineLatest will emit multiple times for a change in multiple properties we coalesce those emissions\n    // together\n    coalesceWith(durationSelector),\n    // mapping array of values to object\n    map((values) =>\n      values.reduce(getEntriesToObjectReducerFn(keys), {} as any)\n    ),\n    // by using shareReplay we share the last composition work done to create the accumulated object\n    shareReplay({refCount: true, bufferSize: 1})\n  );\n}\n"]}