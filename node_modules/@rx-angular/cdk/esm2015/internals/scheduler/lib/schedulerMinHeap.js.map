{"version":3,"file":"schedulerMinHeap.js","sourceRoot":"","sources":["../../../../../../../libs/cdk/internals/scheduler/src/lib/schedulerMinHeap.ts"],"names":[],"mappings":"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","sourcesContent":["import { NgZone } from '@angular/core';\nimport { PriorityLevel } from './schedulerPriorities';\n\ntype Heap = Array<ReactSchedulerTask>;\n\nexport interface SchedulerTaskZone {\n  run<T>(fn: (...args: any[]) => T): T;\n}\n\nexport interface ReactSchedulerTask {\n  id: number;\n  sortIndex: number;\n  callback: Function;\n  priorityLevel: PriorityLevel;\n  startTime: number;\n  expirationTime: number;\n  isQueued?: boolean;\n  ngZone?: SchedulerTaskZone;\n}\n\nexport function push(heap: Heap, node: ReactSchedulerTask): void {\n  const index = heap.length;\n  heap.push(node);\n  siftUp(heap, node, index);\n}\n\nexport function peek(heap: Heap): ReactSchedulerTask | null {\n  const first = heap[0];\n  return first === undefined ? null : first;\n}\n\nexport function pop(heap: Heap): ReactSchedulerTask | null {\n  const first = heap[0];\n  if (first !== undefined) {\n    const last = heap.pop();\n    if (last !== first) {\n      heap[0] = last;\n      siftDown(heap, last, 0);\n    }\n    return first;\n  } else {\n    return null;\n  }\n}\n\nfunction siftUp(heap, node, i) {\n  let index = i;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const parentIndex = (index - 1) >>> 1;\n    const parent = heap[parentIndex];\n    if (parent !== undefined && compare(parent, node) > 0) {\n      // The parent is larger. Swap positions.\n      heap[parentIndex] = node;\n      heap[index] = parent;\n      index = parentIndex;\n    } else {\n      // The parent is smaller. Exit.\n      return;\n    }\n  }\n}\n\nfunction siftDown(heap, node, i) {\n  let index = i;\n  const length = heap.length;\n  while (index < length) {\n    const leftIndex = (index + 1) * 2 - 1;\n    const left = heap[leftIndex];\n    const rightIndex = leftIndex + 1;\n    const right = heap[rightIndex];\n\n    // If the left or right node is smaller, swap with the smaller of those.\n    if (left !== undefined && compare(left, node) < 0) {\n      if (right !== undefined && compare(right, left) < 0) {\n        heap[index] = right;\n        heap[rightIndex] = node;\n        index = rightIndex;\n      } else {\n        heap[index] = left;\n        heap[leftIndex] = node;\n        index = leftIndex;\n      }\n    } else if (right !== undefined && compare(right, node) < 0) {\n      heap[index] = right;\n      heap[rightIndex] = node;\n      index = rightIndex;\n    } else {\n      // Neither child is smaller. Exit.\n      return;\n    }\n  }\n}\n\nfunction compare(a, b) {\n  // Compare sort index first, then task id.\n  const diff = a.sortIndex - b.sortIndex;\n  return diff !== 0 ? diff : a.id - b.id;\n}\n"]}