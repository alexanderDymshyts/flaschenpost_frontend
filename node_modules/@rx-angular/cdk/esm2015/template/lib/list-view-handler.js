import { createEmbeddedView } from './utils';
/**
 * @internal
 *
 * Factory that returns a `ListTemplateManager` for the passed params.
 *
 * @param templateSettings
 */
export function getTemplateHandler(templateSettings) {
    const { viewContainerRef, initialTemplateRef, createViewContext, updateViewContext, } = templateSettings;
    return {
        updateUnchangedContext,
        insertView,
        moveView,
        removeView,
        getListChanges,
        updateView,
    };
    // =====
    function updateUnchangedContext(item, index, count) {
        const view = viewContainerRef.get(index);
        updateViewContext(item, view, {
            count,
            index,
        });
        view.detectChanges();
    }
    function moveView(oldIndex, item, index, count) {
        const oldView = viewContainerRef.get(oldIndex);
        const view = viewContainerRef.move(oldView, index);
        updateViewContext(item, view, {
            count,
            index,
        });
        view.detectChanges();
    }
    function updateView(item, index, count) {
        const view = viewContainerRef.get(index);
        updateViewContext(item, view, {
            count,
            index,
        });
        view.detectChanges();
    }
    function removeView(index) {
        return viewContainerRef.remove(index);
    }
    function insertView(item, index, count) {
        createEmbeddedView(viewContainerRef, initialTemplateRef, createViewContext(item, {
            count,
            index,
        }), index);
    }
}
/**
 * @internal
 *
 * @param changes
 * @param items
 */
function getListChanges(changes, items) {
    const changedIdxs = new Set();
    const changesArr = [];
    let notifyParent = false;
    changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {
        const item = record.item;
        if (record.previousIndex == null) {
            // insert
            changesArr.push(getInsertChange(item, currentIndex === null ? undefined : currentIndex));
            changedIdxs.add(item);
            notifyParent = true;
        }
        else if (currentIndex == null) {
            // remove
            changesArr.push(getRemoveChange(item, adjustedPreviousIndex === null ? undefined : adjustedPreviousIndex));
            notifyParent = true;
        }
        else if (adjustedPreviousIndex !== null) {
            // move
            changesArr.push(getMoveChange(item, currentIndex, adjustedPreviousIndex));
            changedIdxs.add(item);
            notifyParent = true;
        }
    });
    changes.forEachIdentityChange((record) => {
        const item = record.item;
        if (!changedIdxs.has(item)) {
            changesArr.push(getUpdateChange(item, record.currentIndex));
            changedIdxs.add(item);
        }
    });
    items.forEach((item, index) => {
        if (!changedIdxs.has(item)) {
            changesArr.push(getUnchangedChange(item, index));
        }
    });
    return [changesArr, notifyParent];
    // ==========
    function getMoveChange(item, currentIndex, adjustedPreviousIndex) {
        return [
            2 /* move */,
            [item, currentIndex, adjustedPreviousIndex],
        ];
    }
    function getUpdateChange(item, currentIndex) {
        return [3 /* update */, [item, currentIndex]];
    }
    function getUnchangedChange(item, index) {
        return [4 /* context */, [item, index]];
    }
    function getInsertChange(item, currentIndex) {
        return [
            0 /* insert */,
            [item, currentIndex === null ? undefined : currentIndex],
        ];
    }
    function getRemoveChange(item, adjustedPreviousIndex) {
        return [
            1 /* remove */,
            [
                item,
                adjustedPreviousIndex === null ? undefined : adjustedPreviousIndex,
            ],
        ];
    }
}
//# sourceMappingURL=list-view-handler.js.map