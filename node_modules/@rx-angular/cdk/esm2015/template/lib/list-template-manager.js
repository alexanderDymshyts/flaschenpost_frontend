import { combineLatest, of } from 'rxjs';
import { catchError, distinctUntilChanged, map, switchMap, tap, } from 'rxjs/operators';
import { onStrategy, strategyHandling, } from '@rx-angular/cdk/render-strategies';
import { getTemplateHandler } from './list-view-handler';
import { createErrorHandler } from './render-error';
import { notifyAllParentsIfNeeded } from './utils';
export function createListTemplateManager(config) {
    const { templateSettings, renderSettings, trackBy, iterableDiffers } = config;
    const { defaultStrategyName, strategies, cdRef: injectingViewCdRef, patchZone, parent, } = renderSettings;
    const errorHandler = createErrorHandler(renderSettings.errorHandler);
    const ngZone = patchZone ? patchZone : undefined;
    const strategyHandling$ = strategyHandling(defaultStrategyName, strategies);
    let _differ;
    function getDiffer(values) {
        if (_differ) {
            return _differ;
        }
        return values
            ? (_differ = iterableDiffers.find(values).create(trackBy))
            : null;
    }
    //               type,  context
    /* TODO (regarding createView): this is currently not in use. for the list-manager this would mean to provide
     functions for not only create. developers than should have to provide create, move, remove,... the whole thing.
     i don't know if this is the right decision for a first RC */
    const listViewHandler = getTemplateHandler(Object.assign(Object.assign({}, templateSettings), { initialTemplateRef: templateSettings.templateRef }));
    const viewContainerRef = templateSettings.viewContainerRef;
    let notifyParent = false;
    let changesArr;
    let partiallyFinished = false;
    return {
        nextStrategy(nextConfig) {
            strategyHandling$.next(nextConfig);
        },
        render(values$) {
            return values$.pipe(render());
        },
    };
    function handleError() {
        return (o$) => o$.pipe(catchError((err) => {
            partiallyFinished = false;
            errorHandler.handleError(err);
            return of(null);
        }));
    }
    function render() {
        return (o$) => combineLatest([
            o$,
            strategyHandling$.strategy$.pipe(distinctUntilChanged()),
        ]).pipe(map(([iterable, strategy]) => {
            const differ = getDiffer(iterable);
            let changes;
            if (differ) {
                if (partiallyFinished) {
                    const currentIterable = [];
                    for (let i = 0, ilen = viewContainerRef.length; i < ilen; i++) {
                        const viewRef = viewContainerRef.get(i);
                        currentIterable[i] = viewRef.context.$implicit;
                    }
                    differ.diff(currentIterable);
                }
                changes = differ.diff(iterable);
            }
            return {
                changes,
                iterable,
                strategy,
            };
        }), 
        // Cancel old renders
        switchMap(({ changes, iterable, strategy }) => {
            if (!changes) {
                return of([]);
            }
            const values = iterable || [];
            // TODO: we might want to treat other iterables in a more performant way than Array.from()
            const items = Array.isArray(values) ? values : Array.from(iterable);
            const listChanges = listViewHandler.getListChanges(changes, items);
            changesArr = listChanges[0];
            const insertedOrRemoved = listChanges[1];
            const applyChanges$ = getObservablesFromChangesArray(changesArr, strategy, items.length);
            partiallyFinished = true;
            notifyParent = insertedOrRemoved && parent;
            return combineLatest(applyChanges$.length > 0 ? applyChanges$ : [of(null)]).pipe(tap(() => (partiallyFinished = false)), notifyAllParentsIfNeeded(injectingViewCdRef, strategy, () => notifyParent, ngZone), handleError(), map(() => iterable));
        }), handleError());
    }
    /**
     * @internal
     *
     * returns an array of streams which process all of the view updates needed to reflect the latest diff to the
     * viewContainer.
     * I
     *
     * @param changes
     * @param strategy
     * @param count
     */
    function getObservablesFromChangesArray(changes, strategy, count) {
        return changes.length > 0
            ? changes.map((change) => {
                const payload = change[1];
                return onStrategy(change[0], strategy, (type) => {
                    switch (type) {
                        case 0 /* insert */:
                            listViewHandler.insertView(payload[0], payload[1], count);
                            break;
                        case 2 /* move */:
                            listViewHandler.moveView(payload[2], payload[0], payload[1], count);
                            break;
                        case 1 /* remove */:
                            listViewHandler.removeView(payload[1]);
                            break;
                        case 3 /* update */:
                            listViewHandler.updateView(payload[0], payload[1], count);
                            break;
                        case 4 /* context */:
                            listViewHandler.updateUnchangedContext(payload[0], payload[1], count);
                            break;
                    }
                }, { ngZone });
            })
            : [of(null)];
    }
}
//# sourceMappingURL=list-template-manager.js.map