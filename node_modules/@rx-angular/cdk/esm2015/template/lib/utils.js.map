{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../../../../libs/cdk/template/src/lib/utils.ts"],"names":[],"mappings":"AAOA,OAAO,EACL,UAAU,GAEX,MAAM,mCAAmC,CAAC;AAC3C,OAAO,EAAE,MAAM,EAA4B,EAAE,EAAE,MAAM,MAAM,CAAC;AAC5D,OAAO,EAAE,cAAc,EAAE,SAAS,EAAE,MAAM,gBAAgB,CAAC;AAE3D;;;;;;;;;GASG;AACH,MAAM,UAAU,kBAAkB,CAChC,gBAAkC,EAClC,WAA2B,EAC3B,OAAU,EACV,KAAK,GAAG,CAAC;IAET,MAAM,IAAI,GAAG,gBAAgB,CAAC,kBAAkB,CAAC,WAAW,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;IAC9E,IAAI,CAAC,aAAa,EAAE,CAAC;IACrB,OAAO,IAAI,CAAC;AACd,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,gBAAgB,CAC9B,gBAAkC;IAMlC,MAAM,aAAa,GAAG,IAAI,GAAG,EAAqB,CAAC;IAEnD,MAAM,GAAG,GAAG,CAAC,IAAO,EAAkB,EAAE;QACtC,OAAO,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IACjC,CAAC,CAAC;IACF,OAAO;QACL,GAAG,CAAC,IAAO,EAAE,WAA2B;YACtC,cAAc,CAAC,IAAI,EAAE,WAAW,CAAC,CAAC;YAClC,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;gBAC5B,aAAa,CAAC,GAAG,CAAC,IAAI,EAAE,WAAW,CAAC,CAAC;aACtC;iBAAM;gBACL,MAAM,IAAI,KAAK,CACb,uEAAuE,CACxE,CAAC;aACH;QACH,CAAC;QACD,GAAG;QACH,kBAAkB,EAAE,CAAC,IAAO,EAAE,OAAW,EAAE,EAAE,CAC3C,kBAAkB,CAAC,gBAAgB,EAAE,GAAG,CAAC,IAAI,CAAC,EAAE,OAAO,CAAC;KAC3D,CAAC;IAEF,EAAE;IACF,SAAS,cAAc,CACrB,QAAa,EACb,WAAkC;QAElC,MAAM,mBAAmB,GAAG,CAAC,CAAC,CAC5B,CAAC,WAAW,IAAI,WAAW,CAAC,kBAAkB,CAC/C,CAAC;QACF,IAAI,CAAC,mBAAmB,EAAE;YACxB,MAAM,IAAI,KAAK,CACb,GAAG,QAAQ,sDAAsD,CAClE,CAAC;SACH;QACD,OAAO,mBAAmB,CAAC;IAC7B,CAAC;AACH,CAAC;AAED;;;;;;;;;;GAUG;AACH,MAAM,UAAU,wBAAwB,CACtC,kBAAqC,EACrC,QAA+B,EAC/B,YAA2B,EAC3B,MAAe;IAEf,OAAO,CAAC,EAAE,EAAE,EAAE,CACZ,EAAE,CAAC,IAAI,CACL,SAAS,CAAC,CAAC,CAAC,EAAE,EAAE;QACd,MAAM,YAAY,GAAG,YAAY,EAAE,CAAC;QACpC,IAAI,CAAC,YAAY,EAAE;YACjB,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC;SACd;QACD,OAAO,MAAM,CACX,EAAE,CAAC,CAAC,CAAC,EACL,UAAU,CACR,kBAAkB,EAClB,QAAQ,EACR,CAAC,EAAE,EAAE,IAAI,EAAE,OAAO,EAAE,EAAE;YACpB;;;iBAGK;YACL,IAAI,CAAC,kBAAkB,EAAE,OAAO,CAAC,KAAK,CAAC,CAAC;QAC1C,CAAC,EACD;YACE,KAAK,EAAG,kBAA0B,CAAC,OAAO,IAAI,kBAAkB;YAChE,MAAM;SACP,CACF,CAAC,IAAI,CAAC,cAAc,EAAE,CAAC,CACzB,CAAC;IACJ,CAAC,CAAC,CACH,CAAC;AACN,CAAC","sourcesContent":["import {\n  ChangeDetectorRef,\n  EmbeddedViewRef,\n  NgZone,\n  TemplateRef,\n  ViewContainerRef,\n} from '@angular/core';\nimport {\n  onStrategy,\n  RxStrategyCredentials,\n} from '@rx-angular/cdk/render-strategies';\nimport { concat, MonoTypeOperatorFunction, of } from 'rxjs';\nimport { ignoreElements, switchMap } from 'rxjs/operators';\n\n/**\n * @internal\n * creates an embeddedViewRef\n *\n * @param viewContainerRef\n * @param templateRef\n * @param context\n * @param index\n * @return EmbeddedViewRef<C>\n */\nexport function createEmbeddedView<C>(\n  viewContainerRef: ViewContainerRef,\n  templateRef: TemplateRef<C>,\n  context: C,\n  index = 0\n): EmbeddedViewRef<C> {\n  const view = viewContainerRef.createEmbeddedView(templateRef, context, index);\n  view.detectChanges();\n  return view;\n}\n\n/**\n * @internal\n *\n * A factory function returning an object to handle `TemplateRef`'s.\n * You can add and get a `TemplateRef`.\n *\n */\nexport function templateHandling<N, C>(\n  viewContainerRef: ViewContainerRef\n): {\n  add(name: N, templateRef: TemplateRef<C>): void;\n  get(name: N): TemplateRef<C>;\n  createEmbeddedView(name: N, context?: C, index?: number): EmbeddedViewRef<C>;\n} {\n  const templateCache = new Map<N, TemplateRef<C>>();\n\n  const get = (name: N): TemplateRef<C> => {\n    return templateCache.get(name);\n  };\n  return {\n    add(name: N, templateRef: TemplateRef<C>): void {\n      assertTemplate(name, templateRef);\n      if (!templateCache.has(name)) {\n        templateCache.set(name, templateRef);\n      } else {\n        throw new Error(\n          'Updating an already existing Template is not supported at the moment.'\n        );\n      }\n    },\n    get,\n    createEmbeddedView: (name: N, context?: C) =>\n      createEmbeddedView(viewContainerRef, get(name), context),\n  };\n\n  //\n  function assertTemplate<T>(\n    property: any,\n    templateRef: TemplateRef<T> | null\n  ): templateRef is TemplateRef<T> {\n    const isTemplateRefOrNull = !!(\n      !templateRef || templateRef.createEmbeddedView\n    );\n    if (!isTemplateRefOrNull) {\n      throw new Error(\n        `${property} must be a TemplateRef, but received something else.`\n      );\n    }\n    return isTemplateRefOrNull;\n  }\n}\n\n/**\n * @internal\n *\n * A side effect operator similar to `tap` but with a static internal logic.\n * It calls detect changes on the 'VirtualParent' and the injectingViewCdRef.\n *\n * @param injectingViewCdRef\n * @param strategy\n * @param notifyNeeded\n * @param ngZone\n */\nexport function notifyAllParentsIfNeeded<T>(\n  injectingViewCdRef: ChangeDetectorRef,\n  strategy: RxStrategyCredentials,\n  notifyNeeded: () => boolean,\n  ngZone?: NgZone\n): MonoTypeOperatorFunction<T> {\n  return (o$) =>\n    o$.pipe(\n      switchMap((v) => {\n        const notifyParent = notifyNeeded();\n        if (!notifyParent) {\n          return of(v);\n        }\n        return concat(\n          of(v),\n          onStrategy(\n            injectingViewCdRef,\n            strategy,\n            (_v, work, options) => {\n              /*console.log(\n               'notifyAllParentsIfNeeded injectingView',\n               (injectingViewCdRef as any).context\n               );*/\n              work(injectingViewCdRef, options.scope);\n            },\n            {\n              scope: (injectingViewCdRef as any).context || injectingViewCdRef,\n              ngZone,\n            }\n          ).pipe(ignoreElements())\n        );\n      })\n    );\n}\n"]}