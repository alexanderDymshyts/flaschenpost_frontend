import { onStrategy, strategyHandling, } from '@rx-angular/cdk/render-strategies';
import { EMPTY, merge, of } from 'rxjs';
import { catchError, map, switchMap, tap, withLatestFrom, } from 'rxjs/operators';
import { createErrorHandler } from './render-error';
import { notifyAllParentsIfNeeded, templateHandling } from './utils';
/**
 * @internal
 *
 * A factory function that returns a map of projections to turn a notification of a Observable (next, error, complete)
 *
 * @param customNextContext - projection function to provide custom properties as well as override existing
 */
export function notificationKindToViewContext(customNextContext) {
    // @TODO rethink overrides
    return {
        suspense: (notification) => {
            const $implicit = notification.value;
            return Object.assign({ $implicit, suspense: true, error: false, complete: false }, customNextContext($implicit));
        },
        next: (notification) => {
            const $implicit = notification.value;
            return Object.assign({ $implicit, suspense: false, error: false, complete: false }, customNextContext($implicit));
        },
        error: (notification) => {
            const $implicit = notification.value;
            return Object.assign({ $implicit, complete: false, error: notification.error || true, suspense: false }, customNextContext($implicit));
        },
        complete: (notification) => {
            const $implicit = notification.value;
            return Object.assign({ $implicit, error: false, complete: true, suspense: false }, customNextContext($implicit));
        },
    };
}
export function createTemplateManager(config) {
    const { renderSettings, notificationToTemplateName, templateSettings } = config;
    const { defaultStrategyName, strategies, cdRef: injectingViewCdRef, patchZone, parent, } = renderSettings;
    const errorHandler = createErrorHandler(renderSettings.errorHandler);
    const ngZone = patchZone ? patchZone : undefined;
    let activeTemplate;
    const strategyHandling$ = strategyHandling(defaultStrategyName, strategies);
    const templates = templateHandling(templateSettings.viewContainerRef);
    const viewContainerRef = templateSettings.viewContainerRef;
    const triggerHandling = config.templateTrigger$ || EMPTY;
    const getContext = notificationKindToViewContext(templateSettings.customContext || (() => ({})));
    return {
        addTemplateRef: (name, templateRef) => {
            templates.add(name, templateRef);
        },
        nextStrategy: strategyHandling$.next,
        render(values$) {
            let trg;
            let notification = {
                value: undefined,
                complete: false,
                error: false,
                kind: "suspense" /* Suspense */,
                hasValue: false,
            };
            return merge(values$.pipe(tap((n) => (notification = n))), triggerHandling.pipe(tap((trigger) => (trg = trigger)))).pipe(map(() => {
                const contextKind = trg || notification.kind;
                trg = undefined;
                const value = notification.value;
                const templateName = notificationToTemplateName[contextKind](value, templates);
                const template = templates.get(templateName);
                return { template, templateName, notification, contextKind };
            }), withLatestFrom(strategyHandling$.strategy$), 
            // Cancel old renders
            switchMap(([{ template, templateName, notification, contextKind }, strategy,]) => {
                const isNewTemplate = activeTemplate !== templateName || !template;
                const notifyParent = isNewTemplate && parent;
                return onStrategy(notification.value, strategy, (v, work, options) => {
                    const context = getContext[contextKind](notification);
                    if (isNewTemplate) {
                        // template has changed (undefined => next; suspense => next; ...)
                        // handle remove & insert
                        // remove current view if there is any
                        if (viewContainerRef.length > 0) {
                            // patch removal if needed
                            viewContainerRef.clear();
                        }
                        // create new view if any
                        if (template) {
                            // createEmbeddedView is already patched, no need for workFactory
                            templates.createEmbeddedView(templateName, context);
                        }
                    }
                    else if (template) {
                        // template didn't change, update it
                        // handle update
                        const view = viewContainerRef.get(0);
                        Object.keys(context).forEach((k) => {
                            view.context[k] = context[k];
                        });
                        // update view context, patch if needed
                        work(view, options.scope, notification);
                    }
                    activeTemplate = templateName;
                }, { ngZone }
                // we don't need to specify any scope here. The template manager is the only one
                // who will call `viewRef#detectChanges` on any of the templates it manages.
                // whenever a new value comes in, any pre-scheduled work of this taskManager will
                // be nooped before a new work will be scheduled. This happens because of the implementation
                // of `StrategyCredential#behavior`
                ).pipe(notifyAllParentsIfNeeded(injectingViewCdRef, strategy, () => notifyParent, ngZone), catchError((e) => {
                    errorHandler.handleError(e);
                    return of(e);
                }));
            }));
        },
    };
}
//# sourceMappingURL=template-manager.js.map