{"version":3,"file":"create-template-notifier.js","sourceRoot":"","sources":["../../../../../../libs/cdk/notifications/src/lib/create-template-notifier.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  from,\n  isObservable,\n  NEVER,\n  Observable,\n  ObservableInput,\n  ReplaySubject,\n} from 'rxjs';\nimport {\n  distinctUntilChanged,\n  map,\n  startWith,\n  switchMap,\n  tap,\n} from 'rxjs/operators';\n\nimport { rxMaterialize } from './rx-materialize';\nimport { RxNotification, RxNotificationKind } from './model';\nimport { toRxSuspenseNotification } from './notification-transforms';\n\n/**\n * @description\n * Sends value and an initial `undefined` as value With a NEVER.\n * This is needed to render the suspense template and avoid completing (and render the complete template).\n * @param value\n */\nconst emitAndDontComplete = (value) => NEVER.pipe(startWith(value));\n\n/**\n * This helper is responsible for turning a stream of materialized notifications\n * (next error, complete as object in the next stream) into an enriched version with an additional suspense\n * notification type.\n *\n * If a notification enters and is of type next we store tne value of `notification.next` as last value emitted.\n * This value is important in the template to show an e.g. error and also have access to the last emitted value of\n * next.\n * The value can be very useful in error or complete messages or to display the old value overlays by a loading spinner\n * in case of the suspense state.\n *\n * If a notification of kind `next` enters and its value is undefined we turn it into a suspense notification\n * If a notification of kind `error`, `complete`, `suspense` enters we take the last value from of a next notification\n * and assign it as new value to the notification\n */\nconst handleSuspenseAndLastValueInNotifications = <T>() => {\n  // Used to store the last value per handleSuspenseAndLastValueInNotifications call\n  let latestNextValue: T;\n\n  // returns a projection function with a lastValue cache\n  return (notification: RxNotification<T>): RxNotification<T> => {\n    // if it is the notification is of type next we take its value\n    // otherwise we keep the existing last value\n    if (notification.kind === RxNotificationKind.Next) {\n      latestNextValue = notification.value;\n    }\n\n    // If a next notification enters with a value of undefined we turn it into a suspense notification\n    if (\n      notification.kind === RxNotificationKind.Next &&\n      notification.value === undefined\n    ) {\n      return toRxSuspenseNotification(undefined) as RxNotification<T>;\n    }\n\n    // If a Notification of type error, complete or suspense enters we assign the latest last value to them.\n    // This is needed to access the old value in case of error or complete.\n    // Next notifications will pass as they are.\n    if (\n      notification.kind === RxNotificationKind.Error ||\n      notification.kind === RxNotificationKind.Complete ||\n      notification.kind === RxNotificationKind.Suspense\n    ) {\n      notification.value = latestNextValue;\n    }\n\n    return notification as RxNotification<T>;\n  };\n};\n\n/**\n * @internal\n *\n * @description\n * This factory function returns an object that can be driven imperatively over a `next` method.\n * Internally it prepares the incoming values for rendering by turning them into \"template notifications\",\n * an extended `ObservableNotification` object used to determine the respective template for values, errors, completing\n *   or suspense states.\n *\n * Internally it handles different edge cases for initial emits. This helps to have or template creation lazy.\n * Also it maps any Observable to RxNotifications. These notifications are bound to the view later and handle the\n *   display of the default template as well as the suspense, error, complete templates.\n */\nexport function createTemplateNotifier<U>(): {\n  values$: Observable<RxNotification<U>>;\n  next(observable: ObservableInput<U> | U): void;\n  withInitialSuspense(withInitialSuspense: boolean): void;\n} {\n  // A Subject driven from the outside, it can contain Observables, static values null and undefined on purpose of from unassigned properties\n  const observablesSubject = new ReplaySubject<ObservableInput<U> | U>(1);\n\n  let emittedValueOnce = false;\n\n  const values$ = observablesSubject.pipe(\n    distinctUntilChanged(),\n    // handle static values inc null assignment and new Observable or Promises\n    map((observable$): ObservableInput<U> | U => {\n      if (isObservableInput(observable$)) {\n        return skipSuspenseIfHasValue(observable$);\n      } else if (!emittedValueOnce && observable$ === undefined) {\n        return NEVER;\n      }\n      return emitAndDontComplete(observable$);\n    }),\n    switchMap((o: Observable<U>) => {\n      return o.pipe(\n        tap(() => (emittedValueOnce = true)),\n        distinctUntilChanged(),\n        rxMaterialize(),\n        map(handleSuspenseAndLastValueInNotifications<U>())\n      );\n    })\n  );\n\n  return {\n    next(observable: ObservableInput<U> | U) {\n      observablesSubject.next(observable);\n    },\n    withInitialSuspense(withInitialSuspense: boolean) {\n      emittedValueOnce = emittedValueOnce || withInitialSuspense;\n    },\n    values$,\n  };\n\n  /**\n   * @description\n   * returns an observable that starts with an undefined value in case the input\n   * observable$ does not emit a value immediately.\n   * This is needed in order to skip the suspense template when we already know\n   * there will be a next template rendered afterwards\n   * @param observable$\n   */\n  function skipSuspenseIfHasValue<T>(\n    observable$: ObservableInput<T>\n  ): Observable<T> {\n    return new Observable((subscriber) => {\n      let startWithUndefined = true;\n      const inner = from(observable$).subscribe({\n        next: (v) => {\n          startWithUndefined = false;\n          subscriber.next(v);\n        },\n        error: (e) => {\n          startWithUndefined = false;\n          subscriber.error(e);\n        },\n        complete: () => subscriber.complete(),\n      });\n      if (emittedValueOnce && startWithUndefined) {\n        subscriber.next(undefined);\n      }\n      return () => {\n        inner.unsubscribe();\n      };\n    });\n  }\n}\n\nfunction isObservableInput<T>(input: unknown): input is ObservableInput<T> {\n  return (\n    typeof (input as Promise<T>)?.then === 'function' || isObservable(input)\n  );\n}\n"]}