(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core')) :
    typeof define === 'function' && define.amd ? define('@rx-angular/cdk/internals/scheduler', ['exports', '@angular/core'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global['rx-angular'] = global['rx-angular'] || {}, global['rx-angular'].cdk = global['rx-angular'].cdk || {}, global['rx-angular'].cdk.internals = global['rx-angular'].cdk.internals || {}, global['rx-angular'].cdk.internals.scheduler = {}), global.ng.core));
}(this, (function (exports, core) { 'use strict';

    function push(heap, node) {
        var index = heap.length;
        heap.push(node);
        siftUp(heap, node, index);
    }
    function peek(heap) {
        var first = heap[0];
        return first === undefined ? null : first;
    }
    function pop(heap) {
        var first = heap[0];
        if (first !== undefined) {
            var last = heap.pop();
            if (last !== first) {
                heap[0] = last;
                siftDown(heap, last, 0);
            }
            return first;
        }
        else {
            return null;
        }
    }
    function siftUp(heap, node, i) {
        var index = i;
        // eslint-disable-next-line no-constant-condition
        while (true) {
            var parentIndex = (index - 1) >>> 1;
            var parent = heap[parentIndex];
            if (parent !== undefined && compare(parent, node) > 0) {
                // The parent is larger. Swap positions.
                heap[parentIndex] = node;
                heap[index] = parent;
                index = parentIndex;
            }
            else {
                // The parent is smaller. Exit.
                return;
            }
        }
    }
    function siftDown(heap, node, i) {
        var index = i;
        var length = heap.length;
        while (index < length) {
            var leftIndex = (index + 1) * 2 - 1;
            var left = heap[leftIndex];
            var rightIndex = leftIndex + 1;
            var right = heap[rightIndex];
            // If the left or right node is smaller, swap with the smaller of those.
            if (left !== undefined && compare(left, node) < 0) {
                if (right !== undefined && compare(right, left) < 0) {
                    heap[index] = right;
                    heap[rightIndex] = node;
                    index = rightIndex;
                }
                else {
                    heap[index] = left;
                    heap[leftIndex] = node;
                    index = leftIndex;
                }
            }
            else if (right !== undefined && compare(right, node) < 0) {
                heap[index] = right;
                heap[rightIndex] = node;
                index = rightIndex;
            }
            else {
                // Neither child is smaller. Exit.
                return;
            }
        }
    }
    function compare(a, b) {
        // Compare sort index first, then task id.
        var diff = a.sortIndex - b.sortIndex;
        return diff !== 0 ? diff : a.id - b.id;
    }

    // see https://github.com/facebook/react/blob/main/packages/scheduler/src/forks/Scheduler.js
    var getCurrentTime;
    var hasPerformanceNow = typeof core.ɵglobal.performance === 'object' && typeof core.ɵglobal.performance.now === 'function';
    if (hasPerformanceNow) {
        var localPerformance_1 = core.ɵglobal.performance;
        getCurrentTime = function () { return localPerformance_1.now(); };
    }
    else {
        var localDate_1 = Date;
        var initialTime_1 = localDate_1.now();
        getCurrentTime = function () { return localDate_1.now() - initialTime_1; };
    }
    // Max 31 bit integer. The max integer size in V8 for 32-bit systems.
    // Math.pow(2, 30) - 1
    // 0b111111111111111111111111111111
    var maxSigned31BitInt = 1073741823;
    // Times out immediately
    var IMMEDIATE_PRIORITY_TIMEOUT = -1;
    // Eventually times out
    var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
    var NORMAL_PRIORITY_TIMEOUT = 5000;
    var LOW_PRIORITY_TIMEOUT = 10000;
    // Never times out
    var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;
    // Tasks are stored on a min heap
    var taskQueue = [];
    var timerQueue = [];
    // Incrementing id counter. Used to maintain insertion order.
    var taskIdCounter = 1;
    // Pausing the scheduler is useful for debugging.
    var isSchedulerPaused = false;
    var currentTask = null;
    var currentPriorityLevel = 3 /* NormalPriority */;
    // This is set while performing work, to prevent re-entrancy.
    var isPerformingWork = false;
    var isHostCallbackScheduled = false;
    var isHostTimeoutScheduled = false;
    // Capture local references to native APIs, in case a polyfill overrides them.
    var setTimeout = core.ɵglobal.setTimeout;
    var clearTimeout = core.ɵglobal.clearTimeout;
    var setImmediate = core.ɵglobal.setImmediate; // IE and Node.js + jsdom
    var messageChannel = core.ɵglobal.MessageChannel;
    var isInputPending = typeof core.ɵglobal.navigator !== 'undefined' &&
        core.ɵglobal.navigator.scheduling !== undefined &&
        core.ɵglobal.navigator.scheduling.isInputPending !== undefined
        ? core.ɵglobal.navigator.scheduling.isInputPending.bind(core.ɵglobal.navigator.scheduling)
        : null;
    var defaultZone = {
        run: function (fn) { return fn(); }
    };
    function advanceTimers(currentTime) {
        // Check for tasks that are no longer delayed and add them to the queue.
        var timer = peek(timerQueue);
        while (timer !== null) {
            if (timer.callback === null) {
                // Timer was cancelled.
                pop(timerQueue);
            }
            else if (timer.startTime <= currentTime) {
                // Timer fired. Transfer to the task queue.
                pop(timerQueue);
                timer.sortIndex = timer.expirationTime;
                push(taskQueue, timer);
            }
            else {
                // Remaining timers are pending.
                return;
            }
            timer = peek(timerQueue);
        }
    }
    function handleTimeout(currentTime) {
        isHostTimeoutScheduled = false;
        advanceTimers(currentTime);
        if (!isHostCallbackScheduled) {
            if (peek(taskQueue) !== null) {
                isHostCallbackScheduled = true;
                requestHostCallback(flushWork);
            }
            else {
                var firstTimer = peek(timerQueue);
                if (firstTimer !== null) {
                    requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                }
            }
        }
    }
    function flushWork(hasTimeRemaining, initialTime) {
        // We'll need a host callback the next time work is scheduled.
        isHostCallbackScheduled = false;
        if (isHostTimeoutScheduled) {
            // We scheduled a timeout but it's no longer needed. Cancel it.
            isHostTimeoutScheduled = false;
            cancelHostTimeout();
        }
        isPerformingWork = true;
        var previousPriorityLevel = currentPriorityLevel;
        try {
            return workLoop(hasTimeRemaining, initialTime);
        }
        finally {
            currentTask = null;
            currentPriorityLevel = previousPriorityLevel;
            isPerformingWork = false;
        }
    }
    function workLoop(hasTimeRemaining, initialTime, _currentTask) {
        var currentTime = initialTime;
        if (_currentTask) {
            currentTask = _currentTask;
        }
        else {
            advanceTimers(currentTime);
            currentTask = peek(taskQueue);
        }
        var zoneChanged = false;
        var hitDeadline = function () { return currentTask && currentTask.expirationTime > currentTime &&
            (!hasTimeRemaining || shouldYieldToHost()); };
        if (!hitDeadline()) {
            var ngZone_1 = currentTask.ngZone || defaultZone;
            ngZone_1.run(function () {
                while (currentTask !== null && !zoneChanged) {
                    if (hitDeadline()) {
                        break;
                    }
                    var callback = currentTask.callback;
                    if (typeof callback === 'function') {
                        currentTask.callback = null;
                        currentPriorityLevel = currentTask.priorityLevel;
                        var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
                        var continuationCallback = callback(didUserCallbackTimeout);
                        currentTime = getCurrentTime();
                        if (typeof continuationCallback === 'function') {
                            currentTask.callback = continuationCallback;
                        }
                        else {
                            if (currentTask === peek(taskQueue)) {
                                pop(taskQueue);
                            }
                        }
                        advanceTimers(currentTime);
                    }
                    else {
                        pop(taskQueue);
                    }
                    currentTask = peek(taskQueue);
                    zoneChanged = (currentTask === null || currentTask === void 0 ? void 0 : currentTask.ngZone) != null && currentTask.ngZone !== ngZone_1;
                }
            });
        }
        if (zoneChanged) {
            return workLoop(hasTimeRemaining, currentTime, currentTask);
        }
        // Return whether there's additional work
        if (currentTask !== null) {
            return true;
        }
        else {
            var firstTimer = peek(timerQueue);
            if (firstTimer !== null) {
                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
            }
            return false;
        }
    }
    function runWithPriority(priorityLevel, eventHandler) {
        switch (priorityLevel) {
            case 1 /* ImmediatePriority */:
            case 2 /* UserBlockingPriority */:
            case 3 /* NormalPriority */:
            case 4 /* LowPriority */:
            case 5 /* IdlePriority */:
                break;
            default:
                priorityLevel = 3 /* NormalPriority */;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
            return eventHandler();
        }
        finally {
            currentPriorityLevel = previousPriorityLevel;
        }
    }
    function next(eventHandler) {
        var priorityLevel;
        switch (currentPriorityLevel) {
            case 1 /* ImmediatePriority */:
            case 2 /* UserBlockingPriority */:
            case 3 /* NormalPriority */:
                // Shift down to normal priority
                priorityLevel = 3 /* NormalPriority */;
                break;
            default:
                // Anything lower than normal priority should remain at the current level.
                priorityLevel = currentPriorityLevel;
                break;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
            return eventHandler();
        }
        finally {
            currentPriorityLevel = previousPriorityLevel;
        }
    }
    function wrapCallback(callback) {
        var _this = this;
        var parentPriorityLevel = currentPriorityLevel;
        return function () {
            // This is a fork of runWithPriority, inlined for performance.
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
                // eslint-disable-next-line prefer-rest-params
                return callback.apply(_this, arguments);
            }
            finally {
                currentPriorityLevel = previousPriorityLevel;
            }
        };
    }
    function scheduleCallback(priorityLevel, callback, options) {
        var currentTime = getCurrentTime();
        var startTime;
        if (typeof options === 'object' && options !== null) {
            var delay = options.delay;
            if (typeof delay === 'number' && delay > 0) {
                startTime = currentTime + delay;
            }
            else {
                startTime = currentTime;
            }
        }
        else {
            startTime = currentTime;
        }
        var timeout;
        switch (priorityLevel) {
            case 1 /* ImmediatePriority */:
                timeout = IMMEDIATE_PRIORITY_TIMEOUT;
                break;
            case 2 /* UserBlockingPriority */:
                timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
                break;
            case 5 /* IdlePriority */:
                timeout = IDLE_PRIORITY_TIMEOUT;
                break;
            case 4 /* LowPriority */:
                timeout = LOW_PRIORITY_TIMEOUT;
                break;
            case 3 /* NormalPriority */:
            default:
                timeout = NORMAL_PRIORITY_TIMEOUT;
                break;
        }
        var expirationTime = startTime + timeout;
        var newTask = {
            id: taskIdCounter++,
            callback: callback,
            priorityLevel: priorityLevel,
            startTime: startTime,
            expirationTime: expirationTime,
            sortIndex: -1,
            ngZone: (options === null || options === void 0 ? void 0 : options.ngZone) || null
        };
        if (startTime > currentTime) {
            // This is a delayed task.
            newTask.sortIndex = startTime;
            push(timerQueue, newTask);
            if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
                // All tasks are delayed, and this is the task with the earliest delay.
                if (isHostTimeoutScheduled) {
                    // Cancel an existing timeout.
                    cancelHostTimeout();
                }
                else {
                    isHostTimeoutScheduled = true;
                }
                // Schedule a timeout.
                requestHostTimeout(handleTimeout, startTime - currentTime);
            }
        }
        else {
            newTask.sortIndex = expirationTime;
            push(taskQueue, newTask);
            // Schedule a host callback, if needed. If we're already performing work,
            // wait until the next time we yield.
            if (!isHostCallbackScheduled && !isPerformingWork) {
                isHostCallbackScheduled = true;
                requestHostCallback(flushWork);
            }
        }
        return newTask;
    }
    function pauseExecution() {
        isSchedulerPaused = true;
    }
    function continueExecution() {
        isSchedulerPaused = false;
        if (!isHostCallbackScheduled && !isPerformingWork) {
            isHostCallbackScheduled = true;
            requestHostCallback(flushWork);
        }
    }
    function getFirstCallbackNode() {
        return peek(taskQueue);
    }
    function cancelCallback(task) {
        // Null out the callback to indicate the task has been canceled. (Can't
        // remove from the queue because you can't remove arbitrary nodes from an
        // array based heap, only the first one.)
        task.callback = null;
    }
    function getCurrentPriorityLevel() {
        return currentPriorityLevel;
    }
    var isMessageLoopRunning = false;
    var scheduledHostCallback = null;
    var taskTimeoutID = -1;
    // Scheduler periodically yields in case there is other work on the main
    // thread, like user events. By default, it yields multiple times per frame.
    // It does not attempt to align with frame boundaries, since most tasks don't
    // need to be frame aligned; for those that do, use requestAnimationFrame.
    var yieldInterval = 16;
    // TODO: Make this configurable
    // TODO: Adjust this based on priority?
    var maxYieldInterval = 300;
    var needsPaint = false;
    var queueStartTime = -1;
    function shouldYieldToHost() {
        if (needsPaint) {
            // There's a pending paint (signaled by `requestPaint`). Yield now.
            return true;
        }
        var timeElapsed = getCurrentTime() - queueStartTime;
        if (timeElapsed < yieldInterval) {
            // The main thread has only been blocked for a really short amount of time;
            // smaller than a single frame. Don't yield yet.
            return false;
        }
        // The main thread has been blocked for a non-negligible amount of time. We
        // may want to yield control of the main thread, so the browser can perform
        // high priority tasks. The main ones are painting and user input. If there's
        // a pending paint or a pending input, then we should yield. But if there's
        // neither, then we can yield less often while remaining responsive. We'll
        // eventually yield regardless, since there could be a pending paint that
        // wasn't accompanied by a call to `requestPaint`, or other main thread tasks
        // like network events.
        // we don't support isInputPending currently
        /*if (enableIsInputPending) {
          if (needsPaint) {
            // There's a pending paint (signaled by `requestPaint`). Yield now.
            return true;
          }
          if (timeElapsed < continuousInputInterval) {
            // We haven't blocked the thread for that long. Only yield if there's a
            // pending discrete input (e.g. click). It's OK if there's pending
            // continuous input (e.g. mouseover).
            if (isInputPending !== null) {
              return isInputPending();
            }
          } else if (timeElapsed < maxInterval) {
            // Yield if there's either a pending discrete or continuous input.
            if (isInputPending !== null) {
              return isInputPending(continuousOptions);
            }
          } else {
            // We've blocked the thread for a long time. Even if there's no pending
            // input, there may be some other scheduled work that we don't know about,
            // like a network event. Yield now.
            return true;
          }
        }*/
        // `isInputPending` isn't available. Yield now.
        return true;
    }
    function requestPaint() {
        needsPaint = true;
        // we don't support isInputPending currently
        /*if (
          enableIsInputPending &&
          navigator !== undefined &&
          (navigator as any).scheduling !== undefined &&
          (navigator as any).scheduling.isInputPending !== undefined
        ) {
          needsPaint = true;
        }*/
    }
    function forceFrameRate(fps) {
        if (fps < 0 || fps > 125) {
            if (typeof ngDevMode === 'undefined' || ngDevMode) {
                console.error('forceFrameRate takes a positive int between 0 and 125, ' +
                    'forcing frame rates higher than 125 fps is not supported');
            }
            return;
        }
        if (fps > 0) {
            yieldInterval = Math.floor(1000 / fps);
        }
        else {
            // reset the framerate
            yieldInterval = 5;
        }
        // be aware of browser housekeeping work (~6ms per frame)
        // according to https://developers.google.com/web/fundamentals/performance/rendering
        yieldInterval = Math.max(5, yieldInterval - 6);
    }
    var performWorkUntilDeadline = function () {
        if (scheduledHostCallback !== null) {
            var currentTime = getCurrentTime();
            // Yield after `yieldInterval` ms, regardless of where we are in the vsync
            // cycle. This means there's always time remaining at the beginning of
            // the message event.
            queueStartTime = currentTime;
            var hasTimeRemaining = true;
            // If a scheduler task throws, exit the current browser task so the
            // error can be observed.
            //
            // Intentionally not using a try-catch, since that makes some debugging
            // techniques harder. Instead, if `scheduledHostCallback` errors, then
            // `hasMoreWork` will remain true, and we'll continue the work loop.
            var hasMoreWork = true;
            try {
                hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
            }
            finally {
                if (hasMoreWork) {
                    // If there's more work, schedule the next message event at the end
                    // of the preceding one.
                    schedulePerformWorkUntilDeadline();
                }
                else {
                    isMessageLoopRunning = false;
                    scheduledHostCallback = null;
                }
            }
        }
        else {
            isMessageLoopRunning = false;
        }
        // Yielding to the browser will give it a chance to paint, so we can
        // reset this.
        needsPaint = false;
    };
    var schedulePerformWorkUntilDeadline;
    if (typeof setImmediate === 'function') {
        // Node.js and old IE.
        // There's a few reasons for why we prefer setImmediate.
        //
        // Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.
        // (Even though this is a DOM fork of the Scheduler, you could get here
        // with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)
        // https://github.com/facebook/react/issues/20756
        //
        // But also, it runs earlier which is the semantic we want.
        // If other browsers ever implement it, it's better to use it.
        // Although both of these would be inferior to native scheduling.
        schedulePerformWorkUntilDeadline = function () {
            setImmediate(performWorkUntilDeadline);
        };
    }
    else if (typeof messageChannel !== 'undefined') {
        var channel = new messageChannel();
        var port_1 = channel.port2;
        channel.port1.onmessage = performWorkUntilDeadline;
        schedulePerformWorkUntilDeadline = function () {
            port_1.postMessage(null);
        };
    }
    else {
        // We should only fallback here in non-browser environments.
        schedulePerformWorkUntilDeadline = function () {
            setTimeout(performWorkUntilDeadline, 0);
        };
    }
    function requestHostCallback(callback) {
        scheduledHostCallback = callback;
        if (!isMessageLoopRunning) {
            isMessageLoopRunning = true;
            schedulePerformWorkUntilDeadline();
        }
    }
    function requestHostTimeout(callback, ms) {
        taskTimeoutID = setTimeout(function () {
            callback(getCurrentTime());
        }, ms);
    }
    function cancelHostTimeout() {
        clearTimeout(taskTimeoutID);
        taskTimeoutID = -1;
    }
    var _requestPaint = requestPaint;

    /**
     * Generated bundle index. Do not edit.
     */

    exports.cancelCallback = cancelCallback;
    exports.forceFrameRate = forceFrameRate;
    exports.scheduleCallback = scheduleCallback;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=cdk-internals-scheduler.umd.js.map
