(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rxjs'), require('rxjs/operators'), require('@rx-angular/cdk/coercing')) :
    typeof define === 'function' && define.amd ? define('@rx-angular/cdk/notifications', ['exports', 'rxjs', 'rxjs/operators', '@rx-angular/cdk/coercing'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global['rx-angular'] = global['rx-angular'] || {}, global['rx-angular'].cdk = global['rx-angular'].cdk || {}, global['rx-angular'].cdk.notifications = {}), global.rxjs, global.rxjs.operators, global['rx-angular'].cdk.coercing));
}(this, (function (exports, rxjs, operators, coercing) { 'use strict';

    function toRxErrorNotification(error, value) {
        return {
            value: value,
            kind: "error" /* Error */,
            hasValue: !!value || false,
            complete: false,
            error: error || true,
        };
    }
    function toRxSuspenseNotification(value) {
        return {
            value: value,
            kind: "suspense" /* Suspense */,
            hasValue: !!value || false,
            complete: false,
            error: false,
        };
    }
    function toRxCompleteNotification(value) {
        return {
            value: value,
            kind: "complete" /* Complete */,
            hasValue: !!value || false,
            complete: true,
            error: false,
        };
    }

    /**
     * @internal
     *
     * A factory function returning an object to handle the process of switching templates by Notification channel.
     * You can next a Observable of `RxNotification` multiple times and merge them into the Observable exposed under `trigger$`
     *
     */
    function templateTriggerHandling() {
        var hotFlattened = coercing.coerceAllFactory(function () { return new rxjs.Subject(); }, operators.mergeAll());
        return {
            next: function (templateName) {
                hotFlattened.next(templateName);
            },
            trigger$: hotFlattened.values$.pipe(operators.share()),
        };
    }

    function rxMaterialize() {
        return function (o$) { return o$.pipe(operators.materialize(), operators.tap(function (_a) {
            var kind = _a.kind, error = _a.error;
            // As we dont want to just swallow errors we log them here
            if (kind === 'E') {
                console.error(error);
            }
        }), operators.map(function (_a) {
            var value = _a.value, error = _a.error, kind = _a.kind, hasValue = _a.hasValue;
            var rxNotificationKind = notificationKindToRxNotificationKind(kind);
            return {
                value: value,
                hasValue: hasValue,
                error: error,
                kind: rxNotificationKind,
                complete: rxNotificationKind === "complete" /* Complete */,
            };
        })); };
    }
    /**
     * @internal
     *
     * @description
     * This function is here to turn RxJS notification kind values into RxNotification kind names.
     * The main reason for the naming is the RxNotification kind values map directly to the default
     * template names (`suspense`, `next`, `error` `complete`) in the directives of the template package
     */
    function notificationKindToRxNotificationKind(kind) {
        switch (kind) {
            case 'C':
                return "complete" /* Complete */;
            case 'E':
                return "error" /* Error */;
            case 'N':
            default:
                return "next" /* Next */;
        }
    }

    /**
     * @description
     * Sends value and an initial `undefined` as value With a NEVER.
     * This is needed to render the suspense template and avoid completing (and render the complete template).
     * @param value
     */
    var emitAndDontComplete = function (value) { return rxjs.NEVER.pipe(operators.startWith(value)); };
    /**
     * This helper is responsible for turning a stream of materialized notifications
     * (next error, complete as object in the next stream) into an enriched version with an additional suspense
     * notification type.
     *
     * If a notification enters and is of type next we store tne value of `notification.next` as last value emitted.
     * This value is important in the template to show an e.g. error and also have access to the last emitted value of
     * next.
     * The value can be very useful in error or complete messages or to display the old value overlays by a loading spinner
     * in case of the suspense state.
     *
     * If a notification of kind `next` enters and its value is undefined we turn it into a suspense notification
     * If a notification of kind `error`, `complete`, `suspense` enters we take the last value from of a next notification
     * and assign it as new value to the notification
     */
    var handleSuspenseAndLastValueInNotifications = function () {
        // Used to store the last value per handleSuspenseAndLastValueInNotifications call
        var latestNextValue;
        // returns a projection function with a lastValue cache
        return function (notification) {
            // if it is the notification is of type next we take its value
            // otherwise we keep the existing last value
            if (notification.kind === "next" /* Next */) {
                latestNextValue = notification.value;
            }
            // If a next notification enters with a value of undefined we turn it into a suspense notification
            if (notification.kind === "next" /* Next */ &&
                notification.value === undefined) {
                return toRxSuspenseNotification(undefined);
            }
            // If a Notification of type error, complete or suspense enters we assign the latest last value to them.
            // This is needed to access the old value in case of error or complete.
            // Next notifications will pass as they are.
            if (notification.kind === "error" /* Error */ ||
                notification.kind === "complete" /* Complete */ ||
                notification.kind === "suspense" /* Suspense */) {
                notification.value = latestNextValue;
            }
            return notification;
        };
    };
    /**
     * @internal
     *
     * @description
     * This factory function returns an object that can be driven imperatively over a `next` method.
     * Internally it prepares the incoming values for rendering by turning them into "template notifications",
     * an extended `ObservableNotification` object used to determine the respective template for values, errors, completing
     *   or suspense states.
     *
     * Internally it handles different edge cases for initial emits. This helps to have or template creation lazy.
     * Also it maps any Observable to RxNotifications. These notifications are bound to the view later and handle the
     *   display of the default template as well as the suspense, error, complete templates.
     */
    function createTemplateNotifier() {
        // A Subject driven from the outside, it can contain Observables, static values null and undefined on purpose of from unassigned properties
        var observablesSubject = new rxjs.ReplaySubject(1);
        var emittedValueOnce = false;
        var values$ = observablesSubject.pipe(operators.distinctUntilChanged(), 
        // handle static values inc null assignment and new Observable or Promises
        operators.map(function (observable$) {
            if (isObservableInput(observable$)) {
                return skipSuspenseIfHasValue(observable$);
            }
            else if (!emittedValueOnce && observable$ === undefined) {
                return rxjs.NEVER;
            }
            return emitAndDontComplete(observable$);
        }), operators.switchMap(function (o) {
            return o.pipe(operators.tap(function () { return (emittedValueOnce = true); }), operators.distinctUntilChanged(), rxMaterialize(), operators.map(handleSuspenseAndLastValueInNotifications()));
        }));
        return {
            next: function (observable) {
                observablesSubject.next(observable);
            },
            withInitialSuspense: function (withInitialSuspense) {
                emittedValueOnce = emittedValueOnce || withInitialSuspense;
            },
            values$: values$,
        };
        /**
         * @description
         * returns an observable that starts with an undefined value in case the input
         * observable$ does not emit a value immediately.
         * This is needed in order to skip the suspense template when we already know
         * there will be a next template rendered afterwards
         * @param observable$
         */
        function skipSuspenseIfHasValue(observable$) {
            return new rxjs.Observable(function (subscriber) {
                var startWithUndefined = true;
                var inner = rxjs.from(observable$).subscribe({
                    next: function (v) {
                        startWithUndefined = false;
                        subscriber.next(v);
                    },
                    error: function (e) {
                        startWithUndefined = false;
                        subscriber.error(e);
                    },
                    complete: function () { return subscriber.complete(); },
                });
                if (emittedValueOnce && startWithUndefined) {
                    subscriber.next(undefined);
                }
                return function () {
                    inner.unsubscribe();
                };
            });
        }
    }
    function isObservableInput(input) {
        var _a;
        return (typeof ((_a = input) === null || _a === void 0 ? void 0 : _a.then) === 'function' || rxjs.isObservable(input));
    }

    /**
     * Generated bundle index. Do not edit.
     */

    exports.createTemplateNotifier = createTemplateNotifier;
    exports.rxMaterialize = rxMaterialize;
    exports.templateTriggerHandling = templateTriggerHandling;
    exports.toRxCompleteNotification = toRxCompleteNotification;
    exports.toRxErrorNotification = toRxErrorNotification;
    exports.toRxSuspenseNotification = toRxSuspenseNotification;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=cdk-notifications.umd.js.map
