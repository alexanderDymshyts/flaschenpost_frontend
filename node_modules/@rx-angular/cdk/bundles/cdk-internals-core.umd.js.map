{"version":3,"file":"cdk-internals-core.umd.js","sources":["../../../../libs/cdk/internals/core/src/lib/get-zone-unpatched-api.ts","../../../../libs/cdk/internals/core/src/lib/timeout.ts","../../../../libs/cdk/internals/core/src/lib/accumulateObservables.ts","../../../../libs/cdk/internals/core/src/cdk-internals-core.ts"],"sourcesContent":["import { ɵglobal } from '@angular/core';\n\n/**\n * @description\n *\n * This function returns the zone un-patched API for the a specific Browser API.\n * If no target is passed the window is used instead\n *\n * @param name - The name of the API to check.\n * @param target - The target to get un-patched API from.\n * @return {Function} - The zone un-patched API in question.\n *\n */\nexport function getZoneUnPatchedApi<\n  N extends keyof (Window & typeof globalThis)\n>(name: N): (Window & typeof globalThis)[N];\n\nexport function getZoneUnPatchedApi<T extends object, N extends keyof T>(\n  target: T,\n  name: N\n): T[N];\n\nexport function getZoneUnPatchedApi<T extends object, N extends keyof T>(\n  targetOrName: T | string,\n  name?: N\n) {\n  // If the user has provided the API name as the first argument, for instance:\n  // `const addEventListener = getZoneUnPatchedApi('addEventListener');`\n  // Then we just swap arguments and make `global` or `window` as the default target.\n  if (typeof targetOrName === 'string') {\n    name = targetOrName as N;\n    targetOrName = ɵglobal as T;\n  }\n  return targetOrName['__zone_symbol__' + name] || targetOrName[name];\n}\n","import { Observable, Subscriber } from 'rxjs';\nimport { mapTo, concatMap } from 'rxjs/operators';\nimport { getZoneUnPatchedApi } from './get-zone-unpatched-api';\n\n/**\n * Creates an Observable that emits after a setTimeout.\n * The timeout it unpatched to not avoid zone pollution\n * @param setTimeoutFn\n */\nfunction timeout(\n  delay: number = 0\n) {\n  return new Observable<number>((subscriber: Subscriber<number>) => {\n    const asyncID = getZoneUnPatchedApi('setTimeout')(() => subscriber.next(0), delay);\n    return () => {\n      getZoneUnPatchedApi('clearTimeout')(asyncID);\n    };\n  });\n}\n\n/**\n *\n */\nexport function timeoutSwitchMapWith<T>() {\n  return (o$: Observable<T>) => o$.pipe(\n    concatMap((v) => timeout().pipe(mapTo(v)))\n  )\n}\n","import { coalesceWith } from '@rx-angular/cdk/coalescing';\nimport { combineLatest, from, Observable } from 'rxjs';\nimport { distinctUntilChanged, filter, map, shareReplay } from 'rxjs/operators';\nimport {\n  ArrayReducerFn,\n  ExtractObservableValue,\n  NotEmpty,\n  ObservableMap,\n  PropName,\n  PropType,\n} from './model';\nimport { getZoneUnPatchedApi } from './get-zone-unpatched-api';\n\nconst resolvedPromise = getZoneUnPatchedApi('Promise').resolve();\nconst resolvedPromise$ = from(resolvedPromise);\n\n/**\n * @internal\n *\n * Used for typing\n */\nfunction getEntriesToObjectReducerFn<T extends Record<string, any>>(\n  keys: PropName<T>[]\n): ArrayReducerFn<T> {\n  return (\n    accumulator: T,\n    currentValue?: PropType<T>,\n    currentIndex?: number\n  ): T => {\n    return {\n      ...accumulator,\n      [keys[currentIndex]]: currentValue,\n    };\n  };\n}\n\n/**\n * This Observable creation function helps to accumulate an object of key & Observable of values to\n * an Observable of objects of key & value.\n * This comes in handy if you quickly want to create subsets as objects/state-slices of different Observables.\n *\n * The resulting Observable filters out undefined values forwards only distinct values and shared the aggregated output.\n *\n * @example\n *\n * Default usage:\n *\n * const object$: Observable<{\n *   prop1: number,\n *   prop2: string,\n *   prop3: string\n * }> = accumulateObservables({\n *   prop1: interval(42),\n *   prop2: of('lorem'),\n *   prop3: 'test'\n * });\n *\n * Usage with custom duration selector:\n *\n * const object$: Observable<{\n *   prop1: number,\n *   prop2: string,\n *   prop3: string\n * }> = accumulateObservables({\n *   prop1: interval(42),\n *   prop2: of('lorem'),\n *   prop3: 'test'\n * }, timer(0, 20));\n *\n * @param obj - An object of key & Observable values pairs\n * @param durationSelector - An Observable determining the duration for the internal coalescing method\n */\nexport function accumulateObservables<T extends ObservableMap & NotEmpty<T>>(\n  // @TODO type static or Observable to enable mixing of imperative and reatctive values\n  obj: T,\n  durationSelector: Observable<any> = resolvedPromise$\n): Observable<{ [K in keyof T]: ExtractObservableValue<T[K]> }> {\n  const keys = Object.keys(obj) as (keyof T)[];\n  // @TODO better typing to enable static values => coerceObservable(obj[key])\n  const observables = keys.map((key) =>\n    obj[key].pipe(\n      // we avoid using the nullish operator later ;)\n      filter((v) => v !== undefined),\n      // state \"changes\" differ from each other, this operator ensures distinct values\n      distinctUntilChanged()\n    )\n  );\n  return combineLatest(observables).pipe(\n    // As combineLatest will emit multiple times for a change in multiple properties we coalesce those emissions\n    // together\n    coalesceWith(durationSelector),\n    // mapping array of values to object\n    map((values) =>\n      values.reduce(getEntriesToObjectReducerFn(keys), {} as any)\n    ),\n    // by using shareReplay we share the last composition work done to create the accumulated object\n    shareReplay({refCount: true, bufferSize: 1})\n  );\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":["ɵglobal","Observable","concatMap","mapTo","from","filter","distinctUntilChanged","combineLatest","coalesceWith","map","shareReplay"],"mappings":";;;;;;aAsBgB,mBAAmB,CACjC,YAAwB,EACxB,IAAQ;;;;QAKR,IAAI,OAAO,YAAY,KAAK,QAAQ,EAAE;YACpC,IAAI,GAAG,YAAiB,CAAC;YACzB,YAAY,GAAGA,YAAY,CAAC;SAC7B;QACD,OAAO,YAAY,CAAC,iBAAiB,GAAG,IAAI,CAAC,IAAI,YAAY,CAAC,IAAI,CAAC,CAAC;IACtE;;IC9BA;;;;;IAKA,SAAS,OAAO,CACd,KAAiB;QAAjB,sBAAA,EAAA,SAAiB;QAEjB,OAAO,IAAIC,eAAU,CAAS,UAAC,UAA8B;YAC3D,IAAM,OAAO,GAAG,mBAAmB,CAAC,YAAY,CAAC,CAAC,cAAM,OAAA,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,GAAA,EAAE,KAAK,CAAC,CAAC;YACnF,OAAO;gBACL,mBAAmB,CAAC,cAAc,CAAC,CAAC,OAAO,CAAC,CAAC;aAC9C,CAAC;SACH,CAAC,CAAC;IACL,CAAC;IAED;;;aAGgB,oBAAoB;QAClC,OAAO,UAAC,EAAiB,IAAK,OAAA,EAAE,CAAC,IAAI,CACnCC,mBAAS,CAAC,UAAC,CAAC,IAAK,OAAA,OAAO,EAAE,CAAC,IAAI,CAACC,eAAK,CAAC,CAAC,CAAC,CAAC,GAAA,CAAC,CAC3C,GAAA,CAAA;IACH;;ICdA,IAAM,eAAe,GAAG,mBAAmB,CAAC,SAAS,CAAC,CAAC,OAAO,EAAE,CAAC;IACjE,IAAM,gBAAgB,GAAGC,SAAI,CAAC,eAAe,CAAC,CAAC;IAE/C;;;;;IAKA,SAAS,2BAA2B,CAClC,IAAmB;QAEnB,OAAO,UACL,WAAc,EACd,YAA0B,EAC1B,YAAqB;;YAErB,uCACK,WAAW,aACd,GAAC,IAAI,CAAC,YAAY,CAAC,IAAG,YAAY,OAClC;SACH,CAAC;IACJ,CAAC;IAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;aAoCgB,qBAAqB;IACnC;IACA,GAAM,EACN,gBAAoD;QAApD,iCAAA,EAAA,mCAAoD;QAEpD,IAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,CAAgB,CAAC;;QAE7C,IAAM,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,UAAC,GAAG,IAC/B,OAAA,GAAG,CAAC,GAAG,CAAC,CAAC,IAAI;;QAEXC,gBAAM,CAAC,UAAC,CAAC,IAAK,OAAA,CAAC,KAAK,SAAS,GAAA,CAAC;;QAE9BC,8BAAoB,EAAE,CACvB,GAAA,CACF,CAAC;QACF,OAAOC,kBAAa,CAAC,WAAW,CAAC,CAAC,IAAI;;;QAGpCC,uBAAY,CAAC,gBAAgB,CAAC;;QAE9BC,aAAG,CAAC,UAAC,MAAM,IACT,OAAA,MAAM,CAAC,MAAM,CAAC,2BAA2B,CAAC,IAAI,CAAC,EAAE,EAAS,CAAC,GAAA,CAC5D;;QAEDC,qBAAW,CAAC,EAAC,QAAQ,EAAE,IAAI,EAAE,UAAU,EAAE,CAAC,EAAC,CAAC,CAC7C,CAAC;IACJ;;IClGA;;;;;;;;;;;;;;"}