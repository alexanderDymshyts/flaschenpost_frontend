{"version":3,"file":"cdk-notifications.umd.js","sources":["../../../../libs/cdk/notifications/src/lib/notification-transforms.ts","../../../../libs/cdk/notifications/src/lib/template-trigger-handling.ts","../../../../libs/cdk/notifications/src/lib/rx-materialize.ts","../../../../libs/cdk/notifications/src/lib/create-template-notifier.ts","../../../../libs/cdk/notifications/src/cdk-notifications.ts"],"sourcesContent":["import {\n  RxSuspenseNotification,\n  RxNotificationKind,\n  RxErrorNotification,\n  RxCompleteNotification,\n} from './model';\n\nexport function toRxErrorNotification<T>(\n  error?: any,\n  value?: T\n): RxErrorNotification<T> {\n  return {\n    value,\n    kind: RxNotificationKind.Error,\n    hasValue: !!value || false,\n    complete: false,\n    error: error || true,\n  };\n}\n\nexport function toRxSuspenseNotification<T>(\n  value?: T\n): RxSuspenseNotification<T> {\n  return {\n    value,\n    kind: RxNotificationKind.Suspense,\n    hasValue: !!value || false,\n    complete: false,\n    error: false,\n  };\n}\n\nexport function toRxCompleteNotification<T>(\n  value?: T\n): RxCompleteNotification<T> {\n  return {\n    value,\n    kind: RxNotificationKind.Complete,\n    hasValue: !!value || false,\n    complete: true,\n    error: false,\n  };\n}\n","import { Observable, Subject } from 'rxjs';\nimport { mergeAll, share } from 'rxjs/operators';\n\nimport { coerceAllFactory } from '@rx-angular/cdk/coercing';\n\nimport { RxNotification } from './model';\n\n/**\n * @internal\n *\n * A factory function returning an object to handle the process of switching templates by Notification channel.\n * You can next a Observable of `RxNotification` multiple times and merge them into the Observable exposed under `trigger$`\n *\n */\nexport function templateTriggerHandling<T>(): {\n  trigger$: Observable<RxNotification<T>>;\n  next(templateName: Observable<RxNotification<T>>): void;\n} {\n  const hotFlattened = coerceAllFactory(\n    () => new Subject<Observable<RxNotification<T> | RxNotification<T>>>(),\n    mergeAll()\n  );\n  return {\n    next(templateName: Observable<RxNotification<T> | RxNotification<T>>) {\n      hotFlattened.next(templateName);\n    },\n    trigger$: hotFlattened.values$.pipe(share()),\n  };\n}\n","import { OperatorFunction, Notification } from 'rxjs';\nimport { map, materialize, tap } from 'rxjs/operators';\n\nimport { RxNotification, RxNotificationKind } from './model';\n\nexport function rxMaterialize<T>(): OperatorFunction<T, RxNotification<T>> {\n  return (o$) =>\n    o$.pipe(\n      materialize(),\n      tap(({ kind, error }) => {\n        // As we dont want to just swallow errors we log them here\n        if (kind === 'E') {\n          console.error(error);\n        }\n      }),\n      map(({ value, error, kind, hasValue }) => {\n        const rxNotificationKind = notificationKindToRxNotificationKind(kind);\n        return {\n          value,\n          hasValue,\n          error,\n          kind: rxNotificationKind,\n          complete: rxNotificationKind === RxNotificationKind.Complete,\n        };\n      })\n    );\n}\n\n/**\n * @internal\n *\n * @description\n * This function is here to turn RxJS notification kind values into RxNotification kind names.\n * The main reason for the naming is the RxNotification kind values map directly to the default\n * template names (`suspense`, `next`, `error` `complete`) in the directives of the template package\n */\nexport function notificationKindToRxNotificationKind(\n  kind: Notification<unknown>['kind']\n): RxNotificationKind {\n  switch (kind) {\n    case 'C':\n      return RxNotificationKind.Complete;\n    case 'E':\n      return RxNotificationKind.Error;\n    case 'N':\n    default:\n      return RxNotificationKind.Next;\n  }\n}\n","import {\n  from,\n  isObservable,\n  NEVER,\n  Observable,\n  ObservableInput,\n  ReplaySubject,\n} from 'rxjs';\nimport {\n  distinctUntilChanged,\n  map,\n  startWith,\n  switchMap,\n  tap,\n} from 'rxjs/operators';\n\nimport { rxMaterialize } from './rx-materialize';\nimport { RxNotification, RxNotificationKind } from './model';\nimport { toRxSuspenseNotification } from './notification-transforms';\n\n/**\n * @description\n * Sends value and an initial `undefined` as value With a NEVER.\n * This is needed to render the suspense template and avoid completing (and render the complete template).\n * @param value\n */\nconst emitAndDontComplete = (value) => NEVER.pipe(startWith(value));\n\n/**\n * This helper is responsible for turning a stream of materialized notifications\n * (next error, complete as object in the next stream) into an enriched version with an additional suspense\n * notification type.\n *\n * If a notification enters and is of type next we store tne value of `notification.next` as last value emitted.\n * This value is important in the template to show an e.g. error and also have access to the last emitted value of\n * next.\n * The value can be very useful in error or complete messages or to display the old value overlays by a loading spinner\n * in case of the suspense state.\n *\n * If a notification of kind `next` enters and its value is undefined we turn it into a suspense notification\n * If a notification of kind `error`, `complete`, `suspense` enters we take the last value from of a next notification\n * and assign it as new value to the notification\n */\nconst handleSuspenseAndLastValueInNotifications = <T>() => {\n  // Used to store the last value per handleSuspenseAndLastValueInNotifications call\n  let latestNextValue: T;\n\n  // returns a projection function with a lastValue cache\n  return (notification: RxNotification<T>): RxNotification<T> => {\n    // if it is the notification is of type next we take its value\n    // otherwise we keep the existing last value\n    if (notification.kind === RxNotificationKind.Next) {\n      latestNextValue = notification.value;\n    }\n\n    // If a next notification enters with a value of undefined we turn it into a suspense notification\n    if (\n      notification.kind === RxNotificationKind.Next &&\n      notification.value === undefined\n    ) {\n      return toRxSuspenseNotification(undefined) as RxNotification<T>;\n    }\n\n    // If a Notification of type error, complete or suspense enters we assign the latest last value to them.\n    // This is needed to access the old value in case of error or complete.\n    // Next notifications will pass as they are.\n    if (\n      notification.kind === RxNotificationKind.Error ||\n      notification.kind === RxNotificationKind.Complete ||\n      notification.kind === RxNotificationKind.Suspense\n    ) {\n      notification.value = latestNextValue;\n    }\n\n    return notification as RxNotification<T>;\n  };\n};\n\n/**\n * @internal\n *\n * @description\n * This factory function returns an object that can be driven imperatively over a `next` method.\n * Internally it prepares the incoming values for rendering by turning them into \"template notifications\",\n * an extended `ObservableNotification` object used to determine the respective template for values, errors, completing\n *   or suspense states.\n *\n * Internally it handles different edge cases for initial emits. This helps to have or template creation lazy.\n * Also it maps any Observable to RxNotifications. These notifications are bound to the view later and handle the\n *   display of the default template as well as the suspense, error, complete templates.\n */\nexport function createTemplateNotifier<U>(): {\n  values$: Observable<RxNotification<U>>;\n  next(observable: ObservableInput<U> | U): void;\n  withInitialSuspense(withInitialSuspense: boolean): void;\n} {\n  // A Subject driven from the outside, it can contain Observables, static values null and undefined on purpose of from unassigned properties\n  const observablesSubject = new ReplaySubject<ObservableInput<U> | U>(1);\n\n  let emittedValueOnce = false;\n\n  const values$ = observablesSubject.pipe(\n    distinctUntilChanged(),\n    // handle static values inc null assignment and new Observable or Promises\n    map((observable$): ObservableInput<U> | U => {\n      if (isObservableInput(observable$)) {\n        return skipSuspenseIfHasValue(observable$);\n      } else if (!emittedValueOnce && observable$ === undefined) {\n        return NEVER;\n      }\n      return emitAndDontComplete(observable$);\n    }),\n    switchMap((o: Observable<U>) => {\n      return o.pipe(\n        tap(() => (emittedValueOnce = true)),\n        distinctUntilChanged(),\n        rxMaterialize(),\n        map(handleSuspenseAndLastValueInNotifications<U>())\n      );\n    })\n  );\n\n  return {\n    next(observable: ObservableInput<U> | U) {\n      observablesSubject.next(observable);\n    },\n    withInitialSuspense(withInitialSuspense: boolean) {\n      emittedValueOnce = emittedValueOnce || withInitialSuspense;\n    },\n    values$,\n  };\n\n  /**\n   * @description\n   * returns an observable that starts with an undefined value in case the input\n   * observable$ does not emit a value immediately.\n   * This is needed in order to skip the suspense template when we already know\n   * there will be a next template rendered afterwards\n   * @param observable$\n   */\n  function skipSuspenseIfHasValue<T>(\n    observable$: ObservableInput<T>\n  ): Observable<T> {\n    return new Observable((subscriber) => {\n      let startWithUndefined = true;\n      const inner = from(observable$).subscribe({\n        next: (v) => {\n          startWithUndefined = false;\n          subscriber.next(v);\n        },\n        error: (e) => {\n          startWithUndefined = false;\n          subscriber.error(e);\n        },\n        complete: () => subscriber.complete(),\n      });\n      if (emittedValueOnce && startWithUndefined) {\n        subscriber.next(undefined);\n      }\n      return () => {\n        inner.unsubscribe();\n      };\n    });\n  }\n}\n\nfunction isObservableInput<T>(input: unknown): input is ObservableInput<T> {\n  return (\n    typeof (input as Promise<T>)?.then === 'function' || isObservable(input)\n  );\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":["coerceAllFactory","Subject","mergeAll","share","materialize","tap","map","NEVER","startWith","ReplaySubject","distinctUntilChanged","switchMap","Observable","from","isObservable"],"mappings":"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"}