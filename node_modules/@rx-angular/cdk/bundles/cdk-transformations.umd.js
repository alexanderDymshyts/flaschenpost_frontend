(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define('@rx-angular/cdk/transformations', ['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global['rx-angular'] = global['rx-angular'] || {}, global['rx-angular'].cdk = global['rx-angular'].cdk || {}, global['rx-angular'].cdk.transformations = {})));
}(this, (function (exports) { 'use strict';

    function isKeyOf(k) {
        var typeofK = typeof k;
        return (k !== null &&
            k !== undefined &&
            ['string', 'symbol', 'number'].includes(typeofK));
    }
    function isObjectGuard(obj) {
        return (obj !== null &&
            obj !== undefined &&
            typeof obj === 'object' &&
            !Array.isArray(obj));
    }
    function isDefined(val) {
        return val !== null && val !== undefined;
    }

    /**
     * @description
     * Inserts one or multiple items to an array T[].
     * Returns a shallow copy of the updated array T[], and does not mutate the original one.
     *
     * @example
     * // Inserting single value
     *
     * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];
     *
     * const updatedCreatures = insert(creatures, {id: 3, type: 'parrot'});
     *
     * // updatedCreatures will be:
     * //  [{id: 1, type: 'cat'}, {id: 2, type: 'dog}, {id: 3, type: 'parrot}];
     *
     * @example
     * // Inserting multiple values
     *
     * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];
     *
     * const updatedCreatures = insert(creatures, [{id: 3, type: 'parrot'}, {id: 4, type: 'hamster'}]);
     *
     * // updatedCreatures will be:
     * // [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}, {id: 3, type: 'parrot'}, {id: 4, type: 'hamster'}];
     *
     * @example
     * // Usage with RxState
     *
     * export class ListComponent {
     *
     *    readonly insertCreature$ = new Subject<void>();
     *
     *    constructor(private state: RxState<ComponentState>) {
     *      // Reactive implementation
     *      state.connect(
     *        'creatures',
     *        this.insertCreature$,
     *        ({ creatures }) => {
     *            const creatureToAdd = {id: generateId(), name: 'newCreature', type: 'dinosaur' };
     *            return insert(creatures, creatureToAdd);
     *        }
     *      );
     *    }
     *
     *    // Imperative implementation
     *    insertCeature(): void {
     *        const creatureToAdd = {id: generateId(), name: 'newCreature', type: 'dinosaur' };
     *        this.state.set({ creatures: insert(this.state.get().creatures, creatureToAdd)});
     *    }
     * }
     *
     *
     * @returns T[]
     *
     * @docsPage insert
     * @docsCategory transformation-helpers
     */
    function insert(source, updates) {
        var updatesDefined = isDefined(updates);
        var sourceIsNotArray = !Array.isArray(source);
        var invalidInput = sourceIsNotArray && !updatesDefined;
        if (sourceIsNotArray && isDefined(source)) {
            console.warn("Insert: Original value (" + source + ") is not an array.");
        }
        if (invalidInput) {
            return source;
        }
        return (sourceIsNotArray ? [] : source).concat(updatesDefined ? (Array.isArray(updates) ? updates : [updates]) : []);
    }

    var defaultCompareFn = function (a, b) { return a === b; };
    function valuesComparer(original, incoming, compare) {
        if (isKeyOf(compare)) {
            return original[compare] === incoming[compare];
        }
        if (Array.isArray(compare)) {
            var sanitizedKeys = compare.filter(function (k) { return isKeyOf(k); });
            return sanitizedKeys.length > 0
                ? sanitizedKeys.every(function (k) { return original[k] === incoming[k]; })
                : defaultCompareFn(original, incoming);
        }
        return (compare || defaultCompareFn)(original, incoming);
    }

    /**
     * @description
     * Removes one or multiple items from an array T[].
     * For comparison you can provide a key, an array of keys or a custom comparison function that should return true if items match.
     * If no comparison data is provided, an equality check is used by default.
     * Returns a shallow copy of the updated array T[], and does not mutate the original one.
     *
     * @example
     * // Removing value without comparison data
     *
     * const items = [1,2,3,4,5];
     *
     * const updatedItems = remove(items, [1,2,3]);
     *
     * // updatedItems will be: [4,5];
     *
     * @example
     * // Removing values with comparison function
     *
     * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'unicorn'}, {id: 3, type: 'kobold'}];
     *
     * const nonExistingCreatures = [{id: 2, type: 'unicorn'}, {id: 3, type: 'kobold'}];
     *
     * const realCreatures = remove(creatures, nonExistingCreatures, (a, b) => a.id === b.id);
     *
     * // realCreatures will be: [{id: 1, type: 'cat'}];
     *
     * @example
     * // Removing values with key
     *
     * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'unicorn'}, {id: 3, type: 'kobold'}];
     *
     * const nonExistingCreatures = [{id: 2, type: 'unicorn'}, {id: 3, type: 'kobold'}];
     *
     * const realCreatures = remove(creatures, nonExistingCreatures, 'id');
     *
     * // realCreatures will be: [{id: 1, type: 'cat'}];
     *
     * @example
     * // Removing values with array of keys
     *
     * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'unicorn'}, {id: 3, type: 'kobold'}];
     *
     * const nonExistingCreatures = [{id: 2, type: 'unicorn'}, {id: 3, type: 'kobold'}];
     *
     * const realCreatures = remove(creatures, nonExistingCreatures, ['id', 'type']);
     *
     * // realCreatures will be: [{id: 1, type: 'cat'}];
     *
     * @example
     * // Usage with RxState
     *
     * export class ListComponent {
     *
     *    readonly removeCreature$ = new Subject<Creature>();
     *
     *    constructor(private state: RxState<ComponentState>) {
     *      // Reactive implementation
     *      state.connect(
     *        'creatures',
     *        this.removeCreature$,
     *        ({ creatures }, creatureToRemove) => {
     *            return remove(creatures, creatureToRemove, (a, b) => a.id === b.id);
     *        }
     *      );
     *    }
     *
     *    // Imperative implementation
     *    removeCreature(creatureToRemove: Creature): void {
     *        this.state.set({ creatures: remove(this.state.get().creatures, creatureToRemove, (a, b) => a.id === b.id)});
     *    }
     * }
     *
     * @returns T[]
     *
     * @docsPage remove
     * @docsCategory transformation-helpers
     */
    function remove(source, scrap, compare) {
        var scrapAsArray = isDefined(scrap)
            ? Array.isArray(scrap)
                ? scrap
                : [scrap]
            : [];
        var invalidInput = !Array.isArray(source);
        if (invalidInput) {
            console.warn("Remove: original value (" + source + ") is not an array");
            return source;
        }
        return source.filter(function (existingItem) {
            return !scrapAsArray.some(function (item) { return valuesComparer(item, existingItem, compare); });
        });
    }

    /**
     * @description
     * Converts an array of objects to a dictionary {[key: string]: T}.
     * Accepts array T[] and key of type string, number or symbol as inputs.
     *
     *
     * @example
     *
     * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}, {id: 3, type: 'parrot'}];
     *
     * const creaturesDictionary = toDictionary(creatures, 'id');
     *
     * // creaturesDictionary will be:
     * // {
     * //  1: {id: 1, type: 'cat'},
     * //  2: {id: 2, type: 'dog'},
     * //  3: {id: 3, type: 'parrot'}
     * // };
     * @example
     * // Usage with RxState
     *
     * export class ListComponent {
     *
     *    readonly convertToDictionary$ = new Subject();
     *
     *    constructor(private state: RxState<ComponentState>) {
     *      // Reactive implementation
     *      state.connect(
     *        'creaturesDictionary',
     *        this.convertToDictionary$,
     *        ({ creatures }) => {
     *            return toDictionary(creatures, 'id');
     *        }
     *      );
     *    }
     *
     *    // Imperative implementation
     *    convertToDictionary(): void {
     *        this.state.set({ creaturesDictionary: toDictionary(this.state.get().creatures, 'id'});
     *    }
     * }
     *
     * @see {@link OnlyKeysOfSpecificType}
     * @param {OnlyKeysOfSpecificType<T, S>} key
     * @returns { [key: string]: T[] }
     * @docsPage toDictionary
     * @docsCategory transformation-helpers
     */
    function toDictionary(source, key) {
        if (!isDefined(source)) {
            return source;
        }
        var sourceEmpty = !source.length;
        if (!Array.isArray(source) || sourceEmpty || !isKeyOf(source[0][key])) {
            if (!sourceEmpty) {
                console.warn('ToDictionary: unexpected input params.');
            }
            return {};
        }
        var dictionary = {};
        var length = source.length;
        var i = 0;
        for (i; i < length; i++) {
            dictionary["" + source[i][key]] = Object.assign({}, source[i]);
        }
        return dictionary;
    }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                    if (!ar)
                        ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                }
            }
        return to.concat(ar || Array.prototype.slice.call(from));
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
            throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    /**
     * @description
     * Updates one or multiple items in an array T[].
     * For comparison you can provide key, array of keys or a custom comparison function that should return true if items match.
     * If no comparison is provided, an equality check is used by default.
     * Returns a shallow copy of the array T[] and updated items, does not mutate the original array.
     *
     * @example
     * // Update with comparison function
     *
     * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];
     *
     * const newCat = {id: 1, type: 'lion'};
     *
     * const updatedCreatures = update(creatures, newCat, (a, b) => a.id === b.id);
     *
     * // updatedCreatures will be:
     * // [{id: 1, type: 'lion'}, {id: 2, type: 'dog'}];
     *
     * @example
     * // Update with key
     *
     * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];
     *
     * const newCat = {id: 1, type: 'lion'};
     *
     * const updatedCreatures = update(creatures, newCat, 'id');
     *
     * // updatedCreatures will be:
     * // [{id: 1, type: 'lion'}, {id: 2, type: 'dog'}];
     *
     * @example
     * // Update with array of keys
     *
     * const creatures = [{id: 1, type: 'cat', name: 'Bella'}, {id: 2, type: 'dog', name: 'Sparky'}];
     *
     * const newCat = {id: 1, type: 'lion', name: 'Bella'};
     *
     * const updatedCreatures = update(creatures, newCat, ['id', 'name']);
     *
     * // updatedCreatures will be:
     * // [{id: 1, type: 'lion', name: 'Bella'}, {id: 2, type: 'dog', name: 'Sparky'}];
     *
     * @example
     * // Usage with RxState
     *
     * export class ListComponent {
     *
     *    readonly updateCreature$ = new Subject<Creature>();
     *
     *    constructor(private state: RxState<ComponentState>) {
     *      // Reactive implementation
     *      state.connect(
     *        'creatures',
     *        this.updateCreature$,
     *        ({ creatures }, creatureToUpdate) => {
     *            return update(creatures, creatureToUpdate, (a, b) => a.id === b.id);
     *        }
     *      );
     *    }
     *
     *    // Imperative implementation
     *    updateCreature(creatureToUpdate: Creature): void {
     *        this.state.set({ creatures: update(this.state.get().creatures, creatureToUpdate, (a, b) => a.id === b.id)});
     *    }
     * }
     *
     * @returns T[]
     *
     * @docsPage update
     * @docsCategory transformation-helpers
     */
    function update(source, updates, compare) {
        var e_1, _a;
        var updatesDefined = updates != null;
        var updatesAsArray = updatesDefined
            ? Array.isArray(updates)
                ? updates
                : [updates]
            : [];
        var sourceDefined = source != null;
        var sourceIsNotArray = !Array.isArray(source);
        var invalidInput = sourceIsNotArray || source.length === 0 || updatesAsArray.length === 0;
        if (sourceDefined && sourceIsNotArray) {
            console.warn("Update: Original value (" + source + ") is not an array.");
        }
        if (invalidInput) {
            return source;
        }
        var x = [];
        var _loop_1 = function (existingItem) {
            var match = customFind(updatesAsArray, function (item) { return valuesComparer(item, existingItem, compare); });
            x.push(match ? Object.assign(Object.assign({}, existingItem), match) : existingItem);
        };
        try {
            for (var source_1 = __values(source), source_1_1 = source_1.next(); !source_1_1.done; source_1_1 = source_1.next()) {
                var existingItem = source_1_1.value;
                _loop_1(existingItem);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (source_1_1 && !source_1_1.done && (_a = source_1.return)) _a.call(source_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return x;
    }
    function customFind(array, fn) {
        var e_2, _a;
        try {
            for (var array_1 = __values(array), array_1_1 = array_1.next(); !array_1_1.done; array_1_1 = array_1.next()) {
                var item = array_1_1.value;
                var x = fn(item);
                if (x) {
                    return item;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (array_1_1 && !array_1_1.done && (_a = array_1.return)) _a.call(array_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }

    /**
     * @description
     * Accepts an array of objects of type T and single key or array of keys (K extends keyof T).
     * The `exctract` method is pure and immutable, thus not touching the input values and returning a shallow
     * copy of the extracted source.
     *
     * @example
     *
     * const cats = [{id: 1, type: 'cat', name: 'Fluffy'}, {id: 2, type: 'cat', name: 'Emma'}];
     *
     * const catsWithoutTypes = extract(cats, ['name', 'id']);
     *
     * // catsWithoutTypes will be:
     * // [{id: 1, name: 'Fluffy'}, {id: 2, name: 'Emma'}];
     *
     * @example
     * // Usage with RxState
     *
     * export class AnimalsListComponent {
     *
     *    constructor(private state: RxState<ComponentState>, private api: ApiService) {
     *      state.connect(
     *        'animals'
     *        this.api.getAnimals(),
     *        (state, animals) => extract(animals, ['id', 'name'])
     *      );
     *    }
     * }
     *
     * @returns T
     *
     * @docsPage slice
     * @docsCategory transformation-helpers
     */
    function extract(array, keys) {
        var arrayIsArray = isDefined(array) && Array.isArray(array);
        if (!arrayIsArray) {
            console.warn("extract: original value (" + array + ") is not an array.");
            return undefined;
        }
        var sanitizedKeys = (Array.isArray(keys) ? keys : [keys]).filter(function (k) { return isKeyOf(k) && array.some(function (i) { return k in i; }); });
        var length = sanitizedKeys.length;
        if (!sanitizedKeys.length) {
            console.warn("extract: provided keys not found");
            return undefined;
        }
        return array.map(function (item) {
            var i = 0;
            var result = {};
            for (i; i < length; i++) {
                result[sanitizedKeys[i]] = item[sanitizedKeys[i]];
            }
            return result;
        });
    }

    /**
     * @description
     * Updates or inserts (if does not exist) one or multiple items in an array T[].
     * For comparison you can provide a key, an array of keys or a custom comparison function that should return true if
     * items match.
     * If no comparison is provided, an equality check is used by default.
     * upsert is `pure` and `immutable`, your inputs won't be changed
     *
     *
     * @example
     * // Upsert (update) with key
     *
     * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];
     *
     * const newCat = {id: 1, type: 'lion'};
     *
     * const updatedCreatures = upsert(creatures, newCat, 'id');
     *
     * // updatedCreatures will be:
     * // [{id: 1, type: 'lion'}, {id: 2, type: 'dog'}];
     *
     * @example
     * // Upsert (insert) with key
     *
     * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];
     *
     * const newCat = {id: 3, type: 'lion'};
     *
     * const updatedCreatures = upsert(creatures, newCat, 'id');
     *
     * // updatedCreatures will be:
     * // [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}, {id: 3, type: 'lion'}];
     *
     * @example
     * // Upsert (update) with array of keys
     *
     * const creatures = [{id: 1, type: 'cat', name: 'Bella'}, {id: 2, type: 'dog', name: 'Sparky'}];
     *
     * const newCat = {id: 1, type: 'lion', name: 'Bella'};
     *
     * const updatedCreatures = upsert(creatures, newCat, ['id', 'name']);
     *
     * // updatedCreatures will be:
     * // [{id: 1, type: 'lion', name: 'Bella'}, {id: 2, type: 'dog', name: 'Sparky'}];
     *
     * @example
     * // Update (insert) with comparison function
     *
     * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];
     *
     * const newCat = {id: 3, type: 'lion'};
     *
     * const updatedCreatures = upsert(creatures, newCat, (a, b) => a.id === b.id);
     *
     * // updatedCreatures will be:
     * // [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}, {id: 3, type: 'lion'}];
     *
     * @example
     * // Usage with RxState
     *
     * export class ListComponent {
     *
     *    // trigger which gets called on add/update (for reactive implementation)
     *    readonly addOrUpdateCreature = new Subject<Creature>();
     *
     *    constructor(private state: RxState<ComponentState>) {
     *      const initialCreatures = [{id: 1, type: 'cat', name: 'Bella'}, {id: 2, type: 'dog', name: 'Sparky'}];
     *      state.set({ creatures: initialCreatures });
     *      // Reactive implementation
     *      state.connect(
     *        'creatures',
     *        this.addOrUpdateCreature,
     *        ({ creatures }, creatureToUpsert) => {
     *            return upsert(creatures, creatureToUpsert, 'id');
     *        }
     *      );
     *    }
     *
     *    // Imperative implementation
     *    updateCreature(creatureToUpdate: Creature): void {
     *        this.state.set({ creatures: upsert(this.state.get('creatures'), creatureToUpdate, 'id')});
     *    }
     * }
     *
     * @returns T[]
     *
     * @docsPage upsert
     * @docsCategory transformation-helpers
     */
    function upsert(source, update, compare) {
        var e_1, _a;
        // check inputs for validity
        var updatesAsArray = update != null ? (Array.isArray(update) ? update : [update]) : [];
        // check inputs for validity
        var sourceIsNotArray = !Array.isArray(source);
        var invalidInput = sourceIsNotArray && updatesAsArray.length === 0;
        // if the source value is not an Array or the input is not defined return the original source
        // this is the case for any edge case:
        // '', null, undefined, CustomObjectOfDoomAndDarkness, ...
        if (invalidInput) {
            return source;
        }
        // if source is empty array or not an array, but the updates are valid:
        // return a shallow copy of the updates as result
        if (updatesAsArray.length > 0 && (sourceIsNotArray || source.length === 0)) {
            return __spreadArray([], __read(updatesAsArray));
        }
        var inserts = [];
        var updates = {};
        var _loop_1 = function (item) {
            var match = source.findIndex(function (sourceItem) { return valuesComparer(item, sourceItem, compare); });
            // if item already exists, save it as update
            if (match !== -1) {
                updates[match] = item;
            }
            else {
                // otherwise consider this as insert
                if (isObjectGuard(item)) {
                    // create a shallow copy if item is an object
                    inserts.push(Object.assign({}, item));
                }
                else {
                    // otherwise just push it
                    inserts.push(item);
                }
            }
        };
        try {
            // process updates/inserts
            for (var updatesAsArray_1 = __values(updatesAsArray), updatesAsArray_1_1 = updatesAsArray_1.next(); !updatesAsArray_1_1.done; updatesAsArray_1_1 = updatesAsArray_1.next()) {
                var item = updatesAsArray_1_1.value;
                _loop_1(item);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (updatesAsArray_1_1 && !updatesAsArray_1_1.done && (_a = updatesAsArray_1.return)) _a.call(updatesAsArray_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var updated = source.map(function (item, i) {
            var updatedItem = updates[i];
            // process the updated
            if (updatedItem !== null && updatedItem !== undefined) {
                if (isObjectGuard(item)) {
                    return Object.assign(Object.assign({}, item), updatedItem);
                }
                else {
                    return updatedItem;
                }
            }
            return item;
        });
        // return the combination of the updated source & the inserts as new array
        return updated.concat(inserts);
    }

    /**
     * @description
     * Accepts an object of type T and key of type K extends keyof T.
     * Removes property from an object and returns a shallow copy of the updated object without specified property.
     * If property not found returns copy of the original object.
     * Not mutating original object.
     *
     * @example
     *
     * const cat = {id: 1, type: 'cat', name: 'Fluffy'};
     *
     * const anonymusCat = deleteProp(cat, 'name');
     *
     * // anonymusCat will be:
     * // {id: 1, type: 'cat'};
     *
     * @example
     * // Usage with RxState
     *
     * export class ProfileComponent {
     *
     *    readonly removeName$ = new Subject();
     *
     *    constructor(private state: RxState<ComponentState>) {
     *      // Reactive implementation
     *      state.connect(
     *        this.removeName$,
     *        (state) => {
     *            return deleteProp(state, 'name');
     *        }
     *      );
     *    }
     *
     *    // Imperative implementation
     *    removeName(): void {
     *        this.state.set(remove(this.get(), 'name'));
     *    }
     * }
     *
     * @returns Omit<T, K>
     *
     * @docsPage deleteProp
     * @docsCategory transformation-helpers
     */
    function deleteProp(object, key) {
        if (!isDefined(object) || !isObjectGuard(object)) {
            console.warn("DeleteProp: original value " + object + " is not an object.");
            return object;
        }
        if (!isKeyOf(key)) {
            console.warn("DeleteProp: provided key is not a string, number or symbol.");
            return Object.assign({}, object);
        }
        var copy = Object.assign({}, object);
        delete copy[key];
        return copy;
    }

    /**
     * @description
     * Converts a dictionary of type {[key: string]: T} to array T[].
     *
     * @example
     *
     * const creaturesDictionary = {
     *   '1': {id: 1, type: 'cat'},
     *   '2': {id: 2, type: 'dog'},
     *   '3': {id: 3, type: 'parrot'}
     * };
     *
     * const creaturesArray = dictionaryToArray(creaturesDictionary);
     *
     * // creaturesArray will be:
     * // [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}, {id: 3, type: 'parrot'}];
     *
     * @example
     * // Usage with RxState
     *
     * export class ListComponent {
     *    readonly removeName$ = new Subject();
     *
     *    constructor(
     *      private state: RxState<ComponentState>,
     *      private api: ApiService
     *    ) {
     *      // Reactive implementation
     *      state.connect(
     *        'creatures',
     *        this.api.creaturesDictionary$,
     *        (_, creatures) => {
     *            return dictionaryToArray(creatures);
     *        }
     *      );
     *    }
     *
     *    // Imperative implementation
     *    removeName(): void {
     *      this.api.creaturesDictionary$.pipe(
     *        // subscription handling logic
     *      ).subscribe(
     *        dictionary => this.set({creatures: dictionaryToArray(dictionary)})
     *      );
     *    }
     * }
     *
     * @returns T[];
     *
     * @docsPage dictionaryToArray
     * @docsCategory transformation-helpers
     */
    function dictionaryToArray(dictionary) {
        if (!isDefined(dictionary)) {
            return dictionary;
        }
        if (!isObjectGuard(dictionary)) {
            console.warn("DictionaryToArray: unexpected input.");
            return [];
        }
        return Object.values(dictionary);
    }

    /**
     * @description
     * Merges an object of type T with updates of type Partial<T>.
     * Returns a new object where updates override original values while not mutating the original one.

     * @example
     * interface Creature {
     *  id: number,
     *  type: string,
     *  name: string
     * }
     *
     * const cat = {id: 1, type: 'cat'};
     *
     * const catWithname = patch(cat, {name: 'Fluffy'});
     *
     * // catWithname will be:
     * // {id: 1, type: 'cat', name: 'Fluffy'};
     *
     * @example
     * // Usage with RxState
     *
     * export class ProfileComponent {
     *
     *    readonly changeName$ = new Subject<string>();
     *
     *    constructor(private state: RxState<ComponentState>) {
     *      // Reactive implementation
     *      state.connect(
     *        this.changeName$,
     *        (state, name) => {
     *            return patch(state, { name });
     *        }
     *      );
     *    }
     *
     *    // Imperative implementation
     *    changeName(name: string): void {
     *        this.state.set(patch(this.get(), { name }));
     *    }
     * }
     *
     * @returns T
     *
     * @docsPage patch
     * @docsCategory transformation-helpers
     */
    function patch(object, upd) {
        var update = isObjectGuard(upd) ? upd : {};
        if (!isObjectGuard(object) && isObjectGuard(upd)) {
            console.warn("Patch: original value " + object + " is not an object.");
            return Object.assign({}, update);
        }
        if (!isObjectGuard(object) && !isObjectGuard(upd)) {
            console.warn("Patch: original value " + object + " and updates " + upd + " are not objects.");
            return object;
        }
        return Object.assign(Object.assign({}, object), update);
    }

    /**
     * @description
     * Accepts an object of type T, key of type K extends keyof T, and value of type T[K].
     * Sets the property and returns a newly updated shallow copy of an object while not mutating the original one.
     *
     * @example
     *
     * const cat = {id: 1, type: 'cat', name: 'Fluffy'};
     *
     * const renamedCat = setProp(cat, 'name', 'Bella');
     *
     * // renamedCat will be:
     * // {id: 1, type: 'cat', name: 'Bella'};
     *
     * @example
     * // Usage with RxState
     *
     * export class ProfileComponent {
     *
     *    readonly changeName$ = new Subject<string>();
     *
     *    constructor(private state: RxState<ComponentState>) {
     *      // Reactive implementation
     *      state.connect(
     *        this.changeName$,
     *        (state, name) => {
     *            return setProp(state, 'name', name);
     *        }
     *      );
     *    }
     *
     *    // Imperative implementation
     *    changeName(name: string): void {
     *        this.state.set(setProp(this.get(), 'name', name));
     *    }
     * }
     *
     * @returns T
     *
     * @docsPage setProp
     * @docsCategory transformation-helpers
     */
    function setProp(object, key, value) {
        var _a;
        var objectIsObject = isObjectGuard(object);
        var keyIsValid = isKeyOf(key);
        var initialObject = objectIsObject ? object : {};
        if (!objectIsObject) {
            console.warn("SetProp: original value (" + object + ") is not an object.");
        }
        if (!keyIsValid) {
            console.warn("SetProp: key argument (" + key + ") is invalid.");
        }
        if (!isDefined(object) && !keyIsValid) {
            return object;
        }
        if (keyIsValid) {
            return Object.assign(Object.assign({}, initialObject), (_a = {}, _a[key] = value, _a));
        }
        return Object.assign({}, initialObject);
    }

    /**
     * @description
     * Toggles a boolean property in the object.
     * Accepts object of type T and key value of which is boolean.
     * Toggles the property and returns a shallow copy of an object, while not mutating the original one.
     *
     * @example
     *
     * const state = {items: [1,2,3], loading: true};
     *
     * const updatedState = toggle(state, 'loading');
     *
     * // updatedState will be:
     * // {items: [1,2,3], loading: false};
     *
     * @example
     * // Usage with RxState
     *
     * export class ListComponent {
     *    readonly loadingChange$ = new Subject();
     *
     *    constructor(
     *      private state: RxState<ComponentState>
     *    ) {
     *      // Reactive implementation
     *      state.connect(
     *        this.api.loadingChange$,
     *        (state, _) => {
     *            return toggle(state, 'isLoading');
     *        }
     *      );
     *    }
     *
     *    // Imperative implementation
     *    toggleLoading(): void {
     *      this.set(toggle(state, 'isLoading'));
     *    }
     * }
     *
     * @returns T
     *
     * @docsPage toggle
     * @docsCategory transformation-helpers
     */
    function toggle(object, key) {
        var _a;
        var objectIsObject = isObjectGuard(object);
        var keyIsValid = isKeyOf(key);
        var initialObject = objectIsObject ? object : {};
        if (!objectIsObject) {
            console.warn("Toggle: original value (" + object + ") is not an object.");
        }
        if (!keyIsValid) {
            console.warn("Toggle: key argument (" + key + ") is invalid.");
        }
        if (keyIsValid && typeof initialObject[key] !== 'boolean') {
            console.warn("Toggle: value of the key (" + key + ") is not a boolean.");
        }
        if (!isDefined(object) && !keyIsValid) {
            return object;
        }
        if (keyIsValid &&
            (typeof initialObject[key] === 'boolean' ||
                !initialObject.hasOwnProperty(key))) {
            return Object.assign(Object.assign({}, initialObject), (_a = {}, _a[key] = !initialObject[key], _a));
        }
        return Object.assign({}, initialObject);
    }

    /**
     * @description
     * Accepts an object of type T and single key or array of keys (K extends keyof T).
     * Constructs new object based on provided keys.
     *
     * @example
     *
     * const cat = {id: 1, type: 'cat', name: 'Fluffy'};
     *
     * const catWithoutType = slice(cat, ['name', 'id']);
     *
     * // catWithoutType will be:
     * // {id: 1, name: 'Fluffy'};
     *
     * @example
     * // Usage with RxState
     *
     * export class AnimalsListComponent {
     *
     *    constructor(private state: RxState<ComponentState>, private api: ApiService) {
     *      state.connect(
     *        'animals'
     *        this.api.getAnimals(),
     *        (state, animals) => {
     *            return animals.map(animal => slice(animal, ['id', 'name']));
     *        }
     *      );
     *    }
     * }
     *
     * @returns T
     *
     * @docsPage slice
     * @docsCategory transformation-helpers
     */
    function slice(object, keys) {
        var objectIsObject = isDefined(object) && isObjectGuard(object);
        if (!objectIsObject) {
            console.warn("slice: original value (" + object + ") is not an object.");
            return undefined;
        }
        var sanitizedKeys = (Array.isArray(keys) ? keys : [keys]).filter(function (k) { return isKeyOf(k) && k in object; });
        if (!sanitizedKeys.length) {
            console.warn("slice: provided keys not found");
            return undefined;
        }
        return sanitizedKeys.reduce(function (acc, k) {
            var _a;
            return (Object.assign(Object.assign({}, acc), (_a = {}, _a[k] = object[k], _a)));
        }, {});
    }

    /**
     * Generated bundle index. Do not edit.
     */

    exports.deleteProp = deleteProp;
    exports.dictionaryToArray = dictionaryToArray;
    exports.extract = extract;
    exports.insert = insert;
    exports.patch = patch;
    exports.remove = remove;
    exports.setProp = setProp;
    exports.slice = slice;
    exports.toDictionary = toDictionary;
    exports.toggle = toggle;
    exports.update = update;
    exports.upsert = upsert;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=cdk-transformations.umd.js.map
