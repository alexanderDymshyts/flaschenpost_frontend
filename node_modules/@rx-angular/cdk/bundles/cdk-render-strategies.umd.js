(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs'), require('rxjs/operators'), require('@rx-angular/cdk/internals/scheduler'), require('@rx-angular/cdk/coalescing'), require('@rx-angular/cdk/internals/core'), require('@rx-angular/cdk/coercing')) :
    typeof define === 'function' && define.amd ? define('@rx-angular/cdk/render-strategies', ['exports', '@angular/core', 'rxjs', 'rxjs/operators', '@rx-angular/cdk/internals/scheduler', '@rx-angular/cdk/coalescing', '@rx-angular/cdk/internals/core', '@rx-angular/cdk/coercing'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global['rx-angular'] = global['rx-angular'] || {}, global['rx-angular'].cdk = global['rx-angular'].cdk || {}, global['rx-angular'].cdk['render-strategies'] = {}), global.ng.core, global.rxjs, global.rxjs.operators, global['rx-angular'].cdk.internals.scheduler, global['rx-angular'].cdk.coalescing, global['rx-angular'].cdk.internals.core, global['rx-angular'].cdk.coercing));
}(this, (function (exports, i0, rxjs, operators, scheduler, coalescing, core, coercing) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }

    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);

    // set default to 60fps
    scheduler.forceFrameRate(60);
    var immediateStrategy = {
        name: 'immediate',
        work: function (cdRef) { return cdRef.detectChanges(); },
        behavior: function (_a) {
            var work = _a.work, scope = _a.scope, ngZone = _a.ngZone;
            return function (o$) { return o$.pipe(scheduleOnQueue(work, {
                ngZone: ngZone,
                priority: 1 /* ImmediatePriority */,
                scope: scope,
            })); };
        },
    };
    var userBlockingStrategy = {
        name: 'userBlocking',
        work: function (cdRef) { return cdRef.detectChanges(); },
        behavior: function (_a) {
            var work = _a.work, scope = _a.scope, ngZone = _a.ngZone;
            return function (o$) { return o$.pipe(scheduleOnQueue(work, {
                ngZone: ngZone,
                priority: 2 /* UserBlockingPriority */,
                scope: scope,
            })); };
        },
    };
    var normalStrategy = {
        name: 'normal',
        work: function (cdRef) { return cdRef.detectChanges(); },
        behavior: function (_a) {
            var work = _a.work, scope = _a.scope, ngZone = _a.ngZone;
            return function (o$) { return o$.pipe(scheduleOnQueue(work, {
                ngZone: ngZone,
                priority: 3 /* NormalPriority */,
                scope: scope,
            })); };
        },
    };
    var lowStrategy = {
        name: 'low',
        work: function (cdRef) { return cdRef.detectChanges(); },
        behavior: function (_a) {
            var work = _a.work, scope = _a.scope, ngZone = _a.ngZone;
            return function (o$) { return o$.pipe(scheduleOnQueue(work, {
                ngZone: ngZone,
                priority: 4 /* LowPriority */,
                scope: scope,
            })); };
        },
    };
    var idleStrategy = {
        name: 'idle',
        work: function (cdRef) { return cdRef.detectChanges(); },
        behavior: function (_a) {
            var work = _a.work, scope = _a.scope, ngZone = _a.ngZone;
            return function (o$) { return o$.pipe(scheduleOnQueue(work, {
                ngZone: ngZone,
                priority: 5 /* IdlePriority */,
                scope: scope,
            })); };
        },
    };
    function scheduleOnQueue(work, options) {
        var scope = options.scope || {};
        return function (o$) { return o$.pipe(operators.filter(function () { return !coalescing.coalescingManager.isCoalescing(scope); }), operators.switchMap(function (v) { return new rxjs.Observable(function (subscriber) {
            coalescing.coalescingManager.add(scope);
            var task = scheduler.scheduleCallback(options.priority, function () {
                work();
                coalescing.coalescingManager.remove(scope);
                subscriber.next(v);
            }, { delay: options.delay, ngZone: options.ngZone });
            return function () {
                coalescing.coalescingManager.remove(scope);
                scheduler.cancelCallback(task);
            };
        }).pipe(operators.mapTo(v)); })); };
    }
    var RX_CONCURRENT_STRATEGIES = {
        immediate: immediateStrategy,
        userBlocking: userBlockingStrategy,
        normal: normalStrategy,
        low: lowStrategy,
        idle: idleStrategy,
    };

    var animationFrameTick = function () { return new rxjs.Observable(function (subscriber) {
        // use the unpatched API no avoid zone interference
        var id = core.getZoneUnPatchedApi('requestAnimationFrame')(function () {
            subscriber.next(0);
            subscriber.complete();
        });
        return function () {
            // use the unpatched API no avoid zone interference
            core.getZoneUnPatchedApi('cancelAnimationFrame')(id);
        };
    }); };
    var localCredentials = {
        name: 'local',
        work: function (cdRef, _, notification) {
            cdRef.detectChanges();
        },
        behavior: function (_a) {
            var work = _a.work, scope = _a.scope, ngZone = _a.ngZone;
            return function (o$) { return o$.pipe(coalescing.coalesceWith(animationFrameTick(), scope), operators.tap(function () { return (ngZone ? ngZone.run(function () { return work(); }) : work()); })); };
        },
    };
    var noopCredentials = {
        name: 'noop',
        work: function () { return void 0; },
        behavior: function () { return function (o$) { return o$; }; },
    };
    var nativeCredentials = {
        name: 'native',
        work: function (cdRef) { return cdRef.markForCheck(); },
        behavior: function (_a) {
            var work = _a.work, ngZone = _a.ngZone;
            return function (o$) { return o$.pipe(operators.tap(function () { return ngZone && !i0.NgZone.isInAngularZone()
                ? ngZone.run(function () { return work(); })
                : work(); })); };
        },
    };
    /**
     * @deprecated
     * angular drops the internal markDirty API, will fall back to native if used
     */
    var globalCredentials = Object.assign(Object.assign({}, nativeCredentials), { name: 'global' });
    var RX_NATIVE_STRATEGIES = {
        global: globalCredentials,
        native: nativeCredentials,
        noop: noopCredentials,
        local: localCredentials,
    };

    var RX_RENDER_STRATEGIES_CONFIG = new i0.InjectionToken('rxa-render-strategies-config');
    var RX_RENDER_STRATEGIES_DEFAULTS = {
        primaryStrategy: 'normal',
        customStrategies: Object.assign(Object.assign({}, RX_NATIVE_STRATEGIES), RX_CONCURRENT_STRATEGIES),
        patchZone: true,
        parent: true,
    };
    function mergeDefaultConfig(cfg) {
        var custom = cfg
            ? cfg
            : {
                customStrategies: {},
            };
        return Object.assign(Object.assign(Object.assign({}, RX_RENDER_STRATEGIES_DEFAULTS), custom), { customStrategies: Object.assign(Object.assign({}, custom.customStrategies), RX_RENDER_STRATEGIES_DEFAULTS.customStrategies) });
    }

    /**
     * @internal
     *
     * @param value
     * @param strategy
     * @param workFactory
     * @param options
     */
    function onStrategy(value, strategy, workFactory, options) {
        if (options === void 0) { options = {}; }
        return new rxjs.Observable(function (subscriber) {
            subscriber.next(value);
        }).pipe(strategy.behavior({
            work: function () { return workFactory(value, strategy.work, options); },
            scope: options.scope || {},
            ngZone: options.ngZone,
        }), operators.catchError(function (error) { return rxjs.throwError(function () { return [error, value]; }); }), operators.map(function () { return value; }), operators.take(1));
    }

    /**
     * @description
     * RxStrategyProvider is a wrapper service that you can use to consume strategies and schedule your code execution.
     *
     * @example
     * Component({
     *   selector: 'app-service-communicator',
     *   template: ``
     * });
     * export class ServiceCommunicationComponent {
     *   private currentUserSettings;
     *
     *   constructor(
     *     private strategyProvider: RxStrategyProvider,
     *     private userService: UserService,
     *     private backgroundSync: BackgroundSyncService
     *   ) {
     *     this.userService.fetchCurrentUserSettings
     *       .pipe(
     *         tap(settings => (this.currentUserSettings = settings)),
     *         this.strategyProvider.scheduleWith(
     *           settings => this.backgroundSync.openConnection(settings),
     *           { strategy: 'idle' }
     *         )
     *       )
     *       .subscribe();
     *   }
     * }
     *
     * @docsCategory RxStrategyProvider
     * @docsPage RxStrategyProvider
     */
    var RxStrategyProvider = /** @class */ (function () {
        /**
         * @internal
         */
        function RxStrategyProvider(cfg) {
            this._strategies$ = new rxjs.BehaviorSubject(undefined);
            this._primaryStrategy$ = new rxjs.BehaviorSubject(undefined);
            /**
             * @description
             * Current strategy of the service as an observable.
             */
            this.primaryStrategy$ = this._primaryStrategy$.asObservable();
            /**
             * @description
             * Returns observable of an object that contains key-value pairs of strategy names and their credentials (settings) that are available in the service.
             */
            this.strategies$ = this._strategies$.asObservable();
            /**
             * @description
             * Returns an observable of an array of strategy names available in the service.
             */
            this.strategyNames$ = this.strategies$.pipe(operators.map(function (strategies) { return Object.values(strategies).map(function (s) { return s.name; }); }), operators.shareReplay({ bufferSize: 1, refCount: true }));
            this._cfg = mergeDefaultConfig(cfg);
            this._strategies$.next(this._cfg.customStrategies);
            this.primaryStrategy = this.config.primaryStrategy;
        }
        Object.defineProperty(RxStrategyProvider.prototype, "config", {
            /**
             * @description
             * Returns current `RxAngularConfig` used in the service.
             * Config includes:
             * - strategy that currently in use - `primaryStrategy`
             * - array of custom user defined strategies - `customStrategies`
             * - setting that is responsible for running in our outside of the zone.js - `patchZone`
             */
            get: function () {
                return this._cfg;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(RxStrategyProvider.prototype, "strategies", {
            /**
             * @description
             * Returns object that contains key-value pairs of strategy names and their credentials (settings) that are available in the service.
             */
            get: function () {
                return this._strategies$.getValue();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(RxStrategyProvider.prototype, "strategyNames", {
            /**
             * @description
             * Returns an array of strategy names available in the service.
             */
            get: function () {
                return Object.values(this.strategies).map(function (s) { return s.name; });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(RxStrategyProvider.prototype, "primaryStrategy", {
            /**
             * @description
             * Returns current strategy of the service.
             */
            get: function () {
                return this._primaryStrategy$.getValue().name;
            },
            /**
             * @description
             * Set's the strategy that will be used by the service.
             */
            set: function (strategyName) {
                this._primaryStrategy$.next(this.strategies[strategyName]);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @description
         * Allows to schedule a work inside rxjs `pipe`. Accepts the work and configuration options object.
         * - work is any function that should be executed
         * - (optional) options includes strategy, patchZone and scope
         *
         * Scope is by default a subscription but you can also pass `this` and then the scope will be current component.
         * Scope setup is useful if your work is some of the methods of `ChangeDetectorRef`. Only one change detection will be triggered if you have multiple schedules of change detection methods and scope is set to `this`.
         *
         * @example
         * myObservable$.pipe(
         *    this.strategyProvider.scheduleWith(() => myWork(), {strategy: 'idle', patchZone: false})
         * ).subscribe();
         *
         * @return MonoTypeOperatorFunction<R>
         */
        RxStrategyProvider.prototype.scheduleWith = function (work, options) {
            var strategy = this.strategies[(options === null || options === void 0 ? void 0 : options.strategy) || this.primaryStrategy];
            var scope = (options === null || options === void 0 ? void 0 : options.scope) || {};
            var _work = getWork(work, options === null || options === void 0 ? void 0 : options.patchZone);
            var ngZone = (options === null || options === void 0 ? void 0 : options.patchZone) || undefined;
            return function (o$) { return o$.pipe(operators.switchMap(function (v) { return onStrategy(v, strategy, function (_v) {
                _work(_v);
            }, { scope: scope, ngZone: ngZone }); })); };
        };
        /**
         * @description
         * Allows to schedule a work as an observable. Accepts the work and configuration options object.
         * - work is any function that should be executed
         * - (optional) options includes strategy, patchZone and scope
         *
         * Scope is by default a subscription but you can also pass `this` and then the scope will be current component.
         * Scope setup is especially useful if you provide work that will trigger a change detection.
         *
         * @example
         * this.strategyProvider.schedule(() => myWork(), {strategy: 'idle', patchZone: false}).subscribe();
         *
         * @return Observable<R>
         */
        RxStrategyProvider.prototype.schedule = function (work, options) {
            var strategy = this.strategies[(options === null || options === void 0 ? void 0 : options.strategy) || this.primaryStrategy];
            var scope = (options === null || options === void 0 ? void 0 : options.scope) || {};
            var _work = getWork(work, options === null || options === void 0 ? void 0 : options.patchZone);
            var ngZone = (options === null || options === void 0 ? void 0 : options.patchZone) || undefined;
            var returnVal;
            return onStrategy(null, strategy, function () {
                returnVal = _work();
            }, { scope: scope, ngZone: ngZone }).pipe(operators.map(function () { return returnVal; }));
        };
        /**
         * @description
         * Allows to schedule a change detection cycle. Accepts the ChangeDetectorRef and configuration options object.
         * Options include:
         * - afterCD which is the work that should be executed after change detection cycle.
         * - abortCtrl is an AbortController that you can use to cancel the scheduled cycle.
         *
         * @example
         * this.strategyProvider.scheduleCd(this.changeDetectorRef, {afterCD: myWork()});
         *
         * @return AbortController
         */
        RxStrategyProvider.prototype.scheduleCD = function (cdRef, options) {
            var strategy = this.strategies[(options === null || options === void 0 ? void 0 : options.strategy) || this.primaryStrategy];
            var scope = (options === null || options === void 0 ? void 0 : options.scope) || cdRef;
            var abC = (options === null || options === void 0 ? void 0 : options.abortCtrl) || new AbortController();
            var ngZone = (options === null || options === void 0 ? void 0 : options.patchZone) || undefined;
            var work = getWork(function () {
                strategy.work(cdRef, scope);
                if (options === null || options === void 0 ? void 0 : options.afterCD) {
                    options.afterCD();
                }
            }, options.patchZone);
            onStrategy(null, strategy, function () {
                work();
            }, { scope: scope, ngZone: ngZone })
                .pipe(operators.takeUntil(rxjs.fromEvent(abC.signal, 'abort')))
                .subscribe();
            return abC;
        };
        return RxStrategyProvider;
    }());
    /** @nocollapse */ RxStrategyProvider.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: RxStrategyProvider, deps: [{ token: RX_RENDER_STRATEGIES_CONFIG, optional: true }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ RxStrategyProvider.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: RxStrategyProvider, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: RxStrategyProvider, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () {
            return [{ type: undefined, decorators: [{
                            type: i0.Optional
                        }, {
                            type: i0.Inject,
                            args: [RX_RENDER_STRATEGIES_CONFIG]
                        }] }];
        } });
    function getWork(work, patchZone) {
        var _work = work;
        if (patchZone) {
            _work = function (args) { return patchZone.run(function () { return work(args); }); };
        }
        return _work;
    }

    /**
     * @internal
     *
     * A factory function returning an object to handle the process of turning strategy names into `RxStrategyCredentials`
     * You can next a strategy name as Observable or string and get an Observable of `RxStrategyCredentials`
     *
     * @param defaultStrategyName
     * @param strategies
     */
    function strategyHandling(defaultStrategyName, strategies) {
        var hotFlattened = coercing.coerceAllFactory(function () { return new rxjs.ReplaySubject(1); }, operators.switchAll());
        return {
            strategy$: hotFlattened.values$.pipe(operators.startWith(defaultStrategyName), nameToStrategyCredentials(strategies, defaultStrategyName), operators.share()),
            next: function (name) {
                hotFlattened.next(name);
            },
        };
    }
    /**
     * @internal
     */
    function nameToStrategyCredentials(strategies, defaultStrategyName) {
        return function (o$) { return o$.pipe(operators.map(function (name) { return name && Object.keys(strategies).includes(name)
            ? strategies[name]
            : strategies[defaultStrategyName]; })); };
    }

    /**
     * Generated bundle index. Do not edit.
     */

    exports.RX_CONCURRENT_STRATEGIES = RX_CONCURRENT_STRATEGIES;
    exports.RX_NATIVE_STRATEGIES = RX_NATIVE_STRATEGIES;
    exports.RX_RENDER_STRATEGIES_CONFIG = RX_RENDER_STRATEGIES_CONFIG;
    exports.RxStrategyProvider = RxStrategyProvider;
    exports.onStrategy = onStrategy;
    exports.strategyHandling = strategyHandling;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=cdk-render-strategies.umd.js.map
