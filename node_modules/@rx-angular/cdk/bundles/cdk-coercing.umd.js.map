{"version":3,"file":"cdk-coercing.umd.js","sources":["../../../../libs/cdk/coercing/src/lib/coerceObservable.ts","../../../../libs/cdk/coercing/src/lib/coerceObservableWith.ts","../../../../libs/cdk/coercing/src/lib/coerceDistinctObservable.ts","../../../../libs/cdk/coercing/src/lib/coerceDistinctObservableWith.ts","../../../../libs/cdk/coercing/src/lib/coerce-all-factory.ts","../../../../libs/cdk/coercing/src/cdk-coercing.ts"],"sourcesContent":["import { isObservable, Observable, ObservableInput, of } from 'rxjs';\n\n/**\n * This Observable factory creates an Observable out of a static value or ObservableInput.\n *\n * @param o - the value to coerce\n */\nexport function coerceObservable<T>(o: ObservableInput<T> | T): Observable<T> {\n  return isObservable(o) ? o : of(o as T);\n}\n","import { Observable, OperatorFunction } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { coerceObservable } from './coerceObservable';\n\n/**\n * This operator maps an Observable out of a static value or ObservableInput.\n *\n */\nexport function coerceObservableWith<T>(): OperatorFunction<\n  Observable<T | null | undefined> | T | null | undefined,\n  Observable<T | null | undefined>\n> {\n  return (o$: Observable<Observable<T> | T>) => map(coerceObservable)(o$);\n}\n","import {\n  isObservable,\n  Observable,\n  ObservableInput,\n  of,\n  OperatorFunction,\n} from 'rxjs';\nimport { distinctUntilChanged, map, switchAll } from 'rxjs/operators';\nimport { coerceObservable } from './coerceObservable';\n\n/**\n * This Observable factory creates an Observable out of a static value or ObservableInput.\n * It forwards only distinct values from distinct incoming Observables or values.\n * This comes in handy in any environment where you handle processing of incoming dynamic values and their state.\n *\n * Optionally you can pass a flatten strategy to get find grained control of the flattening process. E.g. mergeAll, switchAll\n *\n * @param o$ - The Observable to coerce and map to a Observable with distinct values\n * @param flattenOperator - determines the flattening strategy e.g. mergeAll, concatAll, exhaust, switchAll. default is switchAll\n */\nexport function coerceDistinctObservable<T>(\n  o$: Observable<Observable<T> | T>,\n  flattenOperator?: OperatorFunction<ObservableInput<T>, T>\n) {\n  flattenOperator = flattenOperator || switchAll();\n  return coerceObservable(o$).pipe(\n    distinctUntilChanged(),\n    flattenOperator,\n    distinctUntilChanged()\n  );\n}\n","import { Observable, ObservableInput, OperatorFunction } from 'rxjs';\nimport { distinctUntilChanged, switchAll } from 'rxjs/operators';\nimport { coerceObservableWith } from './coerceObservableWith';\n\n/**\n * This operator takes an Observable of values ot Observables aof values and\n * It forwards only distinct values from distinct incoming Observables or values.\n * This comes in handy in any environment where you handle processing of incoming dynamic values and their state.\n *\n * Optionally you can pass a flatten strategy to get find grained control of the flattening process. E.g. mergeAll, switchAll\n *\n * @param flattenOperator - determines the flattening strategy e.g. mergeAll, concatAll, exhaust, switchAll. default is switchAll\n *\n */\nexport function coerceDistinctWith<T>(\n  flattenOperator?: OperatorFunction<ObservableInput<T>, T>\n) {\n  flattenOperator = flattenOperator || switchAll();\n  return (o$: Observable<Observable<T> | T>) =>\n    o$.pipe(\n      coerceObservableWith(),\n      distinctUntilChanged(),\n      flattenOperator,\n      distinctUntilChanged()\n    );\n}\n","import { Observable, ObservableInput, OperatorFunction, Subject } from 'rxjs';\nimport { switchAll } from 'rxjs/operators';\nimport { coerceDistinctWith } from './coerceDistinctObservableWith';\n\n/**\n * @internal\n *\n * A factory function returning an object to handle the process of merging Observable next notifications into one\n *   Observable. This API takes away the clumsy handling of static values and Observable, reduces the number of\n *   emissions by:\n * - only merging distinct Observables\n * - only emit distingt values of the merged result\n *\n * You can next a Observable of `U` multiple times and merge them into the Observable exposed under one optimized\n *   `values$`\n *\n */\nexport function coerceAllFactory<U, R = U>(\n  subjectFactory?: () => Subject<ObservableInput<U> | U>,\n  flattenOperator?: OperatorFunction<ObservableInput<U>, R>\n): {\n  values$: Observable<R>;\n  next(observable: ObservableInput<U> | U): void;\n} {\n  const observablesSubject = subjectFactory ? subjectFactory() : new Subject();\n  flattenOperator = flattenOperator || (switchAll() as any);\n  const values$ = observablesSubject.pipe(\n    coerceDistinctWith(flattenOperator as any)\n  ) as Observable<R>;\n\n  return {\n    next(observable: ObservableInput<U> | U) {\n      observablesSubject.next(observable);\n    },\n    values$,\n  };\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":["isObservable","of","map","switchAll","distinctUntilChanged","Subject"],"mappings":";;;;;;IAEA;;;;;aAKgB,gBAAgB,CAAI,CAAyB;QAC3D,OAAOA,iBAAY,CAAC,CAAC,CAAC,GAAG,CAAC,GAAGC,OAAE,CAAC,CAAM,CAAC,CAAC;IAC1C;;ICLA;;;;aAIgB,oBAAoB;QAIlC,OAAO,UAAC,EAAiC,IAAK,OAAAC,aAAG,CAAC,gBAAgB,CAAC,CAAC,EAAE,CAAC,GAAA,CAAC;IAC1E;;ICHA;;;;;;;;;;aAUgB,wBAAwB,CACtC,EAAiC,EACjC,eAAyD;QAEzD,eAAe,GAAG,eAAe,IAAIC,mBAAS,EAAE,CAAC;QACjD,OAAO,gBAAgB,CAAC,EAAE,CAAC,CAAC,IAAI,CAC9BC,8BAAoB,EAAE,EACtB,eAAe,EACfA,8BAAoB,EAAE,CACvB,CAAC;IACJ;;IC1BA;;;;;;;;;;aAUgB,kBAAkB,CAChC,eAAyD;QAEzD,eAAe,GAAG,eAAe,IAAID,mBAAS,EAAE,CAAC;QACjD,OAAO,UAAC,EAAiC,IACvC,OAAA,EAAE,CAAC,IAAI,CACL,oBAAoB,EAAE,EACtBC,8BAAoB,EAAE,EACtB,eAAe,EACfA,8BAAoB,EAAE,CACvB,GAAA,CAAC;IACN;;ICrBA;;;;;;;;;;;;;aAagB,gBAAgB,CAC9B,cAAsD,EACtD,eAAyD;QAKzD,IAAM,kBAAkB,GAAG,cAAc,GAAG,cAAc,EAAE,GAAG,IAAIC,YAAO,EAAE,CAAC;QAC7E,eAAe,GAAG,eAAe,IAAKF,mBAAS,EAAU,CAAC;QAC1D,IAAM,OAAO,GAAG,kBAAkB,CAAC,IAAI,CACrC,kBAAkB,CAAC,eAAsB,CAAC,CAC1B,CAAC;QAEnB,OAAO;YACL,IAAI,YAAC,UAAkC;gBACrC,kBAAkB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;aACrC;YACD,OAAO,SAAA;SACR,CAAC;IACJ;;ICpCA;;;;;;;;;;;;;;;;"}