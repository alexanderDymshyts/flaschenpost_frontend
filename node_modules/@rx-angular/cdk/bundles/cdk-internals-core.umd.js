(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs'), require('rxjs/operators'), require('@rx-angular/cdk/coalescing')) :
    typeof define === 'function' && define.amd ? define('@rx-angular/cdk/internals/core', ['exports', '@angular/core', 'rxjs', 'rxjs/operators', '@rx-angular/cdk/coalescing'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global['rx-angular'] = global['rx-angular'] || {}, global['rx-angular'].cdk = global['rx-angular'].cdk || {}, global['rx-angular'].cdk.internals = global['rx-angular'].cdk.internals || {}, global['rx-angular'].cdk.internals.core = {}), global.ng.core, global.rxjs, global.rxjs.operators, global['rx-angular'].cdk.coalescing));
}(this, (function (exports, core, rxjs, operators, coalescing) { 'use strict';

    function getZoneUnPatchedApi(targetOrName, name) {
        // If the user has provided the API name as the first argument, for instance:
        // `const addEventListener = getZoneUnPatchedApi('addEventListener');`
        // Then we just swap arguments and make `global` or `window` as the default target.
        if (typeof targetOrName === 'string') {
            name = targetOrName;
            targetOrName = core.Éµglobal;
        }
        return targetOrName['__zone_symbol__' + name] || targetOrName[name];
    }

    /**
     * Creates an Observable that emits after a setTimeout.
     * The timeout it unpatched to not avoid zone pollution
     * @param setTimeoutFn
     */
    function timeout(delay) {
        if (delay === void 0) { delay = 0; }
        return new rxjs.Observable(function (subscriber) {
            var asyncID = getZoneUnPatchedApi('setTimeout')(function () { return subscriber.next(0); }, delay);
            return function () {
                getZoneUnPatchedApi('clearTimeout')(asyncID);
            };
        });
    }
    /**
     *
     */
    function timeoutSwitchMapWith() {
        return function (o$) { return o$.pipe(operators.concatMap(function (v) { return timeout().pipe(operators.mapTo(v)); })); };
    }

    var resolvedPromise = getZoneUnPatchedApi('Promise').resolve();
    var resolvedPromise$ = rxjs.from(resolvedPromise);
    /**
     * @internal
     *
     * Used for typing
     */
    function getEntriesToObjectReducerFn(keys) {
        return function (accumulator, currentValue, currentIndex) {
            var _a;
            return Object.assign(Object.assign({}, accumulator), (_a = {}, _a[keys[currentIndex]] = currentValue, _a));
        };
    }
    /**
     * This Observable creation function helps to accumulate an object of key & Observable of values to
     * an Observable of objects of key & value.
     * This comes in handy if you quickly want to create subsets as objects/state-slices of different Observables.
     *
     * The resulting Observable filters out undefined values forwards only distinct values and shared the aggregated output.
     *
     * @example
     *
     * Default usage:
     *
     * const object$: Observable<{
     *   prop1: number,
     *   prop2: string,
     *   prop3: string
     * }> = accumulateObservables({
     *   prop1: interval(42),
     *   prop2: of('lorem'),
     *   prop3: 'test'
     * });
     *
     * Usage with custom duration selector:
     *
     * const object$: Observable<{
     *   prop1: number,
     *   prop2: string,
     *   prop3: string
     * }> = accumulateObservables({
     *   prop1: interval(42),
     *   prop2: of('lorem'),
     *   prop3: 'test'
     * }, timer(0, 20));
     *
     * @param obj - An object of key & Observable values pairs
     * @param durationSelector - An Observable determining the duration for the internal coalescing method
     */
    function accumulateObservables(
    // @TODO type static or Observable to enable mixing of imperative and reatctive values
    obj, durationSelector) {
        if (durationSelector === void 0) { durationSelector = resolvedPromise$; }
        var keys = Object.keys(obj);
        // @TODO better typing to enable static values => coerceObservable(obj[key])
        var observables = keys.map(function (key) { return obj[key].pipe(
        // we avoid using the nullish operator later ;)
        operators.filter(function (v) { return v !== undefined; }), 
        // state "changes" differ from each other, this operator ensures distinct values
        operators.distinctUntilChanged()); });
        return rxjs.combineLatest(observables).pipe(
        // As combineLatest will emit multiple times for a change in multiple properties we coalesce those emissions
        // together
        coalescing.coalesceWith(durationSelector), 
        // mapping array of values to object
        operators.map(function (values) { return values.reduce(getEntriesToObjectReducerFn(keys), {}); }), 
        // by using shareReplay we share the last composition work done to create the accumulated object
        operators.shareReplay({ refCount: true, bufferSize: 1 }));
    }

    /**
     * Generated bundle index. Do not edit.
     */

    exports.accumulateObservables = accumulateObservables;
    exports.getZoneUnPatchedApi = getZoneUnPatchedApi;
    exports.timeoutSwitchMapWith = timeoutSwitchMapWith;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=cdk-internals-core.umd.js.map
