{"version":3,"file":"cdk-internals-core.js","sources":["../../../../libs/cdk/internals/core/src/lib/get-zone-unpatched-api.ts","../../../../libs/cdk/internals/core/src/lib/timeout.ts","../../../../libs/cdk/internals/core/src/lib/accumulateObservables.ts","../../../../libs/cdk/internals/core/src/cdk-internals-core.ts"],"sourcesContent":["import { ɵglobal } from '@angular/core';\n\n/**\n * @description\n *\n * This function returns the zone un-patched API for the a specific Browser API.\n * If no target is passed the window is used instead\n *\n * @param name - The name of the API to check.\n * @param target - The target to get un-patched API from.\n * @return {Function} - The zone un-patched API in question.\n *\n */\nexport function getZoneUnPatchedApi<\n  N extends keyof (Window & typeof globalThis)\n>(name: N): (Window & typeof globalThis)[N];\n\nexport function getZoneUnPatchedApi<T extends object, N extends keyof T>(\n  target: T,\n  name: N\n): T[N];\n\nexport function getZoneUnPatchedApi<T extends object, N extends keyof T>(\n  targetOrName: T | string,\n  name?: N\n) {\n  // If the user has provided the API name as the first argument, for instance:\n  // `const addEventListener = getZoneUnPatchedApi('addEventListener');`\n  // Then we just swap arguments and make `global` or `window` as the default target.\n  if (typeof targetOrName === 'string') {\n    name = targetOrName as N;\n    targetOrName = ɵglobal as T;\n  }\n  return targetOrName['__zone_symbol__' + name] || targetOrName[name];\n}\n","import { Observable, Subscriber } from 'rxjs';\nimport { mapTo, concatMap } from 'rxjs/operators';\nimport { getZoneUnPatchedApi } from './get-zone-unpatched-api';\n\n/**\n * Creates an Observable that emits after a setTimeout.\n * The timeout it unpatched to not avoid zone pollution\n * @param setTimeoutFn\n */\nfunction timeout(\n  delay: number = 0\n) {\n  return new Observable<number>((subscriber: Subscriber<number>) => {\n    const asyncID = getZoneUnPatchedApi('setTimeout')(() => subscriber.next(0), delay);\n    return () => {\n      getZoneUnPatchedApi('clearTimeout')(asyncID);\n    };\n  });\n}\n\n/**\n *\n */\nexport function timeoutSwitchMapWith<T>() {\n  return (o$: Observable<T>) => o$.pipe(\n    concatMap((v) => timeout().pipe(mapTo(v)))\n  )\n}\n","import { coalesceWith } from '@rx-angular/cdk/coalescing';\nimport { combineLatest, from, Observable } from 'rxjs';\nimport { distinctUntilChanged, filter, map, shareReplay } from 'rxjs/operators';\nimport {\n  ArrayReducerFn,\n  ExtractObservableValue,\n  NotEmpty,\n  ObservableMap,\n  PropName,\n  PropType,\n} from './model';\nimport { getZoneUnPatchedApi } from './get-zone-unpatched-api';\n\nconst resolvedPromise = getZoneUnPatchedApi('Promise').resolve();\nconst resolvedPromise$ = from(resolvedPromise);\n\n/**\n * @internal\n *\n * Used for typing\n */\nfunction getEntriesToObjectReducerFn<T extends Record<string, any>>(\n  keys: PropName<T>[]\n): ArrayReducerFn<T> {\n  return (\n    accumulator: T,\n    currentValue?: PropType<T>,\n    currentIndex?: number\n  ): T => {\n    return {\n      ...accumulator,\n      [keys[currentIndex]]: currentValue,\n    };\n  };\n}\n\n/**\n * This Observable creation function helps to accumulate an object of key & Observable of values to\n * an Observable of objects of key & value.\n * This comes in handy if you quickly want to create subsets as objects/state-slices of different Observables.\n *\n * The resulting Observable filters out undefined values forwards only distinct values and shared the aggregated output.\n *\n * @example\n *\n * Default usage:\n *\n * const object$: Observable<{\n *   prop1: number,\n *   prop2: string,\n *   prop3: string\n * }> = accumulateObservables({\n *   prop1: interval(42),\n *   prop2: of('lorem'),\n *   prop3: 'test'\n * });\n *\n * Usage with custom duration selector:\n *\n * const object$: Observable<{\n *   prop1: number,\n *   prop2: string,\n *   prop3: string\n * }> = accumulateObservables({\n *   prop1: interval(42),\n *   prop2: of('lorem'),\n *   prop3: 'test'\n * }, timer(0, 20));\n *\n * @param obj - An object of key & Observable values pairs\n * @param durationSelector - An Observable determining the duration for the internal coalescing method\n */\nexport function accumulateObservables<T extends ObservableMap & NotEmpty<T>>(\n  // @TODO type static or Observable to enable mixing of imperative and reatctive values\n  obj: T,\n  durationSelector: Observable<any> = resolvedPromise$\n): Observable<{ [K in keyof T]: ExtractObservableValue<T[K]> }> {\n  const keys = Object.keys(obj) as (keyof T)[];\n  // @TODO better typing to enable static values => coerceObservable(obj[key])\n  const observables = keys.map((key) =>\n    obj[key].pipe(\n      // we avoid using the nullish operator later ;)\n      filter((v) => v !== undefined),\n      // state \"changes\" differ from each other, this operator ensures distinct values\n      distinctUntilChanged()\n    )\n  );\n  return combineLatest(observables).pipe(\n    // As combineLatest will emit multiple times for a change in multiple properties we coalesce those emissions\n    // together\n    coalesceWith(durationSelector),\n    // mapping array of values to object\n    map((values) =>\n      values.reduce(getEntriesToObjectReducerFn(keys), {} as any)\n    ),\n    // by using shareReplay we share the last composition work done to create the accumulated object\n    shareReplay({refCount: true, bufferSize: 1})\n  );\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":";;;;;SAsBgB,mBAAmB,CACjC,YAAwB,EACxB,IAAQ;;;;IAKR,IAAI,OAAO,YAAY,KAAK,QAAQ,EAAE;QACpC,IAAI,GAAG,YAAiB,CAAC;QACzB,YAAY,GAAG,OAAY,CAAC;KAC7B;IACD,OAAO,YAAY,CAAC,iBAAiB,GAAG,IAAI,CAAC,IAAI,YAAY,CAAC,IAAI,CAAC,CAAC;AACtE;;AC9BA;;;;;AAKA,SAAS,OAAO,CACd,QAAgB,CAAC;IAEjB,OAAO,IAAI,UAAU,CAAS,CAAC,UAA8B;QAC3D,MAAM,OAAO,GAAG,mBAAmB,CAAC,YAAY,CAAC,CAAC,MAAM,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;QACnF,OAAO;YACL,mBAAmB,CAAC,cAAc,CAAC,CAAC,OAAO,CAAC,CAAC;SAC9C,CAAC;KACH,CAAC,CAAC;AACL,CAAC;AAED;;;SAGgB,oBAAoB;IAClC,OAAO,CAAC,EAAiB,KAAK,EAAE,CAAC,IAAI,CACnC,SAAS,CAAC,CAAC,CAAC,KAAK,OAAO,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAC3C,CAAA;AACH;;ACdA,MAAM,eAAe,GAAG,mBAAmB,CAAC,SAAS,CAAC,CAAC,OAAO,EAAE,CAAC;AACjE,MAAM,gBAAgB,GAAG,IAAI,CAAC,eAAe,CAAC,CAAC;AAE/C;;;;;AAKA,SAAS,2BAA2B,CAClC,IAAmB;IAEnB,OAAO,CACL,WAAc,EACd,YAA0B,EAC1B,YAAqB;QAErB,uCACK,WAAW,KACd,CAAC,IAAI,CAAC,YAAY,CAAC,GAAG,YAAY,IAClC;KACH,CAAC;AACJ,CAAC;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SAoCgB,qBAAqB;AACnC;AACA,GAAM,EACN,mBAAoC,gBAAgB;IAEpD,MAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,CAAgB,CAAC;;IAE7C,MAAM,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,KAC/B,GAAG,CAAC,GAAG,CAAC,CAAC,IAAI;;IAEX,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,SAAS,CAAC;;IAE9B,oBAAoB,EAAE,CACvB,CACF,CAAC;IACF,OAAO,aAAa,CAAC,WAAW,CAAC,CAAC,IAAI;;;IAGpC,YAAY,CAAC,gBAAgB,CAAC;;IAE9B,GAAG,CAAC,CAAC,MAAM,KACT,MAAM,CAAC,MAAM,CAAC,2BAA2B,CAAC,IAAI,CAAC,EAAE,EAAS,CAAC,CAC5D;;IAED,WAAW,CAAC,EAAC,QAAQ,EAAE,IAAI,EAAE,UAAU,EAAE,CAAC,EAAC,CAAC,CAC7C,CAAC;AACJ;;AClGA;;;;;;"}