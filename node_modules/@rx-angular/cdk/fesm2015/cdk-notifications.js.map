{"version":3,"file":"cdk-notifications.js","sources":["../../../../libs/cdk/notifications/src/lib/notification-transforms.ts","../../../../libs/cdk/notifications/src/lib/template-trigger-handling.ts","../../../../libs/cdk/notifications/src/lib/rx-materialize.ts","../../../../libs/cdk/notifications/src/lib/create-template-notifier.ts","../../../../libs/cdk/notifications/src/cdk-notifications.ts"],"sourcesContent":["import {\n  RxSuspenseNotification,\n  RxNotificationKind,\n  RxErrorNotification,\n  RxCompleteNotification,\n} from './model';\n\nexport function toRxErrorNotification<T>(\n  error?: any,\n  value?: T\n): RxErrorNotification<T> {\n  return {\n    value,\n    kind: RxNotificationKind.Error,\n    hasValue: !!value || false,\n    complete: false,\n    error: error || true,\n  };\n}\n\nexport function toRxSuspenseNotification<T>(\n  value?: T\n): RxSuspenseNotification<T> {\n  return {\n    value,\n    kind: RxNotificationKind.Suspense,\n    hasValue: !!value || false,\n    complete: false,\n    error: false,\n  };\n}\n\nexport function toRxCompleteNotification<T>(\n  value?: T\n): RxCompleteNotification<T> {\n  return {\n    value,\n    kind: RxNotificationKind.Complete,\n    hasValue: !!value || false,\n    complete: true,\n    error: false,\n  };\n}\n","import { Observable, Subject } from 'rxjs';\nimport { mergeAll, share } from 'rxjs/operators';\n\nimport { coerceAllFactory } from '@rx-angular/cdk/coercing';\n\nimport { RxNotification } from './model';\n\n/**\n * @internal\n *\n * A factory function returning an object to handle the process of switching templates by Notification channel.\n * You can next a Observable of `RxNotification` multiple times and merge them into the Observable exposed under `trigger$`\n *\n */\nexport function templateTriggerHandling<T>(): {\n  trigger$: Observable<RxNotification<T>>;\n  next(templateName: Observable<RxNotification<T>>): void;\n} {\n  const hotFlattened = coerceAllFactory(\n    () => new Subject<Observable<RxNotification<T> | RxNotification<T>>>(),\n    mergeAll()\n  );\n  return {\n    next(templateName: Observable<RxNotification<T> | RxNotification<T>>) {\n      hotFlattened.next(templateName);\n    },\n    trigger$: hotFlattened.values$.pipe(share()),\n  };\n}\n","import { OperatorFunction, Notification } from 'rxjs';\nimport { map, materialize, tap } from 'rxjs/operators';\n\nimport { RxNotification, RxNotificationKind } from './model';\n\nexport function rxMaterialize<T>(): OperatorFunction<T, RxNotification<T>> {\n  return (o$) =>\n    o$.pipe(\n      materialize(),\n      tap(({ kind, error }) => {\n        // As we dont want to just swallow errors we log them here\n        if (kind === 'E') {\n          console.error(error);\n        }\n      }),\n      map(({ value, error, kind, hasValue }) => {\n        const rxNotificationKind = notificationKindToRxNotificationKind(kind);\n        return {\n          value,\n          hasValue,\n          error,\n          kind: rxNotificationKind,\n          complete: rxNotificationKind === RxNotificationKind.Complete,\n        };\n      })\n    );\n}\n\n/**\n * @internal\n *\n * @description\n * This function is here to turn RxJS notification kind values into RxNotification kind names.\n * The main reason for the naming is the RxNotification kind values map directly to the default\n * template names (`suspense`, `next`, `error` `complete`) in the directives of the template package\n */\nexport function notificationKindToRxNotificationKind(\n  kind: Notification<unknown>['kind']\n): RxNotificationKind {\n  switch (kind) {\n    case 'C':\n      return RxNotificationKind.Complete;\n    case 'E':\n      return RxNotificationKind.Error;\n    case 'N':\n    default:\n      return RxNotificationKind.Next;\n  }\n}\n","import {\n  from,\n  isObservable,\n  NEVER,\n  Observable,\n  ObservableInput,\n  ReplaySubject,\n} from 'rxjs';\nimport {\n  distinctUntilChanged,\n  map,\n  startWith,\n  switchMap,\n  tap,\n} from 'rxjs/operators';\n\nimport { rxMaterialize } from './rx-materialize';\nimport { RxNotification, RxNotificationKind } from './model';\nimport { toRxSuspenseNotification } from './notification-transforms';\n\n/**\n * @description\n * Sends value and an initial `undefined` as value With a NEVER.\n * This is needed to render the suspense template and avoid completing (and render the complete template).\n * @param value\n */\nconst emitAndDontComplete = (value) => NEVER.pipe(startWith(value));\n\n/**\n * This helper is responsible for turning a stream of materialized notifications\n * (next error, complete as object in the next stream) into an enriched version with an additional suspense\n * notification type.\n *\n * If a notification enters and is of type next we store tne value of `notification.next` as last value emitted.\n * This value is important in the template to show an e.g. error and also have access to the last emitted value of\n * next.\n * The value can be very useful in error or complete messages or to display the old value overlays by a loading spinner\n * in case of the suspense state.\n *\n * If a notification of kind `next` enters and its value is undefined we turn it into a suspense notification\n * If a notification of kind `error`, `complete`, `suspense` enters we take the last value from of a next notification\n * and assign it as new value to the notification\n */\nconst handleSuspenseAndLastValueInNotifications = <T>() => {\n  // Used to store the last value per handleSuspenseAndLastValueInNotifications call\n  let latestNextValue: T;\n\n  // returns a projection function with a lastValue cache\n  return (notification: RxNotification<T>): RxNotification<T> => {\n    // if it is the notification is of type next we take its value\n    // otherwise we keep the existing last value\n    if (notification.kind === RxNotificationKind.Next) {\n      latestNextValue = notification.value;\n    }\n\n    // If a next notification enters with a value of undefined we turn it into a suspense notification\n    if (\n      notification.kind === RxNotificationKind.Next &&\n      notification.value === undefined\n    ) {\n      return toRxSuspenseNotification(undefined) as RxNotification<T>;\n    }\n\n    // If a Notification of type error, complete or suspense enters we assign the latest last value to them.\n    // This is needed to access the old value in case of error or complete.\n    // Next notifications will pass as they are.\n    if (\n      notification.kind === RxNotificationKind.Error ||\n      notification.kind === RxNotificationKind.Complete ||\n      notification.kind === RxNotificationKind.Suspense\n    ) {\n      notification.value = latestNextValue;\n    }\n\n    return notification as RxNotification<T>;\n  };\n};\n\n/**\n * @internal\n *\n * @description\n * This factory function returns an object that can be driven imperatively over a `next` method.\n * Internally it prepares the incoming values for rendering by turning them into \"template notifications\",\n * an extended `ObservableNotification` object used to determine the respective template for values, errors, completing\n *   or suspense states.\n *\n * Internally it handles different edge cases for initial emits. This helps to have or template creation lazy.\n * Also it maps any Observable to RxNotifications. These notifications are bound to the view later and handle the\n *   display of the default template as well as the suspense, error, complete templates.\n */\nexport function createTemplateNotifier<U>(): {\n  values$: Observable<RxNotification<U>>;\n  next(observable: ObservableInput<U> | U): void;\n  withInitialSuspense(withInitialSuspense: boolean): void;\n} {\n  // A Subject driven from the outside, it can contain Observables, static values null and undefined on purpose of from unassigned properties\n  const observablesSubject = new ReplaySubject<ObservableInput<U> | U>(1);\n\n  let emittedValueOnce = false;\n\n  const values$ = observablesSubject.pipe(\n    distinctUntilChanged(),\n    // handle static values inc null assignment and new Observable or Promises\n    map((observable$): ObservableInput<U> | U => {\n      if (isObservableInput(observable$)) {\n        return skipSuspenseIfHasValue(observable$);\n      } else if (!emittedValueOnce && observable$ === undefined) {\n        return NEVER;\n      }\n      return emitAndDontComplete(observable$);\n    }),\n    switchMap((o: Observable<U>) => {\n      return o.pipe(\n        tap(() => (emittedValueOnce = true)),\n        distinctUntilChanged(),\n        rxMaterialize(),\n        map(handleSuspenseAndLastValueInNotifications<U>())\n      );\n    })\n  );\n\n  return {\n    next(observable: ObservableInput<U> | U) {\n      observablesSubject.next(observable);\n    },\n    withInitialSuspense(withInitialSuspense: boolean) {\n      emittedValueOnce = emittedValueOnce || withInitialSuspense;\n    },\n    values$,\n  };\n\n  /**\n   * @description\n   * returns an observable that starts with an undefined value in case the input\n   * observable$ does not emit a value immediately.\n   * This is needed in order to skip the suspense template when we already know\n   * there will be a next template rendered afterwards\n   * @param observable$\n   */\n  function skipSuspenseIfHasValue<T>(\n    observable$: ObservableInput<T>\n  ): Observable<T> {\n    return new Observable((subscriber) => {\n      let startWithUndefined = true;\n      const inner = from(observable$).subscribe({\n        next: (v) => {\n          startWithUndefined = false;\n          subscriber.next(v);\n        },\n        error: (e) => {\n          startWithUndefined = false;\n          subscriber.error(e);\n        },\n        complete: () => subscriber.complete(),\n      });\n      if (emittedValueOnce && startWithUndefined) {\n        subscriber.next(undefined);\n      }\n      return () => {\n        inner.unsubscribe();\n      };\n    });\n  }\n}\n\nfunction isObservableInput<T>(input: unknown): input is ObservableInput<T> {\n  return (\n    typeof (input as Promise<T>)?.then === 'function' || isObservable(input)\n  );\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":"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"}