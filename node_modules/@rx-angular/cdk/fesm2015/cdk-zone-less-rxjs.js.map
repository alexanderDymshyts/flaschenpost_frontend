{"version":3,"file":"cdk-zone-less-rxjs.js","sources":["../../../../libs/cdk/zone-less/rxjs/src/internals/intervalProvider.ts","../../../../libs/cdk/zone-less/rxjs/src/scheduler/Action.ts","../../../../libs/cdk/zone-less/rxjs/src/scheduler/async/AsyncAction.ts","../../../../libs/cdk/zone-less/rxjs/src/internals/date-time-stamp.provider.ts","../../../../libs/cdk/zone-less/rxjs/src/scheduler/scheduler.ts","../../../../libs/cdk/zone-less/rxjs/src/scheduler/async/AsyncScheduler.ts","../../../../libs/cdk/zone-less/rxjs/src/scheduler/async/async.ts","../../../../libs/cdk/zone-less/rxjs/src/observable/utils.ts","../../../../libs/cdk/zone-less/rxjs/src/observable/interval.ts","../../../../libs/cdk/zone-less/rxjs/src/observable/timer.ts","../../../../libs/cdk/zone-less/rxjs/src/observable/fromEvent.ts","../../../../libs/cdk/zone-less/rxjs/src/internals/Immediate.ts","../../../../libs/cdk/zone-less/rxjs/src/internals/immediateProvider.ts","../../../../libs/cdk/zone-less/rxjs/src/scheduler/asap/AsapAction.ts","../../../../libs/cdk/zone-less/rxjs/src/scheduler/asap/AsapScheduler.ts","../../../../libs/cdk/zone-less/rxjs/src/scheduler/asap/asap.ts","../../../../libs/cdk/zone-less/rxjs/src/scheduler/queue/QueueAction.ts","../../../../libs/cdk/zone-less/rxjs/src/scheduler/queue/QueueScheduler.ts","../../../../libs/cdk/zone-less/rxjs/src/scheduler/queue/queue.ts","../../../../libs/cdk/zone-less/rxjs/src/internals/animationFrameProvider.ts","../../../../libs/cdk/zone-less/rxjs/src/scheduler/animation-frame/AnimationFrameAction.ts","../../../../libs/cdk/zone-less/rxjs/src/scheduler/animation-frame/AnimationFrameScheduler.ts","../../../../libs/cdk/zone-less/rxjs/src/scheduler/animation-frame/animationFrame.ts","../../../../libs/cdk/zone-less/rxjs/src/cdk-zone-less-rxjs.ts"],"sourcesContent":["import { setInterval } from '@rx-angular/cdk/zone-less/browser';\n\ntype SetIntervalFunction = (\n  handler: () => void,\n  timeout?: number,\n  ...args: any[]\n) => number;\ntype ClearIntervalFunction = (handle: number) => void;\n\ninterface IntervalProvider {\n  setInterval: SetIntervalFunction;\n  clearInterval: ClearIntervalFunction;\n  delegate?: Omit<IntervalProvider, 'delegate'>;\n}\n\nexport const intervalProvider: IntervalProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setInterval(handler: () => void, timeout?: number, ...args) {\n    const { delegate } = intervalProvider;\n    if (delegate?.setInterval) {\n      return delegate.setInterval(handler, timeout, ...args);\n    }\n    return setInterval(handler, timeout);\n  },\n  clearInterval(handle) {\n    const { delegate } = intervalProvider;\n    return (delegate?.clearInterval || clearInterval)(handle as any);\n  },\n};\n","import { Subscription } from 'rxjs';\nimport { Scheduler } from './scheduler';\nimport { SchedulerAction } from './types';\n\n/**\n * A unit of work to be executed in a `scheduler`. An action is typically\n * created from within a {@link SchedulerLike} and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\nexport class Action<T> extends Subscription {\n  constructor(\n    scheduler: Scheduler,\n    work: (this: SchedulerAction<T>, state?: T) => void\n  ) {\n    super();\n  }\n  /**\n   * Schedules this action on its parent {@link SchedulerLike} for execution. May be passed\n   * some context object, `state`. May happen at some point in the future,\n   * according to the `delay` parameter, if specified.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler.\n   * @return {void}\n   */\n  public schedule(state?: T, delay: number = 0): Subscription {\n    return this;\n  }\n}\n","import { intervalProvider } from '../../internals/intervalProvider';\nimport { Subscription } from 'rxjs';\nimport { Action } from '../Action';\nimport { SchedulerAction } from '../types';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class AsyncAction<T> extends Action<T> {\n  public id: any;\n  public state?: T;\n  // @ts-ignore: Property has no initializer and is not definitely assigned\n  public delay: number;\n  protected pending = false;\n\n  constructor(\n    protected scheduler: AsyncScheduler,\n    protected work: (this: SchedulerAction<T>, state?: T) => void\n  ) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (this.closed) {\n      return this;\n    }\n\n    // Always replace the current state with the new state.\n    this.state = state;\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n\n    //\n    // Important implementation note:\n    //\n    // Actions only execute once by default, unless rescheduled from within the\n    // scheduled callback. This allows us to implement single and repeat\n    // actions via the same code path, without adding API surface area, as well\n    // as mimic traditional recursion but across asynchronous boundaries.\n    //\n    // However, JS runtimes and timers distinguish between intervals achieved by\n    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n    // serial `setTimeout` calls can be individually delayed, which delays\n    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n    // guarantee the interval callback will be invoked more precisely to the\n    // interval period, regardless of load.\n    //\n    // Therefore, we use `setInterval` to schedule single and repeat actions.\n    // If the action reschedules itself with the same delay, the interval is not\n    // canceled. If the action doesn't reschedule, or reschedules with a\n    // different delay, the interval will be canceled after scheduled callback\n    // execution.\n    //\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    // Set the pending flag indicating that this action has been scheduled, or\n    // has recursively rescheduled itself.\n    this.pending = true;\n\n    this.delay = delay;\n    // If this action has already an async Id, don't request a new one.\n    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n\n    return this;\n  }\n\n  protected requestAsyncId(\n    scheduler: AsyncScheduler,\n    id?: any,\n    delay: number = 0\n  ): any {\n    return intervalProvider.setInterval(\n      scheduler.flush.bind(scheduler, this),\n      delay\n    );\n  }\n\n  protected recycleAsyncId(\n    scheduler: AsyncScheduler,\n    id: any,\n    delay: number | null = 0\n  ): any {\n    // If this action is rescheduled with the same delay time, don't clear the interval id.\n    if (delay != null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n    // Otherwise, if the action's delay time is different from the current delay,\n    // or the action has been rescheduled before it's executed, clear the interval id\n    intervalProvider.clearInterval(id);\n    return undefined;\n  }\n\n  /**\n   * Immediately executes this action and the `work` it contains.\n   * @return {any}\n   */\n  public execute(state: T, delay: number): any {\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n    const error = this._execute(state, delay);\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      // Dequeue if the action didn't reschedule itself. Don't call\n      // unsubscribe(), because the action could reschedule later.\n      // For example:\n      // ```\n      // scheduler.schedule(function doWork(counter) {\n      //   /* ... I'm a busy worker bee ... */\n      //   var originalAction = this;\n      //   /* wait 100ms before rescheduling the action */\n      //   setTimeout(function () {\n      //     originalAction.schedule(counter + 1);\n      //   }, 100);\n      // }, 1000);\n      // ```\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  }\n\n  protected _execute(state: T, delay: number): any {\n    let errored = false;\n    let errorValue: any;\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      errorValue = (!!e && e) || new Error(e);\n    }\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  }\n\n  unsubscribe() {\n    if (!this.closed) {\n      const { id, scheduler } = this;\n      const { actions } = scheduler;\n\n      this.work = this.state = this.scheduler = null!;\n      this.pending = false;\n\n      // arrRemove\n      if (actions) {\n        const index = actions.indexOf(this);\n        0 <= index && actions.splice(index, 1);\n      }\n      if (id != null) {\n        this.id = this.recycleAsyncId(scheduler, id, null);\n      }\n\n      this.delay = null!;\n      super.unsubscribe();\n    }\n  }\n}\n","interface DateTimestampProvider {\n  delegate?: DateTimestampProvider;\n  now(): number;\n}\n\nexport const dateTimestampProvider: DateTimestampProvider = {\n  now() {\n    return (dateTimestampProvider.delegate || Date).now();\n  },\n};\n","import { dateTimestampProvider } from '../internals/date-time-stamp.provider';\nimport { Subscription } from 'rxjs';\nimport { Action } from './Action';\nimport { SchedulerLike, SchedulerAction } from './types';\n\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an `Action`.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n * @deprecated Scheduler is an internal implementation detail of RxJS, and\n * should not be used directly. Rather, create your own class and implement\n * {@link SchedulerLike}. Will be made internal in v8.\n */\nexport class Scheduler implements SchedulerLike {\n  public static now: () => number = dateTimestampProvider.now;\n\n  constructor(\n    private schedulerActionCtor: typeof Action,\n    now: () => number = Scheduler.now\n  ) {\n    this.now = now;\n  }\n\n  /**\n   * A getter method that returns a number representing the current time\n   * (at the time this function was called) according to the scheduler's own\n   * internal clock.\n   * @return {number} A number that represents the current time. May or may not\n   * have a relation to wall-clock time. May or may not refer to a time unit\n   * (e.g. milliseconds).\n   */\n  public now: () => number;\n\n  /**\n   * Schedules a function, `work`, for execution. May happen at some point in\n   * the future, according to the `delay` parameter, if specified. May be passed\n   * some context object, `state`, which will be passed to the `work` function.\n   *\n   * The given arguments will be processed an stored as an Action object in a\n   * queue of actions.\n   *\n   * @param {function(state: ?T): ?Subscription} work A function representing a\n   * task, or some unit of work to be executed by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler itself.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @return {Subscription} A subscription in order to be able to unsubscribe\n   * the scheduled work.\n   */\n  public schedule<T>(\n    work: (this: SchedulerAction<T>, state?: T) => void,\n    delay: number = 0,\n    state?: T\n  ): Subscription {\n    return new this.schedulerActionCtor<T>(this, work).schedule(state, delay);\n  }\n}\n","import { Action } from '../Action';\nimport { AsyncAction } from './AsyncAction';\nimport { Scheduler } from '../scheduler';\n\nexport class AsyncScheduler extends Scheduler {\n  actions: Array<AsyncAction<any>> = [];\n  /**\n   * A flag to indicate whether the Scheduler is currently executing a batch of\n   * queued actions.\n   * @type {boolean}\n   * @internal\n   */\n  _active = false;\n\n  /**\n   * An internal ID used to track the latest asynchronous task such as those\n   * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n   * others.\n   * @type {any}\n   * @internal\n   */\n  _scheduled?: any = undefined;\n\n  constructor(\n    SchedulerAction: typeof Action,\n    now: () => number = Scheduler.now\n  ) {\n    super(SchedulerAction, now);\n  }\n\n  public flush(action: AsyncAction<any>): void {\n    const { actions } = this;\n\n    if (this._active) {\n      actions.push(action);\n      return;\n    }\n\n    let error: any;\n    this._active = true;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions.shift()!)); // exhaust the scheduler queue\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions.shift()!)) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n","import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n *\n * NOTE: This is a zone un-patched version of rxjs asyncScheduler\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asapScheduler} scheduler.\n *\n * ## Examples\n * Use async scheduler to delay task\n * ```ts\n * import { asyncScheduler } from '@cu/perf-utils';\n *\n * const task = () => console.log('it works!');\n *\n * asyncScheduler.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n * ```\n *\n * Use async scheduler to repeat task in intervals\n * ```ts\n * import { asyncScheduler } from '@cu/perf-utils';\n *\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * asyncScheduler.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n * ```\n * @deprecated will be removed with 1.0.0\n */\nexport const asyncScheduler = new AsyncScheduler(AsyncAction);\n","import { SchedulerLike } from 'rxjs';\n\nexport function isNumeric(val: any): val is number | string {\n  // parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n  // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n  // subtraction forces infinities to NaN\n  // adding 1 corrects loss of precision from parseFloat (#15100)\n  return !Array.isArray(val) && val - parseFloat(val) + 1 >= 0;\n}\n\nexport function isScheduler(value: any): value is SchedulerLike {\n  return value && typeof (<any>value).schedule === 'function';\n}\n","import { Observable, SchedulerAction, SchedulerLike, Subscriber } from 'rxjs';\nimport { asyncScheduler } from '../scheduler/async/async';\nimport { isNumeric } from './utils';\n\n/**\n * Creates an Observable that emits sequential numbers every specified\n * interval of time, on a specified {@link SchedulerLike}.\n *\n * <span class=\"informal\">Emits incremental numbers periodically in time.\n * </span>\n *\n * ![](interval.png)\n *\n * `interval` returns an Observable that emits an infinite sequence of\n * ascending integers, with a constant interval of time of your choosing\n * between those emissions. The first emission is not sent immediately, but\n * only after the first period has passed. By default, this operator uses the\n * `async` {@link SchedulerLike} to provide a notion of time, but you may pass any\n * {@link SchedulerLike} to it.\n *\n * ## Example\n * Emits ascending numbers, one every second (1000ms) up to the number 3\n * ```ts\n * import { interval } from 'rxjs';\n * import { take } from 'rxjs/operators';\n *\n * const numbers = interval(1000);\n *\n * const takeFourNumbers = numbers.pipe(take(4));\n *\n * takeFourNumbers.subscribe(x => console.log('Next: ', x));\n *\n * // Logs:\n * // Next: 0\n * // Next: 1\n * // Next: 2\n * // Next: 3\n * ```\n *\n * @see {@link timer}\n * @see {@link delay}\n *\n * @param {number} [period=0] The interval size in milliseconds (by default)\n * or the time unit determined by the scheduler's clock.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for scheduling\n * the emission of values, and providing a notion of \"time\".\n * @return {Observable} An Observable that emits a sequential number each time\n * interval.\n * @static true\n * @deprecated will be removed with 1.0.0\n * @name interval\n * @owner Observable\n */\nexport function interval(\n  period = 0,\n  scheduler: SchedulerLike = asyncScheduler\n): Observable<number> {\n  if (!isNumeric(period) || period < 0) {\n    period = 0;\n  }\n\n  if (!scheduler || typeof scheduler.schedule !== 'function') {\n    scheduler = asyncScheduler;\n  }\n\n  return new Observable<number>((subscriber) => {\n    subscriber.add(\n      scheduler.schedule(dispatch, period, { subscriber, counter: 0, period })\n    );\n    return subscriber;\n  });\n}\n\nfunction dispatch(this: SchedulerAction<IntervalState>, state: IntervalState) {\n  const { subscriber, counter, period } = state;\n  subscriber.next(counter);\n  this.schedule({ subscriber, counter: counter + 1, period }, period);\n}\n\ninterface IntervalState {\n  subscriber: Subscriber<number>;\n  counter: number;\n  period: number;\n}\n","import { Observable, SchedulerAction, SchedulerLike, Subscriber } from 'rxjs';\nimport { asyncScheduler } from '../scheduler/async/async';\nimport { isNumeric, isScheduler } from './utils';\n\n/**\n * Creates an Observable that starts emitting after an `dueTime` and\n * emits ever increasing numbers after each `period` of time thereafter.\n *\n * <span class=\"informal\">Its like {@link index/interval}, but you can specify when\n * should the emissions start.</span>\n *\n * ![](timer.png)\n *\n * `timer` returns an Observable that emits an infinite sequence of ascending\n * integers, with a constant interval of time, `period` of your choosing\n * between those emissions. The first emission happens after the specified\n * `dueTime`. The initial delay may be a `Date`. By default, this\n * operator uses the {@link asyncScheduler} {@link SchedulerLike} to provide a notion of time, but you\n * may pass any {@link SchedulerLike} to it. If `period` is not specified, the output\n * Observable emits only one value, `0`. Otherwise, it emits an infinite\n * sequence.\n *\n * ## Examples\n * ### Emits ascending numbers, one every second (1000ms), starting after 3 seconds\n * ```ts\n * import { timer } from 'rxjs';\n *\n * const numbers = timer(3000, 1000);\n * numbers.subscribe(x => console.log(x));\n * ```\n *\n * ### Emits one number after five seconds\n * ```ts\n * import { timer } from 'rxjs';\n *\n * const numbers = timer(5000);\n * numbers.subscribe(x => console.log(x));\n * ```\n * @see {@link index/interval}\n * @see {@link delay}\n *\n * @param {number|Date} [dueTime] The initial delay time specified as a Date object or as an integer denoting\n * milliseconds to wait before emitting the first value of 0`.\n * @param {number|SchedulerLike} [periodOrScheduler] The period of time between emissions of the\n * subsequent numbers.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for scheduling\n * the emission of values, and providing a notion of \"time\".\n * @return {Observable} An Observable that emits a `0` after the\n * `dueTime` and ever increasing numbers after each `period` of time\n * thereafter.\n * @static true\n * @deprecated will be removed with 1.0.0\n * @name timer\n * @owner Observable\n */\nexport function timer(\n  dueTime: number | Date = 0,\n  periodOrScheduler?: number | SchedulerLike,\n  scheduler?: SchedulerLike\n): Observable<number> {\n  let period = -1;\n  if (isNumeric(periodOrScheduler)) {\n    period = (Number(periodOrScheduler) < 1 && 1) || Number(periodOrScheduler);\n  } else if (isScheduler(periodOrScheduler)) {\n    scheduler = periodOrScheduler as any;\n  }\n\n  if (!isScheduler(scheduler)) {\n    scheduler = asyncScheduler;\n  }\n\n  return new Observable((subscriber) => {\n    const due = isNumeric(dueTime)\n      ? (dueTime as number)\n      : +dueTime - scheduler.now();\n\n    return scheduler.schedule(dispatch, due, {\n      index: 0,\n      period,\n      subscriber,\n    });\n  });\n}\n\ninterface TimerState {\n  index: number;\n  period: number;\n  subscriber: Subscriber<number>;\n}\n\nfunction dispatch(this: SchedulerAction<TimerState>, state: TimerState) {\n  const { index, period, subscriber } = state;\n  subscriber.next(index);\n\n  if (subscriber.closed) {\n    return;\n  } else if (period === -1) {\n    return subscriber.complete();\n  }\n\n  state.index = index + 1;\n  this.schedule(state, period);\n}\n","import { Observable, Subscriber } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { getZoneUnPatchedApi } from '@rx-angular/cdk/internals/core';\n\n// @ts-ignore\nconst isFunction = (fn) => typeof fn === 'function';\nconst isArray = Array.isArray;\nconst toString: Function = (() => Object.prototype.toString)();\n\nexport interface NodeStyleEventEmitter {\n  addListener: (eventName: string | symbol, handler: NodeEventHandler) => this;\n  removeListener: (\n    eventName: string | symbol,\n    handler: NodeEventHandler\n  ) => this;\n}\n\nexport type NodeEventHandler = (...args: any[]) => void;\n\n// For APIs that implement `addListener` and `removeListener` methods that may\n// not use the same arguments or return EventEmitter values\n// such as React Native\nexport interface NodeCompatibleEventEmitter {\n  addListener: (eventName: string, handler: NodeEventHandler) => void | {};\n  removeListener: (eventName: string, handler: NodeEventHandler) => void | {};\n}\n\nexport interface JQueryStyleEventEmitter {\n  on: (eventName: string, handler: Function) => void;\n  off: (eventName: string, handler: Function) => void;\n}\n\nexport interface HasEventTargetAddRemove<E> {\n  addEventListener(\n    type: string,\n    listener: ((evt: E) => void) | null,\n    options?: boolean | AddEventListenerOptions\n  ): void;\n  removeEventListener(\n    type: string,\n    listener?: ((evt: E) => void) | null,\n    options?: EventListenerOptions | boolean\n  ): void;\n}\n\nexport type EventTargetLike<T> =\n  | HasEventTargetAddRemove<T>\n  | NodeStyleEventEmitter\n  | NodeCompatibleEventEmitter\n  | JQueryStyleEventEmitter;\n\nexport type FromEventTarget<T> =\n  | EventTargetLike<T>\n  | ArrayLike<EventTargetLike<T>>;\n\nexport interface EventListenerOptions {\n  capture?: boolean;\n  passive?: boolean;\n  once?: boolean;\n}\n\nexport interface AddEventListenerOptions extends EventListenerOptions {\n  once?: boolean;\n  passive?: boolean;\n}\n\n/** @deprecated will be removed with 1.0.0 */\nexport function fromEvent<T>(\n  target: FromEventTarget<T>,\n  eventName: string\n): Observable<T>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function fromEvent<T>(\n  target: FromEventTarget<T>,\n  eventName: string,\n  resultSelector: (...args: any[]) => T\n): Observable<T>;\n/** @deprecated will be removed with 1.0.0 */\nexport function fromEvent<T>(\n  target: FromEventTarget<T>,\n  eventName: string,\n  options: EventListenerOptions\n): Observable<T>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function fromEvent<T>(\n  target: FromEventTarget<T>,\n  eventName: string,\n  options: EventListenerOptions,\n  resultSelector: (...args: any[]) => T\n): Observable<T>;\n/** @deprecated will be removed with 1.0.0 */\nexport function fromEvent<T>(\n  target: FromEventTarget<T>,\n  eventName: string,\n  options?: EventListenerOptions | ((...args: any[]) => T),\n  resultSelector?: (...args: any[]) => T\n): Observable<T> {\n  if (isFunction(options)) {\n    // DEPRECATED PATH\n    // @ts-ignore\n    resultSelector = options;\n    options = undefined;\n  }\n  if (resultSelector) {\n    // DEPRECATED PATH\n    return fromEvent<T>(\n      target,\n      eventName,\n      <EventListenerOptions | undefined>options\n    ).pipe(\n      map((args) =>\n        isArray(args) ? resultSelector(...args) : resultSelector(args)\n      )\n    );\n  }\n\n  return new Observable<T>((subscriber) => {\n    function handler(e: T) {\n      if (arguments.length > 1) {\n        subscriber.next(Array.prototype.slice.call(arguments));\n      } else {\n        subscriber.next(e);\n      }\n    }\n    setupSubscription(\n      target,\n      eventName,\n      handler,\n      subscriber,\n      options as EventListenerOptions\n    );\n  });\n}\n\nfunction setupSubscription<T>(\n  sourceObj: FromEventTarget<T>,\n  eventName: string,\n  handler: (...args: any[]) => void,\n  subscriber: Subscriber<T>,\n  options?: EventListenerOptions\n) {\n  let unsubscribe: () => void;\n  if (isEventTarget(sourceObj)) {\n    const source = sourceObj;\n    getZoneUnPatchedApi(sourceObj, 'addEventListener').call(\n      sourceObj,\n      eventName,\n      handler,\n      options\n    );\n    unsubscribe = () =>\n      getZoneUnPatchedApi(source, 'removeEventListener').call(\n        source,\n        eventName,\n        handler,\n        options\n      );\n  } else if (isJQueryStyleEventEmitter(sourceObj)) {\n    const source = sourceObj;\n    sourceObj.on(eventName, handler);\n    unsubscribe = () => source.off(eventName, handler);\n  } else if (isNodeStyleEventEmitter(sourceObj)) {\n    const source = sourceObj;\n    sourceObj.addListener(eventName, handler as NodeEventHandler);\n    unsubscribe = () =>\n      source.removeListener(eventName, handler as NodeEventHandler);\n  } else if (sourceObj && (sourceObj as any).length) {\n    for (let i = 0, len = (sourceObj as any).length; i < len; i++) {\n      setupSubscription(sourceObj[i], eventName, handler, subscriber, options);\n    }\n  } else {\n    throw new TypeError('Invalid event target');\n  }\n\n  subscriber.add(unsubscribe);\n}\n\nfunction isNodeStyleEventEmitter(\n  sourceObj: any\n): sourceObj is NodeStyleEventEmitter {\n  return (\n    sourceObj &&\n    typeof sourceObj.addListener === 'function' &&\n    typeof sourceObj.removeListener === 'function'\n  );\n}\n\nfunction isJQueryStyleEventEmitter(\n  sourceObj: any\n): sourceObj is JQueryStyleEventEmitter {\n  return (\n    sourceObj &&\n    typeof sourceObj.on === 'function' &&\n    typeof sourceObj.off === 'function'\n  );\n}\n\nfunction isEventTarget(\n  sourceObj: any\n): sourceObj is HasEventTargetAddRemove<any> {\n  return (\n    sourceObj &&\n    typeof sourceObj.addEventListener === 'function' &&\n    typeof sourceObj.removeEventListener === 'function'\n  );\n}\n","import { Promise } from '@rx-angular/cdk/zone-less/browser';\n\nlet nextHandle = 1;\n// The promise needs to be created lazily otherwise it won't be patched by Zones\nlet resolved: Promise<any>;\nconst activeHandles: { [key: number]: any } = {};\n\n/**\n * Finds the handle in the list of active handles, and removes it.\n * Returns `true` if found, `false` otherwise. Used both to clear\n * Immediate scheduled tasks, and to identify if a task should be scheduled.\n */\nfunction findAndClearHandle(handle: number): boolean {\n  if (handle in activeHandles) {\n    delete activeHandles[handle];\n    return true;\n  }\n  return false;\n}\n\n/**\n * Helper functions to schedule and unschedule microtasks.\n */\nexport const Immediate = {\n  setImmediate(cb: () => void): number {\n    const handle = nextHandle++;\n    activeHandles[handle] = true;\n    if (!resolved) {\n      resolved = Promise.resolve();\n    }\n    resolved.then(() => findAndClearHandle(handle) && cb());\n    return handle;\n  },\n\n  clearImmediate(handle: number): void {\n    findAndClearHandle(handle);\n  },\n};\n","import { Immediate } from './Immediate';\n\nconst { setImmediate, clearImmediate } = Immediate;\n\ntype SetImmediateFunction = (handler: () => void, ...args: any[]) => number;\ntype ClearImmediateFunction = (handle: number) => void;\n\ninterface ImmediateProvider {\n  setImmediate: SetImmediateFunction;\n  clearImmediate: ClearImmediateFunction;\n  delegate?: Omit<ImmediateProvider, 'delegate'>;\n}\n\nexport const immediateProvider: ImmediateProvider = {\n  setImmediate(...args): number {\n    const { delegate } = immediateProvider;\n    return (delegate?.setImmediate || setImmediate)(...args);\n  },\n\n  clearImmediate(handle: number): void {\n    const { delegate } = immediateProvider;\n    return (delegate?.clearImmediate || clearImmediate)(handle as any);\n  },\n};\n","import { immediateProvider } from '../../internals/immediateProvider';\nimport { AsyncAction } from '../async/AsyncAction';\nimport { AsapScheduler } from './AsapScheduler';\nimport { SchedulerAction } from '../types';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class AsapAction<T> extends AsyncAction<T> {\n  constructor(\n    protected scheduler: AsapScheduler,\n    protected work: (this: SchedulerAction<T>, state?: T) => void\n  ) {\n    super(scheduler, work);\n  }\n\n  protected requestAsyncId(\n    scheduler: AsapScheduler,\n    id?: any,\n    delay: number = 0\n  ): any {\n    // If delay is greater than 0, request as an async action.\n    if (delay !== null && delay > 0) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Push the action to the end of the scheduler queue.\n    scheduler.actions.push(this);\n    // If a microtask has already been scheduled, don't schedule another\n    // one. If a microtask hasn't been scheduled yet, schedule one now. Return\n    // the current scheduled microtask id.\n    return (\n      scheduler._scheduled ||\n      (scheduler._scheduled = immediateProvider.setImmediate(\n        scheduler.flush.bind(scheduler, undefined)\n      ))\n    );\n  }\n  protected recycleAsyncId(\n    scheduler: AsapScheduler,\n    id?: any,\n    delay: number = 0\n  ): any {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n      return super.recycleAsyncId(scheduler, id, delay);\n    }\n    // If the scheduler queue is empty, cancel the requested microtask and\n    // set the scheduled flag to undefined so the next AsapAction will schedule\n    // its own.\n    if (!scheduler.actions.some((action) => action.id === id)) {\n      immediateProvider.clearImmediate(id);\n      scheduler._scheduled = undefined;\n    }\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\n    return undefined;\n  }\n}\n","import { AsyncAction } from '../async/AsyncAction';\nimport { AsyncScheduler } from '../async/AsyncScheduler';\n\nexport class AsapScheduler extends AsyncScheduler {\n  public flush(action?: AsyncAction<any>): void {\n    this._active = true;\n    // The async id that effects a call to flush is stored in _scheduled.\n    // Before executing an action, it's necessary to check the action's async\n    // id to determine whether it's supposed to be executed in the current\n    // flush.\n    // Previous implementations of this method used a count to determine this,\n    // but that was unsound, as actions that are unsubscribed - i.e. cancelled -\n    // are removed from the actions array and that can shift actions that are\n    // scheduled to be executed in a subsequent flush into positions at which\n    // they are executed within the current flush.\n    const flushId = this._scheduled;\n    this._scheduled = undefined;\n\n    const { actions } = this;\n    let error: any;\n    action = action || actions.shift()!;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions[0]) && action.id === flushId && actions.shift());\n\n    this._active = false;\n\n    if (error) {\n      while (\n        (action = actions[0]) &&\n        action.id === flushId &&\n        actions.shift()\n      ) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n","import { AsapAction } from './AsapAction';\nimport { AsapScheduler } from './AsapScheduler';\n\n/**\n *\n * NOTE: This is a zone un-patched version of rxjs asapScheduler\n *\n * Asap Scheduler\n *\n * <span class=\"informal\">Perform task as fast as it can be performed asynchronously</span>\n *\n * `asap` scheduler behaves the same as {@link asyncScheduler} scheduler when you use it to delay task\n * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing\n * code to end and then it will try to execute given task as fast as possible.\n *\n * `asap` scheduler will do its best to minimize time between end of currently executing code\n * and start of scheduled task. This makes it best candidate for performing so called \"deferring\".\n * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves\n * some (although minimal) unwanted delay.\n *\n * Note that using `asap` scheduler does not necessarily mean that your task will be first to process\n * after currently executing code. In particular, if some task was also scheduled with `asap` before,\n * that task will execute first. That being said, if you need to schedule task asynchronously, but\n * as soon as possible, `asap` scheduler is your best bet.\n *\n * ## Example\n * Compare async and asap scheduler<\n * ```ts\n * import { asapScheduler, asyncScheduler } from '@cu/perf-utils';\n *\n * asyncScheduler.schedule(() => console.log('async')); // scheduling 'async' first...\n * asapScheduler.schedule(() => console.log('asap'));\n *\n * // Logs:\n * // \"asap\"\n * // \"async\"\n * // ... but 'asap' goes first!\n * ```\n * @deprecated will be removed with 1.0.0\n */\nexport const asapScheduler = new AsapScheduler(AsapAction);\n","import { AsyncAction } from '../async/AsyncAction';\nimport { Subscription } from 'rxjs';\nimport { SchedulerAction } from '../types';\nimport { QueueScheduler } from './QueueScheduler';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class QueueAction<T> extends AsyncAction<T> {\n  constructor(\n    protected scheduler: QueueScheduler,\n    protected work: (this: SchedulerAction<T>, state?: T) => void\n  ) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (delay > 0) {\n      return super.schedule(state, delay);\n    }\n    this.delay = delay;\n    this.state = state;\n    this.scheduler.flush(this);\n    return this;\n  }\n\n  public execute(state: T, delay: number): any {\n    return delay > 0 || this.closed\n      ? super.execute(state, delay)\n      : this._execute(state, delay);\n  }\n\n  protected requestAsyncId(\n    scheduler: QueueScheduler,\n    id?: any,\n    delay: number = 0\n  ): any {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Otherwise flush the scheduler starting with this action.\n    return scheduler.flush(this);\n  }\n}\n","import { AsyncScheduler } from '../async/AsyncScheduler';\n\nexport class QueueScheduler extends AsyncScheduler {}\n","import { QueueAction } from './QueueAction';\nimport { QueueScheduler } from './QueueScheduler';\n\n/**\n *\n * NOTE: This is a zone un-patched version of rxjs queueScheduler\n *\n * Queue Scheduler\n *\n * <span class=\"informal\">Put every next task on a queue, instead of executing it immediately</span>\n *\n * `queue` scheduler, when used with delay, behaves the same as {@link asyncScheduler} scheduler.\n *\n * When used without delay, it schedules given task synchronously - executes it right when\n * it is scheduled. However when called recursively, that is when inside the scheduled task,\n * another task is scheduled with queue scheduler, instead of executing immediately as well,\n * that task will be put on a queue and wait for current one to finish.\n *\n * This means that when you execute task with `queue` scheduler, you are sure it will end\n * before any other task scheduled with that scheduler will start.\n *\n * ## Examples\n * Schedule recursively first, then do something\n * ```ts\n * import { queueScheduler } from '@cu/perf-utils';\n *\n * queueScheduler.schedule(() => {\n *   queueScheduler.schedule(() => console.log('second')); // will not happen now, but will be put on a queue\n *\n *   console.log('first');\n * });\n *\n * // Logs:\n * // \"first\"\n * // \"second\"\n * ```\n *\n * Reschedule itself recursively\n * ```ts\n * import { queueScheduler } from '@cu/perf-utils';\n *\n * queueScheduler.schedule(function(state) {\n *   if (state !== 0) {\n *     console.log('before', state);\n *     this.schedule(state - 1); // `this` references currently executing Action,\n *                               // which we reschedule with new state\n *     console.log('after', state);\n *   }\n * }, 0, 3);\n *\n * // In scheduler that runs recursively, you would expect:\n * // \"before\", 3\n * // \"before\", 2\n * // \"before\", 1\n * // \"after\", 1\n * // \"after\", 2\n * // \"after\", 3\n *\n * // But with queue it logs:\n * // \"before\", 3\n * // \"after\", 3\n * // \"before\", 2\n * // \"after\", 2\n * // \"before\", 1\n * // \"after\", 1\n * ```\n * @deprecated will be removed with 1.0.0\n */\nexport const queueScheduler = new QueueScheduler(QueueAction);\n","import { Subscription } from 'rxjs';\nimport { getZoneUnPatchedApi } from '@rx-angular/cdk/internals/core';\n\nconst cancelAnimationFrame = getZoneUnPatchedApi('cancelAnimationFrame');\nconst requestAnimationFrame = getZoneUnPatchedApi('requestAnimationFrame');\n\ninterface AnimationFrameProvider {\n  schedule(callback: FrameRequestCallback): Subscription;\n  requestAnimationFrame: typeof requestAnimationFrame;\n  cancelAnimationFrame: typeof cancelAnimationFrame;\n  delegate?: Omit<AnimationFrameProvider, 'schedule' | 'delegate'>;\n}\n\nexport const animationFrameProvider: AnimationFrameProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  schedule(callback) {\n    let request = requestAnimationFrame;\n    let cancel: typeof cancelAnimationFrame | undefined = cancelAnimationFrame;\n    const { delegate } = animationFrameProvider;\n    if (delegate) {\n      request = delegate.requestAnimationFrame;\n      cancel = delegate.cancelAnimationFrame;\n    }\n    const handle = request((timestamp) => {\n      // Clear the cancel function. The request has been fulfilled, so\n      // attempting to cancel the request upon unsubscription would be\n      // pointless.\n      cancel = undefined;\n      callback(timestamp);\n    });\n    return new Subscription(() => cancel?.(handle));\n  },\n  requestAnimationFrame(...args) {\n    const { delegate } = animationFrameProvider;\n    return (delegate?.requestAnimationFrame || requestAnimationFrame)(...args);\n  },\n  cancelAnimationFrame(...args) {\n    const { delegate } = animationFrameProvider;\n    return (delegate?.cancelAnimationFrame || cancelAnimationFrame)(...args);\n  },\n};\n","import { animationFrameProvider } from '../../internals/animationFrameProvider';\nimport { AsyncAction } from '../async/AsyncAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\nimport { SchedulerAction } from '../types';\n\nexport class AnimationFrameAction<T> extends AsyncAction<T> {\n  constructor(\n    protected scheduler: AnimationFrameScheduler,\n    protected work: (this: SchedulerAction<T>, state?: T) => void\n  ) {\n    super(scheduler, work);\n  }\n\n  protected requestAsyncId(\n    scheduler: AnimationFrameScheduler,\n    id?: any,\n    delay: number = 0\n  ): any {\n    // If delay is greater than 0, request as an async action.\n    if (delay !== null && delay > 0) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Push the action to the end of the scheduler queue.\n    scheduler.actions.push(this);\n    // If an animation frame has already been requested, don't request another\n    // one. If an animation frame hasn't been requested yet, request one. Return\n    // the current animation frame request id.\n    return (\n      scheduler._scheduled ||\n      (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(() =>\n        scheduler.flush(undefined)\n      ))\n    );\n  }\n  protected recycleAsyncId(\n    scheduler: AnimationFrameScheduler,\n    id?: any,\n    delay: number = 0\n  ): any {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if ((delay != null && delay > 0) || (delay == null && this.delay > 0)) {\n      return super.recycleAsyncId(scheduler, id, delay);\n    }\n    // If the scheduler queue is empty, cancel the requested animation frame and\n    // set the scheduled flag to undefined so the next AnimationFrameAction will\n    // request its own.\n    if (!scheduler.actions.some((action) => action.id === id)) {\n      animationFrameProvider.cancelAnimationFrame(id);\n      scheduler._scheduled = undefined;\n    }\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\n    return undefined;\n  }\n}\n","import { AsyncAction } from '../async/AsyncAction';\nimport { AsyncScheduler } from '../async/AsyncScheduler';\n\nexport class AnimationFrameScheduler extends AsyncScheduler {\n  public flush(action?: AsyncAction<any>): void {\n    this._active = true;\n    // The async id that effects a call to flush is stored in _scheduled.\n    // Before executing an action, it's necessary to check the action's async\n    // id to determine whether it's supposed to be executed in the current\n    // flush.\n    // Previous implementations of this method used a count to determine this,\n    // but that was unsound, as actions that are unsubscribed - i.e. cancelled -\n    // are removed from the actions array and that can shift actions that are\n    // scheduled to be executed in a subsequent flush into positions at which\n    // they are executed within the current flush.\n    const flushId = this._scheduled;\n    this._scheduled = undefined;\n\n    const { actions } = this;\n    let error: any;\n    action = action || actions.shift()!;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions[0]) && action.id === flushId && actions.shift());\n\n    this._active = false;\n\n    if (error) {\n      while (\n        (action = actions[0]) &&\n        action.id === flushId &&\n        actions.shift()\n      ) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n","import { AnimationFrameAction } from './AnimationFrameAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\n\n/**\n *\n * NOTE: This is a zone un-patched version of rxjs animationFrameScheduler\n *\n * Animation Frame Scheduler\n *\n * <span class=\"informal\">Perform task when `window.requestAnimationFrame` would fire</span>\n *\n * When `animationFrame` scheduler is used with delay, it will fall back to {@link asyncScheduler} scheduler\n * behaviour.\n *\n * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.\n * It makes sure scheduled task will happen just before next browser content repaint,\n * thus performing animations as efficiently as possible.\n *\n * ## Example\n * Schedule div height animation\n * ```ts\n * // html: <div style=\"background: #0ff;\"></div>\n * import { animationFrameScheduler } from '@rx-angular/cdk/zone-less/rxjs';\n *\n * const div = document.querySelector('div');\n *\n * animationFrameScheduler.schedule(function(height) {\n *   div.style.height = height + \"px\";\n *\n *   this.schedule(height + 1);  // `this` references currently executing Action,\n *                               // which we reschedule with new state\n * }, 0, 0);\n *\n * // You will see a div element growing in height\n * ```\n * @deprecated will be removed with 1.0.0\n */\nexport const animationFrameScheduler = new AnimationFrameScheduler(\n  AnimationFrameAction\n);\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":["dispatch","Promise"],"mappings":"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"}