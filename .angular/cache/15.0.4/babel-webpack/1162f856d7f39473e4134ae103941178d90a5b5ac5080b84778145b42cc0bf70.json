{"ast":null,"code":"import { Subject, BehaviorSubject, merge, queueScheduler, EMPTY, noop } from 'rxjs';\nimport { distinctUntilChanged, mergeAll, observeOn, withLatestFrom, scan, tap, catchError, publish, publishReplay, filter, shareReplay, map, pluck } from 'rxjs/operators';\nconst defaultAccumulator = (st, sl) => {\n  return Object.assign(Object.assign({}, st), sl);\n};\nfunction createAccumulationObservable(stateObservables = new Subject(), stateSlices = new Subject(), accumulatorObservable = new BehaviorSubject(defaultAccumulator)) {\n  const signal$ = merge(stateObservables.pipe(distinctUntilChanged(), mergeAll(), observeOn(queueScheduler)), stateSlices.pipe(observeOn(queueScheduler))).pipe(withLatestFrom(accumulatorObservable.pipe(observeOn(queueScheduler))), scan((state, [slice, stateAccumulator]) => stateAccumulator(state, slice), {}), tap(newState => compositionObservable.state = newState, error => console.error(error)),\n  // @Notice We catch the error here as it get lost in between `publish` and `publishReplay`. We return empty to\n  catchError(e => EMPTY), publish());\n  const state$ = signal$.pipe(publishReplay(1));\n  const compositionObservable = {\n    state: {},\n    signal$,\n    state$,\n    nextSlice,\n    nextSliceObservable,\n    nextAccumulator,\n    subscribe\n  };\n  // ======\n  return compositionObservable;\n  // ======\n  function nextAccumulator(accumulatorFn) {\n    accumulatorObservable.next(accumulatorFn);\n  }\n  function nextSlice(stateSlice) {\n    stateSlices.next(stateSlice);\n  }\n  function nextSliceObservable(stateObservable) {\n    stateObservables.next(stateObservable);\n  }\n  function subscribe() {\n    const sub = compositionObservable.signal$.connect();\n    sub.add(compositionObservable.state$.connect());\n    sub.add(() => {\n      accumulatorObservable.complete();\n      stateObservables.complete();\n      stateSlices.complete();\n    });\n    return sub;\n  }\n}\nfunction isPromiseGuard(value) {\n  return value !== null && value !== undefined && typeof value.subscribe !== 'function' && typeof value.then === 'function';\n}\nfunction isOperateFnArrayGuard(op) {\n  if (!Array.isArray(op)) {\n    return false;\n  }\n  return op.length > 0 && op.every(i => typeof i === 'function');\n}\nfunction isStringArrayGuard(op) {\n  if (!Array.isArray(op)) {\n    return false;\n  }\n  return op.length > 0 && op.every(i => typeof i === 'string');\n}\nfunction isIterableGuard(obj) {\n  if (obj === null || obj === undefined) {\n    return false;\n  }\n  return typeof obj[Symbol.iterator] === 'function';\n}\nfunction isKeyOf(k) {\n  const typeofK = typeof k;\n  return k !== null && k !== undefined && ['string', 'symbol', 'number'].includes(typeofK);\n}\nfunction isObjectGuard(obj) {\n  return obj !== null && obj !== undefined && typeof obj === 'object' && !Array.isArray(obj);\n}\nfunction isDefined(val) {\n  return val !== null && val !== undefined;\n}\nfunction isStringAndFunctionTupleGuard(op) {\n  return typeof op[0] === 'string' && typeof op[1] === 'function';\n}\nfunction isStringArrayFunctionAndOptionalObjectTupleGuard(op) {\n  return isStringArrayGuard(op[0]) && typeof op[1] === 'function' && (op[2] === undefined || typeof op[2] === 'object');\n}\nfunction pipeFromArray(fns) {\n  if (!fns) {\n    return noop;\n  }\n  if (fns.length === 1) {\n    return fns[0];\n  }\n  return function piped(input) {\n    return fns.reduce((prev, fn) => fn(prev), input);\n  };\n}\n\n/**\n * @description\n *\n * As it acts like the Observables `pipe` method, it accepts one or many RxJS operators as params.\n *\n * @example\n * import { Observable } from 'rxjs';\n * import { map } from 'rxjs/operators';\n * import { stateful } from 'rx-angular/state';\n *\n * const state$: Observable<{ name: string; items: string[] }>;\n * const derivation$ = state$.pipe(\n *   stateful(\n *     map(state => state.list.length),\n *     filter(length => length > 3)\n *   )\n * );\n *\n * @param {OperatorFunction<T, A>} op - one or multiple passed operator comma separated\n *\n * @docsPage stateful\n * @docsCategory operators\n */\nfunction stateful(...optionalDerive) {\n  return s => {\n    return s.pipe(\n    // distinct same base-state objects (e.g. a default emission of default switch cases, incorrect mutable handling\n    // of data) @TODO evaluate benefits vs. overhead\n    distinctUntilChanged(),\n    // CUSTOM LOGIC HERE\n    o => {\n      if (isOperateFnArrayGuard(optionalDerive)) {\n        return o.pipe(pipeFromArray(optionalDerive));\n      }\n      return o;\n    },\n    // initial emissions, undefined is no base-state, pollution with skip(1)\n    filter(v => v !== undefined),\n    // distinct same derivation value\n    distinctUntilChanged(),\n    // reuse custom operations result for multiple subscribers and reemit the last calculated value.\n    shareReplay({\n      bufferSize: 1,\n      refCount: true\n    }));\n  };\n}\nfunction safePluck(stateObject, keys) {\n  // needed to match null and undefined conventions of RxAngular core components\n  // safePluck(null) -> return null\n  // safePluck(undefined) -> return undefined\n  // safePluck(obj, ['wrongKey']) -> return undefined\n  // safePluck(obj, ['correctKey']) -> return value of key\n  // safePluck(obj, '') -> return undefined\n  // safePluck(obj, null) -> return undefined\n  if (!isDefined(stateObject)) {\n    return stateObject;\n  }\n  if (!isDefined(keys)) {\n    return undefined;\n  }\n  // sanitize keys -> keep only valid keys (string, number, symbol)\n  const keysArr = (Array.isArray(keys) ? keys : [keys]).filter(k => isKeyOf(k));\n  if (keysArr.length === 0 || !isObjectGuard(stateObject) || Object.keys(stateObject).length === 0) {\n    return undefined;\n  }\n  let prop = stateObject[keysArr.shift()];\n  keysArr.forEach(key => {\n    if (isObjectGuard(prop) && isKeyOf(key)) {\n      prop = prop[key];\n    }\n  });\n  return prop;\n}\n\n/**\n * @internal\n */\nfunction defaultCompare(oldVal, newVal) {\n  return oldVal === newVal;\n}\n/**\n * @description\n *\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from\n * the previous item. Comparison will be done for each set key in the `keys` array.\n *\n * You can fine grain your distinct checks by providing a `KeyCompareMap` with those keys you want to compute\n * explicitly different\n *\n * The name `distinctUntilSomeChanged` was picked since it internally iterates over the `keys` and utilizes the\n * [some](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Array/some) method in order to\n * compute if values are distinct or not.\n *\n * @example\n *\n * import { of } from 'rxjs';\n * import { distinctUntilSomeChanged } from 'rx-angular/state';\n *\n * interface Person {\n *    age: number;\n *    name: string;\n * }\n *\n * of(\n *   { age: 4, name: 'Hans'},\n *   { age: 7, name: 'Sophie'},\n *   { age: 5, name: 'Han Solo'},\n *   { age: 5, name: 'HanSophie'},\n * ).pipe(\n *   distinctUntilSomeChanged(['age', 'name']),\n * )\n * .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Hans'}\n * // { age: 7, name: 'Sophie'}\n * // { age: 5, name: 'Han Solo'}\n * // { age: 5, name: 'HanSophie'}\n *\n * @example\n * // An example with `KeyCompareMap`\n * import { of } from 'rxjs';\n * import { distinctUntilSomeChanged } from 'rxjs/operators';\n *\n * interface Person {\n *     age: number;\n *     name: string;\n *  }\n * const customComparison: KeyCompareMap<Person> = {\n *   name: (oldName, newName) => oldName.substring(0, 2) === newName.substring(0, 2)\n * };\n *\n * of(\n *     { age: 4, name: 'Hans'},\n *     { age: 7, name: 'Sophie'},\n *     { age: 5, name: 'Han Solo'},\n *     { age: 5, name: 'HanSophie'},\n *   ).pipe(\n *     distinctUntilSomeChanged(['age', 'name'], customComparison),\n *   )\n *   .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Hans' }\n * // { age: 7, name: 'Sophie' }\n * // { age: 5, name: 'Han Solo' }\n *\n * @param {K[]} keys String key for object property lookup on each item.\n * @param {KeyCompareMap<T>} [compare] Optional KeyCompareMap to explicitly define comparisons for some of the keys\n * @docsPage distinctUntilSomeChanged\n * @docsCategory operators\n */\nfunction distinctUntilSomeChanged(keys, keyCompareMap) {\n  // default compare function applying === to every key\n  let distinctCompare = (oldState, newState) => keys.some(key => !defaultCompare(safePluck(oldState, [key]), safePluck(newState, [key])));\n  // generate compare function respecting every case of provided keyCompareMap\n  if (keyCompareMap !== undefined) {\n    const compare = key => {\n      return keyCompareMap.hasOwnProperty(key) && keyCompareMap[key] !== undefined ? keyCompareMap[key] : defaultCompare;\n    };\n    distinctCompare = (oldState, newState) => {\n      return keys.some(key => !compare(key)(safePluck(oldState, [key]), safePluck(newState, [key])));\n    };\n  }\n  return distinctUntilChanged((oldV, newV) => !distinctCompare(oldV, newV));\n}\n\n/**\n * @description\n *\n * Returns an Observable that emits only the provided `keys` emitted by the source Observable. Each key will get\n * filtered to only emit _defined_ values as well as checked for distinct emissions.\n * Comparison will be done for each set key in the `keys` array.\n *\n * `selectSlice` will only emit _valid_ selections. A selection is _valid_ if every\n * selected key exists and is defined in the source Observable. This ensures that the `selectSlice`\n * operator will always return a complete slice with all values defined.\n *\n * You can fine grain your distinct checks by providing a `KeyCompareMap` with those keys you want to compute\n * explicitly different\n *\n * @example\n *\n * // An example with a custom comparison applied to each key\n * import { of } from 'rxjs';\n * import { selectSlice } from 'rx-angular/state';\n *\n *\n * const state$: Observable<MyState> = of(\n *  { title: 'myTitle', panelOpen: true},\n *  { title: 'myTitle2', panelOpen: true},\n *  { title: 'newTitle', panelOpen: true},\n *  { title: 'newTitle', panelOpen: false}\n * )\n * .pipe(\n *     selectSlice(['title', 'panelOpen']),\n *   )\n *   .subscribe(x => console.log(x));\n *\n * // displays:\n * //  { title: 'myTitle', panelOpen: true },\n * //  { title: 'myTitle2', panelOpen: true },\n * //  { title: 'newTitle', panelOpen: true },\n * //  { title: 'newTitle', panelOpen: false }\n *\n * @example\n *\n * import { of, Observable } from 'rxjs';\n * import { tap } from 'rxjs/operators';\n * import { selectSlice } from 'rx-angular/state';\n *\n * interface MyState {\n *    title: string;\n *    items: string[];\n *    panelOpen: boolean;\n * }\n * // Select items and title.\n * // apply custom compare logic for the items array\n * const customComparison: KeyCompareMap<MyState> = {\n *   items: (oldItems, newItems) => compareItems(oldItems, newItems)\n * };\n * const state$: Observable<MyState> = of(\n * { title: 'myTitle', items: ['foo', 'bar'], panelOpen: true },\n * { title: 'myTitle', items: ['foo', 'bar'], panelOpen: false },\n * { title: 'nextTitle', items: ['foo', 'baR'], panelOpen: true },\n * { title: 'nextTitle', items: ['fooRz', 'boo'], panelOpen: false },\n * );\n * const slice$ = state$.pipe(selectSlice(['title', 'items'], customComparison), tap(console.log)).subscribe();\n *\n * // displays:\n * // { title: 'myTitle', items: ['foo', 'bar'] }\n * // { title: 'nextTitle', items: ['foo', 'baR'] }\n * // { title: 'nextTitle', items: ['fooRz', 'boo'] }\n *\n * @param {(K)[]} keys - the array of keys which should be selected\n * @param {KeyCompareMap<{ [P in K]: T[P] }>} [keyCompareMap] Optional KeyCompareMap to provide custom compare logic\n * for some the keys\n * @docsPage selectSlice\n * @docsCategory operators\n */\nfunction selectSlice(keys, keyCompareMap) {\n  return o$ => o$.pipe(filter(state => state !== undefined), map(state => {\n    // forward null\n    if (state === null) {\n      return null;\n    }\n    // an array of all keys which exist and are _defined_ in the state object\n    const definedKeys = keys\n    // filter out undefined properties e. g. {}, { str: undefined }\n    .filter(k => state.hasOwnProperty(k) && state[k] !== undefined);\n    // we want to ensure to only emit _valid_ selections\n    // a selection is _valid_ if every selected key exists and has a value:\n    // {} => selectSlice(['foo']) => no emission\n    // {str: 'test'} => selectSlice([]) => no emission\n    // {str: 'test'} => selectSlice(['notPresent']) => no emission\n    // {str: 'test'} => state.select(selectSlice([])) => no emission\n    // {str: 'test'} => state.select(selectSlice(['notPresent'])) => no emission\n    // {str: undefined} => state.select(selectSlice(['str'])) => no emission\n    // {str: 'test', foo: undefined } => state.select(selectSlice(['foo'])) => no emission\n    if (definedKeys.length < keys.length) {\n      return undefined;\n    }\n    // create the selected slice\n    return definedKeys.reduce((vm, key) => {\n      vm[key] = state[key];\n      return vm;\n    }, {});\n  }), filter(v => v !== undefined), distinctUntilSomeChanged(keys, keyCompareMap));\n}\n\n/**\n * @internal\n */\nfunction select(...opOrMapFn) {\n  return state$ => {\n    if (!opOrMapFn || opOrMapFn.length === 0) {\n      return state$.pipe(stateful());\n    } else if (isStringAndFunctionTupleGuard(opOrMapFn)) {\n      return state$.pipe(stateful(map(s => opOrMapFn[1](s[opOrMapFn[0]]))));\n    } else if (isStringArrayFunctionAndOptionalObjectTupleGuard(opOrMapFn)) {\n      return state$.pipe(selectSlice(opOrMapFn[0], opOrMapFn[2]), stateful(map(opOrMapFn[1])));\n    } else if (isStringArrayGuard(opOrMapFn)) {\n      return state$.pipe(stateful(pluck(...opOrMapFn)));\n    } else if (isOperateFnArrayGuard(opOrMapFn)) {\n      return state$.pipe(stateful(pipeFromArray(opOrMapFn)));\n    } else {\n      throw new Error('wrong params passed to select');\n    }\n  };\n}\nfunction createSideEffectObservable(stateObservables = new Subject()) {\n  const effects$ = merge(stateObservables.pipe(mergeAll(), observeOn(queueScheduler)));\n  function nextEffectObservable(effect$) {\n    stateObservables.next(effect$);\n  }\n  function subscribe() {\n    return effects$.subscribe();\n  }\n  return {\n    effects$,\n    nextEffectObservable,\n    subscribe\n  };\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { createAccumulationObservable, createSideEffectObservable, distinctUntilSomeChanged, isDefined, isKeyOf, isObjectGuard, isOperateFnArrayGuard, isStringAndFunctionTupleGuard, isStringArrayFunctionAndOptionalObjectTupleGuard, isStringArrayGuard, pipeFromArray, safePluck, select, selectSlice, stateful };","map":{"version":3,"names":["Subject","BehaviorSubject","merge","queueScheduler","EMPTY","noop","distinctUntilChanged","mergeAll","observeOn","withLatestFrom","scan","tap","catchError","publish","publishReplay","filter","shareReplay","map","pluck","defaultAccumulator","st","sl","Object","assign","createAccumulationObservable","stateObservables","stateSlices","accumulatorObservable","signal$","pipe","state","slice","stateAccumulator","newState","compositionObservable","error","console","e","state$","nextSlice","nextSliceObservable","nextAccumulator","subscribe","accumulatorFn","next","stateSlice","stateObservable","sub","connect","add","complete","isPromiseGuard","value","undefined","then","isOperateFnArrayGuard","op","Array","isArray","length","every","i","isStringArrayGuard","isIterableGuard","obj","Symbol","iterator","isKeyOf","k","typeofK","includes","isObjectGuard","isDefined","val","isStringAndFunctionTupleGuard","isStringArrayFunctionAndOptionalObjectTupleGuard","pipeFromArray","fns","piped","input","reduce","prev","fn","stateful","optionalDerive","s","o","v","bufferSize","refCount","safePluck","stateObject","keys","keysArr","prop","shift","forEach","key","defaultCompare","oldVal","newVal","distinctUntilSomeChanged","keyCompareMap","distinctCompare","oldState","some","compare","hasOwnProperty","oldV","newV","selectSlice","o$","definedKeys","vm","select","opOrMapFn","Error","createSideEffectObservable","effects$","nextEffectObservable","effect$"],"sources":["/home/sasha/Study/Work Assignements/flashenpost/Frontend/node_modules/@rx-angular/state/fesm2015/state-selections.js"],"sourcesContent":["import { Subject, BehaviorSubject, merge, queueScheduler, EMPTY, noop } from 'rxjs';\nimport { distinctUntilChanged, mergeAll, observeOn, withLatestFrom, scan, tap, catchError, publish, publishReplay, filter, shareReplay, map, pluck } from 'rxjs/operators';\n\nconst defaultAccumulator = (st, sl) => {\n    return Object.assign(Object.assign({}, st), sl);\n};\nfunction createAccumulationObservable(stateObservables = new Subject(), stateSlices = new Subject(), accumulatorObservable = new BehaviorSubject(defaultAccumulator)) {\n    const signal$ = merge(stateObservables.pipe(distinctUntilChanged(), mergeAll(), observeOn(queueScheduler)), stateSlices.pipe(observeOn(queueScheduler))).pipe(withLatestFrom(accumulatorObservable.pipe(observeOn(queueScheduler))), scan((state, [slice, stateAccumulator]) => stateAccumulator(state, slice), {}), tap((newState) => (compositionObservable.state = newState), (error) => console.error(error)), \n    // @Notice We catch the error here as it get lost in between `publish` and `publishReplay`. We return empty to\n    catchError((e) => EMPTY), publish());\n    const state$ = signal$.pipe(publishReplay(1));\n    const compositionObservable = {\n        state: {},\n        signal$,\n        state$,\n        nextSlice,\n        nextSliceObservable,\n        nextAccumulator,\n        subscribe,\n    };\n    // ======\n    return compositionObservable;\n    // ======\n    function nextAccumulator(accumulatorFn) {\n        accumulatorObservable.next(accumulatorFn);\n    }\n    function nextSlice(stateSlice) {\n        stateSlices.next(stateSlice);\n    }\n    function nextSliceObservable(stateObservable) {\n        stateObservables.next(stateObservable);\n    }\n    function subscribe() {\n        const sub = compositionObservable.signal$.connect();\n        sub.add(compositionObservable.state$.connect());\n        sub.add(() => {\n            accumulatorObservable.complete();\n            stateObservables.complete();\n            stateSlices.complete();\n        });\n        return sub;\n    }\n}\n\nfunction isPromiseGuard(value) {\n    return (value !== null &&\n        value !== undefined &&\n        typeof value.subscribe !== 'function' &&\n        typeof value.then === 'function');\n}\nfunction isOperateFnArrayGuard(op) {\n    if (!Array.isArray(op)) {\n        return false;\n    }\n    return op.length > 0 && op.every((i) => typeof i === 'function');\n}\nfunction isStringArrayGuard(op) {\n    if (!Array.isArray(op)) {\n        return false;\n    }\n    return op.length > 0 && op.every((i) => typeof i === 'string');\n}\nfunction isIterableGuard(obj) {\n    if (obj === null || obj === undefined) {\n        return false;\n    }\n    return typeof obj[Symbol.iterator] === 'function';\n}\nfunction isKeyOf(k) {\n    const typeofK = typeof k;\n    return (k !== null &&\n        k !== undefined &&\n        ['string', 'symbol', 'number'].includes(typeofK));\n}\nfunction isObjectGuard(obj) {\n    return (obj !== null &&\n        obj !== undefined &&\n        typeof obj === 'object' &&\n        !Array.isArray(obj));\n}\nfunction isDefined(val) {\n    return val !== null && val !== undefined;\n}\nfunction isStringAndFunctionTupleGuard(op) {\n    return typeof op[0] === 'string' && typeof op[1] === 'function';\n}\nfunction isStringArrayFunctionAndOptionalObjectTupleGuard(op) {\n    return (isStringArrayGuard(op[0]) &&\n        typeof op[1] === 'function' &&\n        (op[2] === undefined || typeof op[2] === 'object'));\n}\n\nfunction pipeFromArray(fns) {\n    if (!fns) {\n        return noop;\n    }\n    if (fns.length === 1) {\n        return fns[0];\n    }\n    return function piped(input) {\n        return fns.reduce((prev, fn) => fn(prev), input);\n    };\n}\n\n/**\n * @description\n *\n * As it acts like the Observables `pipe` method, it accepts one or many RxJS operators as params.\n *\n * @example\n * import { Observable } from 'rxjs';\n * import { map } from 'rxjs/operators';\n * import { stateful } from 'rx-angular/state';\n *\n * const state$: Observable<{ name: string; items: string[] }>;\n * const derivation$ = state$.pipe(\n *   stateful(\n *     map(state => state.list.length),\n *     filter(length => length > 3)\n *   )\n * );\n *\n * @param {OperatorFunction<T, A>} op - one or multiple passed operator comma separated\n *\n * @docsPage stateful\n * @docsCategory operators\n */\nfunction stateful(...optionalDerive) {\n    return (s) => {\n        return s.pipe(\n        // distinct same base-state objects (e.g. a default emission of default switch cases, incorrect mutable handling\n        // of data) @TODO evaluate benefits vs. overhead\n        distinctUntilChanged(), \n        // CUSTOM LOGIC HERE\n        (o) => {\n            if (isOperateFnArrayGuard(optionalDerive)) {\n                return o.pipe(pipeFromArray(optionalDerive));\n            }\n            return o;\n        }, \n        // initial emissions, undefined is no base-state, pollution with skip(1)\n        filter((v) => v !== undefined), \n        // distinct same derivation value\n        distinctUntilChanged(), \n        // reuse custom operations result for multiple subscribers and reemit the last calculated value.\n        shareReplay({ bufferSize: 1, refCount: true }));\n    };\n}\n\nfunction safePluck(stateObject, keys) {\n    // needed to match null and undefined conventions of RxAngular core components\n    // safePluck(null) -> return null\n    // safePluck(undefined) -> return undefined\n    // safePluck(obj, ['wrongKey']) -> return undefined\n    // safePluck(obj, ['correctKey']) -> return value of key\n    // safePluck(obj, '') -> return undefined\n    // safePluck(obj, null) -> return undefined\n    if (!isDefined(stateObject)) {\n        return stateObject;\n    }\n    if (!isDefined(keys)) {\n        return undefined;\n    }\n    // sanitize keys -> keep only valid keys (string, number, symbol)\n    const keysArr = (Array.isArray(keys) ? keys : [keys]).filter(k => isKeyOf(k));\n    if (keysArr.length === 0 ||\n        !isObjectGuard(stateObject) ||\n        Object.keys(stateObject).length === 0) {\n        return undefined;\n    }\n    let prop = stateObject[keysArr.shift()];\n    keysArr.forEach(key => {\n        if (isObjectGuard(prop) && isKeyOf(key)) {\n            prop = prop[key];\n        }\n    });\n    return prop;\n}\n\n/**\n * @internal\n */\nfunction defaultCompare(oldVal, newVal) {\n    return oldVal === newVal;\n}\n/**\n * @description\n *\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from\n * the previous item. Comparison will be done for each set key in the `keys` array.\n *\n * You can fine grain your distinct checks by providing a `KeyCompareMap` with those keys you want to compute\n * explicitly different\n *\n * The name `distinctUntilSomeChanged` was picked since it internally iterates over the `keys` and utilizes the\n * [some](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Array/some) method in order to\n * compute if values are distinct or not.\n *\n * @example\n *\n * import { of } from 'rxjs';\n * import { distinctUntilSomeChanged } from 'rx-angular/state';\n *\n * interface Person {\n *    age: number;\n *    name: string;\n * }\n *\n * of(\n *   { age: 4, name: 'Hans'},\n *   { age: 7, name: 'Sophie'},\n *   { age: 5, name: 'Han Solo'},\n *   { age: 5, name: 'HanSophie'},\n * ).pipe(\n *   distinctUntilSomeChanged(['age', 'name']),\n * )\n * .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Hans'}\n * // { age: 7, name: 'Sophie'}\n * // { age: 5, name: 'Han Solo'}\n * // { age: 5, name: 'HanSophie'}\n *\n * @example\n * // An example with `KeyCompareMap`\n * import { of } from 'rxjs';\n * import { distinctUntilSomeChanged } from 'rxjs/operators';\n *\n * interface Person {\n *     age: number;\n *     name: string;\n *  }\n * const customComparison: KeyCompareMap<Person> = {\n *   name: (oldName, newName) => oldName.substring(0, 2) === newName.substring(0, 2)\n * };\n *\n * of(\n *     { age: 4, name: 'Hans'},\n *     { age: 7, name: 'Sophie'},\n *     { age: 5, name: 'Han Solo'},\n *     { age: 5, name: 'HanSophie'},\n *   ).pipe(\n *     distinctUntilSomeChanged(['age', 'name'], customComparison),\n *   )\n *   .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Hans' }\n * // { age: 7, name: 'Sophie' }\n * // { age: 5, name: 'Han Solo' }\n *\n * @param {K[]} keys String key for object property lookup on each item.\n * @param {KeyCompareMap<T>} [compare] Optional KeyCompareMap to explicitly define comparisons for some of the keys\n * @docsPage distinctUntilSomeChanged\n * @docsCategory operators\n */\nfunction distinctUntilSomeChanged(keys, keyCompareMap) {\n    // default compare function applying === to every key\n    let distinctCompare = (oldState, newState) => keys.some((key) => !defaultCompare(safePluck(oldState, [key]), safePluck(newState, [key])));\n    // generate compare function respecting every case of provided keyCompareMap\n    if (keyCompareMap !== undefined) {\n        const compare = (key) => {\n            return keyCompareMap.hasOwnProperty(key) &&\n                keyCompareMap[key] !== undefined\n                ? keyCompareMap[key]\n                : defaultCompare;\n        };\n        distinctCompare = (oldState, newState) => {\n            return keys.some((key) => !compare(key)(safePluck(oldState, [key]), safePluck(newState, [key])));\n        };\n    }\n    return distinctUntilChanged((oldV, newV) => !distinctCompare(oldV, newV));\n}\n\n/**\n * @description\n *\n * Returns an Observable that emits only the provided `keys` emitted by the source Observable. Each key will get\n * filtered to only emit _defined_ values as well as checked for distinct emissions.\n * Comparison will be done for each set key in the `keys` array.\n *\n * `selectSlice` will only emit _valid_ selections. A selection is _valid_ if every\n * selected key exists and is defined in the source Observable. This ensures that the `selectSlice`\n * operator will always return a complete slice with all values defined.\n *\n * You can fine grain your distinct checks by providing a `KeyCompareMap` with those keys you want to compute\n * explicitly different\n *\n * @example\n *\n * // An example with a custom comparison applied to each key\n * import { of } from 'rxjs';\n * import { selectSlice } from 'rx-angular/state';\n *\n *\n * const state$: Observable<MyState> = of(\n *  { title: 'myTitle', panelOpen: true},\n *  { title: 'myTitle2', panelOpen: true},\n *  { title: 'newTitle', panelOpen: true},\n *  { title: 'newTitle', panelOpen: false}\n * )\n * .pipe(\n *     selectSlice(['title', 'panelOpen']),\n *   )\n *   .subscribe(x => console.log(x));\n *\n * // displays:\n * //  { title: 'myTitle', panelOpen: true },\n * //  { title: 'myTitle2', panelOpen: true },\n * //  { title: 'newTitle', panelOpen: true },\n * //  { title: 'newTitle', panelOpen: false }\n *\n * @example\n *\n * import { of, Observable } from 'rxjs';\n * import { tap } from 'rxjs/operators';\n * import { selectSlice } from 'rx-angular/state';\n *\n * interface MyState {\n *    title: string;\n *    items: string[];\n *    panelOpen: boolean;\n * }\n * // Select items and title.\n * // apply custom compare logic for the items array\n * const customComparison: KeyCompareMap<MyState> = {\n *   items: (oldItems, newItems) => compareItems(oldItems, newItems)\n * };\n * const state$: Observable<MyState> = of(\n * { title: 'myTitle', items: ['foo', 'bar'], panelOpen: true },\n * { title: 'myTitle', items: ['foo', 'bar'], panelOpen: false },\n * { title: 'nextTitle', items: ['foo', 'baR'], panelOpen: true },\n * { title: 'nextTitle', items: ['fooRz', 'boo'], panelOpen: false },\n * );\n * const slice$ = state$.pipe(selectSlice(['title', 'items'], customComparison), tap(console.log)).subscribe();\n *\n * // displays:\n * // { title: 'myTitle', items: ['foo', 'bar'] }\n * // { title: 'nextTitle', items: ['foo', 'baR'] }\n * // { title: 'nextTitle', items: ['fooRz', 'boo'] }\n *\n * @param {(K)[]} keys - the array of keys which should be selected\n * @param {KeyCompareMap<{ [P in K]: T[P] }>} [keyCompareMap] Optional KeyCompareMap to provide custom compare logic\n * for some the keys\n * @docsPage selectSlice\n * @docsCategory operators\n */\nfunction selectSlice(keys, keyCompareMap) {\n    return (o$) => o$.pipe(filter((state) => state !== undefined), map((state) => {\n        // forward null\n        if (state === null) {\n            return null;\n        }\n        // an array of all keys which exist and are _defined_ in the state object\n        const definedKeys = keys\n            // filter out undefined properties e. g. {}, { str: undefined }\n            .filter((k) => state.hasOwnProperty(k) && state[k] !== undefined);\n        // we want to ensure to only emit _valid_ selections\n        // a selection is _valid_ if every selected key exists and has a value:\n        // {} => selectSlice(['foo']) => no emission\n        // {str: 'test'} => selectSlice([]) => no emission\n        // {str: 'test'} => selectSlice(['notPresent']) => no emission\n        // {str: 'test'} => state.select(selectSlice([])) => no emission\n        // {str: 'test'} => state.select(selectSlice(['notPresent'])) => no emission\n        // {str: undefined} => state.select(selectSlice(['str'])) => no emission\n        // {str: 'test', foo: undefined } => state.select(selectSlice(['foo'])) => no emission\n        if (definedKeys.length < keys.length) {\n            return undefined;\n        }\n        // create the selected slice\n        return definedKeys\n            .reduce((vm, key) => {\n            vm[key] = state[key];\n            return vm;\n        }, {});\n    }), filter((v) => v !== undefined), distinctUntilSomeChanged(keys, keyCompareMap));\n}\n\n/**\n * @internal\n */\nfunction select(...opOrMapFn) {\n    return (state$) => {\n        if (!opOrMapFn || opOrMapFn.length === 0) {\n            return state$.pipe(stateful());\n        }\n        else if (isStringAndFunctionTupleGuard(opOrMapFn)) {\n            return state$.pipe(stateful(map((s) => opOrMapFn[1](s[opOrMapFn[0]]))));\n        }\n        else if (isStringArrayFunctionAndOptionalObjectTupleGuard(opOrMapFn)) {\n            return state$.pipe(selectSlice(opOrMapFn[0], opOrMapFn[2]), stateful(map(opOrMapFn[1])));\n        }\n        else if (isStringArrayGuard(opOrMapFn)) {\n            return state$.pipe(stateful(pluck(...opOrMapFn)));\n        }\n        else if (isOperateFnArrayGuard(opOrMapFn)) {\n            return state$.pipe(stateful(pipeFromArray(opOrMapFn)));\n        }\n        else {\n            throw new Error('wrong params passed to select');\n        }\n    };\n}\n\nfunction createSideEffectObservable(stateObservables = new Subject()) {\n    const effects$ = merge(stateObservables.pipe(mergeAll(), observeOn(queueScheduler)));\n    function nextEffectObservable(effect$) {\n        stateObservables.next(effect$);\n    }\n    function subscribe() {\n        return effects$.subscribe();\n    }\n    return {\n        effects$,\n        nextEffectObservable,\n        subscribe\n    };\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { createAccumulationObservable, createSideEffectObservable, distinctUntilSomeChanged, isDefined, isKeyOf, isObjectGuard, isOperateFnArrayGuard, isStringAndFunctionTupleGuard, isStringArrayFunctionAndOptionalObjectTupleGuard, isStringArrayGuard, pipeFromArray, safePluck, select, selectSlice, stateful };\n"],"mappings":"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,IAAI,CAACD,WAAW,CAAC,CAAChC,MAAM,KAAK,CAAC,EAAE;IACvC,OAAON,SAAS;EACpB;EACA,IAAIyC,IAAI,GAAGH,WAAW,CAACE,OAAO,CAACE,KAAK,EAAE,CAAC;EACvCF,OAAO,CAACG,OAAO,CAACC,GAAG,IAAI;IACnB,IAAI1B,aAAa,CAACuB,IAAI,CAAC,IAAI3B,OAAO,CAAC8B,GAAG,CAAC,EAAE;MACrCH,IAAI,GAAGA,IAAI,CAACG,GAAG,CAAC;IACpB;EACJ,CAAC,CAAC;EACF,OAAOH,IAAI;AACf;;AAEA;AACA;AACA;AACA,SAASI,cAAc,CAACC,MAAM,EAAEC,MAAM,EAAE;EACpC,OAAOD,MAAM,KAAKC,MAAM;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,wBAAwB,CAACT,IAAI,EAAEU,aAAa,EAAE;EACnD;EACA,IAAIC,eAAe,GAAG,CAACC,QAAQ,EAAEvE,QAAQ,KAAK2D,IAAI,CAACa,IAAI,CAAER,GAAG,IAAK,CAACC,cAAc,CAACR,SAAS,CAACc,QAAQ,EAAE,CAACP,GAAG,CAAC,CAAC,EAAEP,SAAS,CAACzD,QAAQ,EAAE,CAACgE,GAAG,CAAC,CAAC,CAAC,CAAC;EACzI;EACA,IAAIK,aAAa,KAAKjD,SAAS,EAAE;IAC7B,MAAMqD,OAAO,GAAIT,GAAG,IAAK;MACrB,OAAOK,aAAa,CAACK,cAAc,CAACV,GAAG,CAAC,IACpCK,aAAa,CAACL,GAAG,CAAC,KAAK5C,SAAS,GAC9BiD,aAAa,CAACL,GAAG,CAAC,GAClBC,cAAc;IACxB,CAAC;IACDK,eAAe,GAAG,CAACC,QAAQ,EAAEvE,QAAQ,KAAK;MACtC,OAAO2D,IAAI,CAACa,IAAI,CAAER,GAAG,IAAK,CAACS,OAAO,CAACT,GAAG,CAAC,CAACP,SAAS,CAACc,QAAQ,EAAE,CAACP,GAAG,CAAC,CAAC,EAAEP,SAAS,CAACzD,QAAQ,EAAE,CAACgE,GAAG,CAAC,CAAC,CAAC,CAAC;IACpG,CAAC;EACL;EACA,OAAO3F,oBAAoB,CAAC,CAACsG,IAAI,EAAEC,IAAI,KAAK,CAACN,eAAe,CAACK,IAAI,EAAEC,IAAI,CAAC,CAAC;AAC7E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,WAAW,CAAClB,IAAI,EAAEU,aAAa,EAAE;EACtC,OAAQS,EAAE,IAAKA,EAAE,CAAClF,IAAI,CAACd,MAAM,CAAEe,KAAK,IAAKA,KAAK,KAAKuB,SAAS,CAAC,EAAEpC,GAAG,CAAEa,KAAK,IAAK;IAC1E;IACA,IAAIA,KAAK,KAAK,IAAI,EAAE;MAChB,OAAO,IAAI;IACf;IACA;IACA,MAAMkF,WAAW,GAAGpB;IAChB;IAAA,CACC7E,MAAM,CAAEqD,CAAC,IAAKtC,KAAK,CAAC6E,cAAc,CAACvC,CAAC,CAAC,IAAItC,KAAK,CAACsC,CAAC,CAAC,KAAKf,SAAS,CAAC;IACrE;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI2D,WAAW,CAACrD,MAAM,GAAGiC,IAAI,CAACjC,MAAM,EAAE;MAClC,OAAON,SAAS;IACpB;IACA;IACA,OAAO2D,WAAW,CACbhC,MAAM,CAAC,CAACiC,EAAE,EAAEhB,GAAG,KAAK;MACrBgB,EAAE,CAAChB,GAAG,CAAC,GAAGnE,KAAK,CAACmE,GAAG,CAAC;MACpB,OAAOgB,EAAE;IACb,CAAC,EAAE,CAAC,CAAC,CAAC;EACV,CAAC,CAAC,EAAElG,MAAM,CAAEwE,CAAC,IAAKA,CAAC,KAAKlC,SAAS,CAAC,EAAEgD,wBAAwB,CAACT,IAAI,EAAEU,aAAa,CAAC,CAAC;AACtF;;AAEA;AACA;AACA;AACA,SAASY,MAAM,CAAC,GAAGC,SAAS,EAAE;EAC1B,OAAQ7E,MAAM,IAAK;IACf,IAAI,CAAC6E,SAAS,IAAIA,SAAS,CAACxD,MAAM,KAAK,CAAC,EAAE;MACtC,OAAOrB,MAAM,CAACT,IAAI,CAACsD,QAAQ,EAAE,CAAC;IAClC,CAAC,MACI,IAAIT,6BAA6B,CAACyC,SAAS,CAAC,EAAE;MAC/C,OAAO7E,MAAM,CAACT,IAAI,CAACsD,QAAQ,CAAClE,GAAG,CAAEoE,CAAC,IAAK8B,SAAS,CAAC,CAAC,CAAC,CAAC9B,CAAC,CAAC8B,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAC3E,CAAC,MACI,IAAIxC,gDAAgD,CAACwC,SAAS,CAAC,EAAE;MAClE,OAAO7E,MAAM,CAACT,IAAI,CAACiF,WAAW,CAACK,SAAS,CAAC,CAAC,CAAC,EAAEA,SAAS,CAAC,CAAC,CAAC,CAAC,EAAEhC,QAAQ,CAAClE,GAAG,CAACkG,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAC5F,CAAC,MACI,IAAIrD,kBAAkB,CAACqD,SAAS,CAAC,EAAE;MACpC,OAAO7E,MAAM,CAACT,IAAI,CAACsD,QAAQ,CAACjE,KAAK,CAAC,GAAGiG,SAAS,CAAC,CAAC,CAAC;IACrD,CAAC,MACI,IAAI5D,qBAAqB,CAAC4D,SAAS,CAAC,EAAE;MACvC,OAAO7E,MAAM,CAACT,IAAI,CAACsD,QAAQ,CAACP,aAAa,CAACuC,SAAS,CAAC,CAAC,CAAC;IAC1D,CAAC,MACI;MACD,MAAM,IAAIC,KAAK,CAAC,+BAA+B,CAAC;IACpD;EACJ,CAAC;AACL;AAEA,SAASC,0BAA0B,CAAC5F,gBAAgB,GAAG,IAAIzB,OAAO,EAAE,EAAE;EAClE,MAAMsH,QAAQ,GAAGpH,KAAK,CAACuB,gBAAgB,CAACI,IAAI,CAACtB,QAAQ,EAAE,EAAEC,SAAS,CAACL,cAAc,CAAC,CAAC,CAAC;EACpF,SAASoH,oBAAoB,CAACC,OAAO,EAAE;IACnC/F,gBAAgB,CAACmB,IAAI,CAAC4E,OAAO,CAAC;EAClC;EACA,SAAS9E,SAAS,GAAG;IACjB,OAAO4E,QAAQ,CAAC5E,SAAS,EAAE;EAC/B;EACA,OAAO;IACH4E,QAAQ;IACRC,oBAAoB;IACpB7E;EACJ,CAAC;AACL;;AAEA;AACA;AACA;;AAEA,SAASlB,4BAA4B,EAAE6F,0BAA0B,EAAEhB,wBAAwB,EAAE7B,SAAS,EAAEL,OAAO,EAAEI,aAAa,EAAEhB,qBAAqB,EAAEmB,6BAA6B,EAAEC,gDAAgD,EAAEb,kBAAkB,EAAEc,aAAa,EAAEc,SAAS,EAAEwB,MAAM,EAAEJ,WAAW,EAAE3B,QAAQ"},"metadata":{},"sourceType":"module","externalDependencies":[]}